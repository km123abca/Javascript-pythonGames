<!DOCTYPE html>
<html>
<head>
    <title> Soldier in a battle field</title>

    <!-- sound divs and scripts-->
    <!-- audio pre script -->
    <script>    
    let musicStarted=false;
    let okToStartMusic=false;////okToStartMusic gets activated once user clicks on the mouse

    var startMusic=()=>{                        
                        if(!musicStarted && okToStartMusic)
                            {
                             musicStarted=true;
                             musicList[presentMusicIndex % musicList.length].play();
                            }   
                        };
    var pauseMusic=()=>{
                        musicStarted=false;
                        for(let i in mCL) mCL[i].src="";
                        for(let i in mCL) 
                            mCL[i].src=`${soundsFolder}/${musicFilesList[i]}`;
                        };

        var resetMusicVar=()=>{
        musicStarted=false;
        startMusic();
        }
    </script>
    <div id="musicContainer"></div>   
    <div id="soundscontainer"></div>   
    <!-- audio post script -->
    <script>
        let soundsFolder="../PlatformGame/sounds";
        var musicContainer=document.querySelector('#musicContainer');
        var musicFilesList=['techno_bg_music.mp3',
                            'Hollow Knight OST - Greenpath.mp3',
                            'Nils_Frahm_Says.mp3'];
        var mCL=[];
        for(let i in musicFilesList){
           var audioElem=document.createElement("audio");
           var audioSourceForAudioElem=document.createElement("source");
           audioSourceForAudioElem.type="audio/mpeg";
           audioSourceForAudioElem.src=`${soundsFolder}/${musicFilesList[i]}`;
           audioElem.appendChild(audioSourceForAudioElem);
           audioElem.onended=resetMusicVar;
           musicContainer.appendChild(audioElem);
           mCL.push(audioElem);
        }       

        var musicList=[mCL[0],mCL[1]];
        var presentMusicIndex=0;
        //creating sound components start
        var soundDivIds=['RockSmash','LossBuzz'];
        var parentSoundDiv=document.getElementById("soundscontainer");
        for(let i in soundDivIds){            
        var audioElem=document.createElement("audio");
        audioElem.id=soundDivIds[i];
        var audioSourceForAudioElem=document.createElement("source");
        audioSourceForAudioElem.type="audio/mpeg";
        audioSourceForAudioElem.src=`${soundsFolder}/${soundDivIds[i]}.wav`;
        audioElem.appendChild(audioSourceForAudioElem);
        parentSoundDiv.appendChild(audioElem);
        }
        //creating sound components end
    </script>
    <!-- sound divs and scripts ends -->
    <script src="scenedata.js"></script>
    <!-- function group1: Basic functions -->
    <script>
    let FPS=60;
    let deltaTime=1000 / FPS;
    let mouseX,mouseY,mousePressed;

    function trackMouse(e)
            {
            mouseX=e.clientX;//e.clientX-15*xscale;
            mouseY=e.clientY;//e.clientY-25*yscale;
            }
    function showMouse()    
            {
        let mx=mouseX+gameManager.camera.position.x;
        let my=mouseY+gameManager.camera.position.y;
        mx=mx.toFixed(2);
        my=my.toFixed(2);
        w2screen(`${mx},${my}`,canvas.width/2,200);
            }
    const w2screen=(strr = "", px = 20, py = 30,fillStyle="#FFFFFF",siz=40) =>
            {
          ctx.font = `${siz}px Haettenschweiler`;
          ctx.fillStyle = fillStyle;
          ctx.fillText(strr, px, py);
            }
    class CreateVector
        {
        constructor(x,y)
            {
             this.x=x;
             this.y=y;  
            }       
        set(x,y)
            {
             this.x=x;
             this.y=y;
             return this;
            }
        setVec(vec)
            {
             this.x=vec.x;
             this.y=vec.y;           
            }
        mag()
            {
             return Math.sqrt(this.x**2+this.y**2);
            }
        add(vec)
            {
            this.x+=vec.x;
            this.y+=vec.y;
            return this;
            }
        sub(vec)
            {
            this.x-=vec.x;
            this.y-=vec.y;
            return this;
            }
        mult(num)
            {
            this.x*=num;
            this.y*=num;
            return this;
            }
        div(num)
            {
            if(num==0)
                {
                 alert("div by 0:!!!");
                 return new CreateVector(0,0);
                }
            this.x/=num;
            this.y/=num;
            return this;
            }
        normalize()
            {
            let mag=this.mag();
            if(mag==0) return this;
            this.x/=mag;
            this.y/=mag;
            return this;
            }
        normalized()
            {
             return this.copy().normalize();
            }
        copy()
            {
            let copyVec=new CreateVector(this.x,this.y);
            return copyVec;
            }
        equals(vec)
            {
             return this.x==vec.x && this.y==vec.y;
            }
        desc()
            {
            return `Vector:${this.x},${this.y}`
            }
        heading()
            {
            let angx=Math.atan2(this.y,this.x)/Math.PI*180;
            return angx<0?angx+360:angx;
            }
        pointToAngle(angle)
            {
            let mag=this.mag();
            this.x=mag*Math.cos(angle/180*Math.PI);
            this.y=mag*Math.sin(angle/180*Math.PI);         
            return this;
            }
        rotateByAngle(delta)
            {
            let ang=this.heading();
            return this.pointToAngle(ang+delta);
            }
        dot(vec)
            {
            return this.x*vec.x+this.y*vec.y;
            }    
        announce()
            {
             return this.x.toFixed(2)+','+this.y.toFixed(2);
            }   
        }
    function Get_A_Point(src,dist,angle){
        let res= new CreateVector(dist,0);
        res.pointToAngle(angle);
        return src.copy().add(res);
    }
    function PointInsideObject(objToCheck,pt)
        {
        if (pt.x >= objToCheck.position.x-objToCheck.width/2 && pt.x <= objToCheck.position.x+objToCheck.width/2)
        if (pt.y >= objToCheck.position.y-objToCheck.height/2 && pt.y <= objToCheck.position.y+objToCheck.height/2)
            return true
        return false
        }
    function Raycast(originx,direction,lenx,objToCheck)
        {
        //graphic   
         /*      
         Draw_a_line(originx.copy().add(new CreateVector(0,0)),
                     originx.copy().add(new CreateVector(0,0)).add(direction.copy().mult(lenx))
                    );  
         */  
        //graphic

        let origin=originx.copy();
        let destin=originx.copy().add(direction.copy().mult(lenx)); 
        let deltaz=2*xscale
        let startLen=0

        while (startLen < lenx)
            {
            if (PointInsideObject(objToCheck,origin.add(direction.copy().mult(deltaz))) )
                return true
            startLen+=deltaz
            }
        return false
        }
    function RaycastAll(originx,direction,lenx,arrOfArrObjs,arrAvoid)
        {
        
        //graphic            
         Draw_a_line(originx.copy().add(new CreateVector(0,0)),
                     originx.copy().add(new CreateVector(0,0)).add(direction.copy().mult(lenx))
                    );       
        //graphic

        let origin=originx.copy();
        let destin=originx.copy().add(direction.copy().mult(lenx)); 
        let deltaz=2*xscale
        let startLen=0
            

        while (startLen < lenx)
            {
            for(let objxArr of arrOfArrObjs)
                for(let objToCheck of objxArr)
                {
                 let skipFlag=false;
                 for(let avoidObj of arrAvoid)
                    {                   
                    if(avoidObj==objToCheck)
                        {
                        skipFlag=true;
                        break;  
                        }
                    }
                 if (skipFlag) continue;

                 if (PointInsideObject(objToCheck,origin.add(direction.copy().mult(deltaz))) )
                    {
                     console.log('reporting hit inside '+objToCheck.sprite_type);
                     return true;
                    }
                }
            startLen+=deltaz;
            }
        return false
        }
    //collision check algorithm starts
    function b_collision(obj1,obj2)
        {
         let cornerPoints1=[obj1.position.copy().add(new CreateVector(-obj1.width/2,-obj1.height/2)),
                           obj1.position.copy().add(new CreateVector(-obj1.width/2, obj1.height/2)),
                           obj1.position.copy().add(new CreateVector( obj1.width/2,-obj1.height/2)),
                           obj1.position.copy().add(new CreateVector( obj1.width/2, obj1.height/2))
                          ];
         let cornerPoints2=[obj2.position.copy().add(new CreateVector(-obj2.width/2,-obj2.height/2)),
                            obj2.position.copy().add(new CreateVector(-obj2.width/2, obj2.height/2)),
                            obj2.position.copy().add(new CreateVector( obj2.width/2,-obj2.height/2)),
                            obj2.position.copy().add(new CreateVector( obj2.width/2, obj2.height/2))
                          ];
         cornerPoints1=cornerPoints1.map(x=>obj1.position.copy().add(x.copy().sub(obj1.position).rotateByAngle(obj1.angle)) );
         cornerPoints2=cornerPoints2.map(x=>obj2.position.copy().add(x.copy().sub(obj2.position).rotateByAngle(obj2.angle)) );
         return ArePointsInside(cornerPoints1,obj2)||ArePointsInside(cornerPoints2,obj1);
        }
    function ArePointsInside(pts,obj2)
        {
        let ptsy=pts.map(x=>GetRAVec(x,obj2.angle));
        let objx={position:GetRAVec(obj2.position,obj2.angle),width:obj2.width,height:obj2.height};
        for(let pt of ptsy)
            {
             if(PointInsideObject(objx,pt)) return true;
            }
        return false;
        }
    //collision check algorithm ends
    //simple box collsion check
    function collisioncheckzVec(elem1,elem2)
                {
            return (inter_ects(elem1.position.x-elem1.width/2,elem1.position.y-elem1.height/2,
                               elem1.width,elem1.height,
                               elem2.position.x-elem2.width/2,elem2.position.y-elem2.height/2,
                               elem2.width,elem2.height
                              )
                   );
                }
    function circularCollision(elem1,elem2)
        {
            let centerSeperation=elem1.position.copy();
            centerSeperation.sub(elem2.position);
            centerSeperation=centerSeperation.mag();
            return centerSeperation < elem1.width/2+elem2.width/2;
        }
    function inter_ects(q1,q2,ql1,ql2,w1,w2,wl1,wl2)
                {
                if(w1>=q1)
                    {
                    if((w1-q1)<ql1)
                        {
                        if(w2>=q2)
                            {
                            if((w2-q2)<ql2) return true;
                            return false;
                            }
                        else
                            {
                            if((q2-w2)<wl2) return true;
                            return false;
                            }
                        }
                    }
                else
                    {
                    if((q1-w1)<wl1)
                        {
                        if(w2>=q2)
                            {
                            if((w2-q2)<ql2) return true;
                            return false;
                            }
                        else
                            {
                            if((q2-w2)<wl2) return true;
                            return false;
                            }
                        }
                    }
                }
    //simple box collision check ends
    function GetRAVec(a,angle)
        {
            let t=d2r(angle);
            let xval= a.x * Math.cos(t)+a.y * Math.sin(t);
            let yval=-a.x * Math.sin(t)+a.y * Math.cos(t);
            return new CreateVector(xval,yval);
        }
    function GetrRAVec(a,angle)
        {
            let t=d2r(angle);
            let xval= a.x * Math.cos(t)-a.y * Math.sin(t);
            let yval= a.x * Math.sin(t)+a.y * Math.cos(t);
            return new CreateVector(xval,yval);
        }
    function d2r(ang)
        {
        return ang/180*Math.PI;
        }
    function r2d(ang)
        {
        return ang/Math.PI*180;
        }
    function Lerp(startValue,endValue,LerpFac)
        {
        return startValue+(endValue-startValue)/LerpFac;
        }
    function AngleLerp(startValue,endValue,lerpFac)
        {
        // console.log('received start:'+startValue);
        // console.log('received end:'+endValue);
        if (Math.abs(endValue - startValue) < SepFrom360(startValue) + SepFrom360(endValue))
            return startValue+(endValue-startValue)/lerpFac 
        return CloseAngleDistance360(startValue,(SepFrom360(startValue)+SepFrom360(endValue))/lerpFac )
        }
    function SepFrom360(angle)
        {
        if (angle < 180)
            return angle
        return 360 - angle
        }
    function CloseAngleDistance360(startAngle,delta)
        {
        if (startAngle < 180)
            {
            if (startAngle > delta)
                return startAngle - delta;
            return 360 - (delta - startAngle);
            }
        else
            {
             if (360 - startAngle > delta)
                return startAngle + delta;
             return delta - (360 - startAngle);
            }
        }
    function LoadImages(folderPath,imageNames)
        {
        let result=[];
        for(let imgx of imageNames)
            {
            let createdImage=new Image();
            // console.log('./'+folderPath+'/'+imgx);
            try
                {
                createdImage.src=folderPath+'/'+imgx;
                }
            catch(err)
                {
                console.log(err);               
                }
            result.push(createdImage);
            }
        return result;
        }
    function LoadImagex(folderPath,imageName)
        {
            let createdImage= new Image();
            createdImage.src=folderPath+'/'+imageName;
            return createdImage;
        }
    function LoadImagexArray(imagePathArray)
        {
            let outputArray=[];
            for(let individualImagePath of imagePathArray)
                {
                 let createdImage= new Image();
                 createdImage.src=individualImagePath;  
                 outputArray.push(createdImage); 
                }            
            return outputArray;
        }

    let tempTimer=0;
    function DisplayInGaps(strx)
        {
         if(gameManager.runningClock - tempTimer > 2000)
            {
              tempTimer=gameManager.runningClock;
              console.log(strx);
            }
        }

    function Draw_a_line(startPos,endPos,color='#FF0000')
        {
        ctx.strokeStyle=color;
        ctx.beginPath();
        ctx.moveTo(startPos.x - gameManager.camera.position.x,startPos.y - gameManager.camera.position.y);
        ctx.lineTo(endPos.x - gameManager.camera.position.x,endPos.y - gameManager.camera.position.y);
        ctx.stroke();
        }

    function destroySelf(objx)
        {             
             for(let i in objx.spriteGroups)
             {        
              for(let j in objx.spriteGroups[i])
                {

                 if(objx.spriteGroups[i][j]==objx)
                    {     
                      objx.spriteGroups[i].splice(j,1);
                      break;
                    }   
                }
             }
         
        }



	
    </script>


</head>
<body style='background-color:black;'>
    <canvas style='border:3px solid black;' onmousemove="trackMouse(event)"></canvas>
    
    <!-- function group2: functions and variables that run the game -->
    <script>
    var canvas = document.querySelector('canvas');
    ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth-35;
    canvas.height = window.innerHeight-100;    
    let xscale=canvas.width/931;
    let yscale=canvas.height/561;
    var resize = function () 
        {
        canvas.width = window.innerWidth-35;
        canvas.height = window.innerHeight-100;
        };
    window.addEventListener('resize', resize);
    canvas.addEventListener('contextmenu', function(event) {
    event.preventDefault();
    });
    let upArrow=false,leftArrow=false,rightArrow=false,downArrow=false;
    let keysPressed=new Set();
    CapturePressedKey=(keyCode,pressed=true)=>{
        if(!((keyCode>64 && keyCode<91)||(keyCode > 96 && keyCode < 123)||(keyCode==32))) return false;
        let charx=String.fromCharCode(keyCode);
        let charx2=String.fromCharCode(keyCode+32);     
        if(pressed && !keysPressed.has(charx))          
            keysPressed.add(charx);
        else if(!pressed)
            {
             keysPressed.delete(charx);
             keysPressed.delete(charx2);
            }
    }

    GetKeyPressedx=(x)=>{
        return keysPressed.has(x)||keysPressed.has(x.toUpperCase());
    }
    let pressedKeyCode=-1;
    
   
    document.onkeydown=function(e)
                     {
                        // console.log(e.keyCode);
                        // CapturePressedKey(e.keyCode);                
                        
                        if(e.keyCode==37) leftArrow=true;
                        if(e.keyCode==38) upArrow=true;
                        if(e.keyCode==39) rightArrow=true;
                        if(e.keyCode==40) downArrow=true;
                     }
    let spacePress,enterPress,upPress,rightPress,downPress,leftPress;
    let mouseRightPressed=false;
    document.onkeypress=function (e)
                    {
                    pressedKeyCode=e.keyCode;
                    // console.log(e.keyCode);  
                    CapturePressedKey(e.keyCode);       
                    if(e.keyCode==32) spacePress=true;
                    if(e.keyCode==119) upPress=true;
                    if(e.keyCode==100) rightPress=true;
                    if(e.keyCode==115) downPress=true;
                    if(e.keyCode==97) leftPress=true;                  
                    if(e.keyCode==13)  enterPress=true;                     
                    if(e.keyCode==112)                        
                        gameManager.gamePaused=!gameManager.gamePaused;//This is the code for p                        
                          
                    };
    document.onkeyup=function (e)
                    {   
                    // console.log(e.keyCode);
                    pressedKeyCode=-1;
                    CapturePressedKey(e.keyCode,false);
                    if(e.keyCode==32) spacePress=false;                 
                    if(e.keyCode==87) upPress=false;
                    if(e.keyCode==68) rightPress=false;
                    if(e.keyCode==83) downPress=false;
                    if(e.keyCode==65) leftPress=false;
                    
                    if(e.keyCode==13)  enterPress=false;                  

                    if(e.keyCode==37) leftArrow=false;
                    if(e.keyCode==38) upArrow=false;
                    if(e.keyCode==39) rightArrow=false;
                    if(e.keyCode==40) downArrow=false;
                    };
    document.onmousedown=function(e)
                    {
                    //okToStartMusic gets activated once user clicks on the mouse
                    if(!okToStartMusic)
                        {
                         okToStartMusic=true;
                         startMusic();
                        }

                    if(processMouseClick(e)==1)
                    mousePressed=true;  
                    else
                    mouseRightPressed=true;                                                
                    };  
    document.onmouseup=function(e)
                    {
                    if(processMouseClick(e)==1)
                    mousePressed=false;   
                    else
                    mouseRightPressed=false;                                          
                    };

    function processMouseClick(e)
        {
            e=e||window.event;
            if('which' in e){
                return e.which;
            }
            return 1;
        }

   /*
document.onmousedown = function(event) {
  event = event || window.event;
  
  if ('which' in event) {
    // For modern browsers
    if (event.which === 1) {
      // Left mouse click
      // Handle left click here
    } else if (event.which === 3) {
      // Right mouse click
      // Handle right click here
    }
  } else if ('button' in event) {
    // For older IE browsers
    if (event.button === 0) {
      // Left mouse click
      // Handle left click here
    } else if (event.button === 2) {
      // Right mouse click
      // Handle right click here
    }
  }
};

   */

//Game classes start
    //1. Camera starts
    class Camera
        {
          constructor()
            {
             this.position=new CreateVector(0,0);
             this.mouseLockX=0;
             this.mouseLockY=0; 
             this.tgt=null;   
             this.lerpFactor=4;  
            }
          runWithMouse()
            {
             if(mousePressed)
                {   
                if(this.mouseLockX==0)
                    {
                    this.mouseLockX=mouseX;                 
                    }
                if(this.mouseLockY==0)
                    {
                    this.mouseLockY=mouseY;
                    }
                this.position.x-=(mouseX-this.mouseLockX)/10;
                this.position.y-=(mouseY-this.mouseLockY)/10;
                }
             else
                {
                if(this.mouseLockX!=0) this.mouseLockX=0;
                if(this.mouseLockY!=0) this.mouseLockY=0;
                }
            }
          smoothFocus(followH,followV)
            {
             if(!this.tgt) return false;
             // if(!this.tgt || !this.tgt.isActive) return false;
             // DisplayInGaps(`camera is following ${this.tgt.sprite_type}`);
             // DisplayInGaps(`camera position is ${this.position.announce()} and tgt is at ${this.tgt.position.announce()}, ${canvas.width/2},${canvas.height}`)
             if(followH)
                this.position.x=Lerp(this.position.x,this.tgt.position.x-canvas.width/2,this.lerpFactor);
             if(followV)
                this.position.y=Lerp(this.position.y,this.tgt.position.y-canvas.height/2,this.lerpFactor);
            }

        }
    //1. Camera Ends
    //3. Indicator Objs start
    class IndicatorObjs
        {
        constructor(x,y,colorx,sprite_type,spriteGroups)
            {
             this.position=new CreateVector(x,y);
             this.sprite_type=sprite_type;
             this.angle=0;
             this.colorx=colorx;
             this.rad=20*xscale;
             for(let grp of spriteGroups)
                grp.push(this);
             this.onScreen=true;
             this.width=111;
             this.height=111;
            }
        display()
            {   
            if(!this.onScreen) return false;                
            ctx.save();         
            ctx.translate(this.position.x - gameManager.camera.position.x,this.position.y - gameManager.camera.position.y); 
            ctx.fillStyle=this.colorx;
            ctx.strokeStyle=this.colorx;                
            ctx.beginPath();
            ctx.arc(0,0,this.rad,0,2*Math.PI);
            ctx.fill();
            ctx.stroke();
            ctx.restore();
            w2screen(this.sprite_type,
                     this.position.x-gameManager.camera.position.x,
                     this.position.y-50*yscale-gameManager.camera.position.y);
            }
        }
  //3. Indicator Objs end
  //7 EntryExitPoint start
    class EntryExitPoint extends IndicatorObjs
        {
        constructor(x,y,sprite_type,spriteGroups)
            {
              super(x,y,'#0000FF',sprite_type,spriteGroups);             
            }
         update()
          { 
            return false;
          }
        }
  //EntryExitPoint end
  //5. Hitbox starts
    class HitBox
        {
         constructor(x,y,wid,hei,spriteGroups,hitboxName="unknown hitbox",parent=false)
            {
             this.position= new CreateVector(x,y);
             this.width = wid;
             this.height= hei;
             this.onScreen=true;
             this.sprite_type=hitboxName;
             this.angle=0;
             this.spriteGroups=spriteGroups;
             for(let grp of spriteGroups)
                grp.push(this);
             this.parent=parent;
            }
         update()
            {
             return true;
            }
         updatePosition(pos)
            {
             if(!this.position.equals(pos))
                this.position.setVec(pos);      
            }
         display()
            {            
             if(!this.onScreen) return false;
             ctx.save();
             ctx.translate(this.position.x-gameManager.camera.position.x, 
                           this.position.y-gameManager.camera.position.y);
             ctx.rotate(d2r(this.angle));
             // ctx.scale(this.sx,this.sy);
             ctx.fillStyle='#b3ffff';
             ctx.strokeStyle='#00FF00';
             ctx.beginPath();
             ctx.rect(-this.width/2,-this.height/2,this.width,this.height);
             ctx.stroke();
             ctx.fill();             
             ctx.restore();
            }

        }
  //5. Hitbox ends
  //14 Damage hitbox starts
  class DamageHitBox extends HitBox
        {
         constructor(x,y,wid,hei,offsetx,offsety,damage,hitback,
                     spriteGroups,hitboxName="unknown hitbox",parent=false)
          {
            
            let tempPos=new CreateVector(x,y);
            let tempOffset=new CreateVector(offsetx,offsety);            
            // tempPos.add(tempOffset.pointToAngle(parent.angle));
            tempPos.add(tempOffset);
            super(tempPos.x,tempPos.y,wid,hei,spriteGroups,hitboxName,parent);
            this.hitback=hitback; 
            this.birthTime=gameManager.runningClock;
            this.lifeSpan=1000; 
            this.dmg=damage;        
          } 
          update(){
            this.checkLife();
          }  
          checkLife(){
            if(gameManager.runningClock - this.birthTime > this.lifeSpan){
                this.onScreen=false;
                destroySelf(this);
            }
          }
        causeDamage(go)
            {
              go.takeDamage(this.dmg,this.hitback);             
              destroySelf(this);
              SpawnClouds(this.position);            
            }
        }
  //14 Damage hitbox ends
  //8. Camera stop sprites
    class CameraStopper extends IndicatorObjs
        {
        constructor(x,y,sprite_type,spriteGroups)
          {
            super(x,y,'#00FF00',sprite_type,spriteGroups);
            // this.sprite_type=sprite_type;
            if(sprite_type=='camstopper_right') gameManager.bottomY=y;
          }
        cameraCanFollow(objx)
          {
            let resultArray=[true,true];
            if((this.sprite_type=='camstopper_left' && objx.position.x < this.position.x) ||
               (this.sprite_type=='camstopper_right' && objx.position.x > this.position.x)
              )
                resultArray[0]=false;//return [false,true];
            if((this.sprite_type=='camstopper_left' && objx.position.y < this.position.y) ||
               (this.sprite_type=='camstopper_right' && objx.position.y > this.position.y)
              )
                resultArray[1]=false;//return [true,false];
            return resultArray;//return [true,true];
          }
         update()
          {     
          if(!gameManager.player) return false;  
          if(gameManager.camera.tgt==this)
            {            
             switch(this.sprite_type)
                {
                 case 'camstopper_left':
                    if(gameManager.player.position.x > this.position.x)
                        gameManager.camera.tgt=gameManager.player;
                        break;
                 case 'camstopper_right':
                    if(gameManager.player.position.x < this.position.x)
                        gameManager.camera.tgt=gameManager.player;
                        break;
                }
            }
          }
        }
  //8. Camera stop sprites ends
  //11. SceneChanger
    class SceneChanger extends IndicatorObjs
        {
        constructor(x,y,sprite_type,spriteGroups)
            {
              super(x,y,'#00FFFF',sprite_type,spriteGroups);
              // this.sprite_type=sprite_type;
              this.width=50*xscale;
              this.height=200*yscale;
              this.cornerPts=[[-1,-1],[1,-1],[1,1],[-1,1]];
              this.cornerPts=this.cornerPts.map(x=>[x[0]*this.width/2,x[1]*this.height/2]);
              this.usedAlready=false;
              
            }
        update()
            {       
             if(this.usedAlready)
                {
                    return false;
                }    
             if(!gameManager.player) return false; 
             if(!gameManager.inTransition && b_collision(this,gameManager.player))
                {  
                  console.log('hit scene changer');            
                  this.usedAlready=true;   
                  gameManager.changeScene(this.sprite_type);
                }
            }
        display()
            {           
            if(!this.onScreen)
                return false;
            ctx.save();
            ctx.translate(this.position.x - gameManager.camera.position.x,this.position.y - gameManager.camera.position.y);                          
            ctx.fillStyle=this.colorx;
            ctx.strokeStyle=this.colorx;
            ctx.beginPath();
            ctx.moveTo(this.cornerPts[0][0],this.cornerPts[0][1]);
            for(var g=1;g<this.cornerPts.length;g++)
                ctx.lineTo(this.cornerPts[g][0],this.cornerPts[g][1]);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();               
            ctx.restore();
            }
        }
  //11. SceneChanger ends
  //UI bar starts
    class UIBar
        {
        constructor(x,y,wid,hei,val,maxVal,backgroundColor,mainColor,spriteGroups,screenOverlay=true,offsetx=0,offsety=0,parentObj=null,sprite_type="un_uibar")
            {
             this.position = new CreateVector(x,y);
             this.offset = new CreateVector(offsetx,offsety);
             this.parentObj=parentObj;
             this.width = wid * xscale;
             this.height = hei * yscale;
             this.fixedWidth= this.width;
             this.onScreen = true;
             // this.backgroundColor='#222222';
             this.backgroundColor = backgroundColor;
             this.mainColor = mainColor;
             this.val = val;
             this.maxVal = maxVal;
             this.fixedMaxVal=maxVal;
             this.spriteGroups=spriteGroups;
             for(let grp of this.spriteGroups)
                grp.push(this);
             this.screenOverlay=screenOverlay;
             this.sprite_type=sprite_type;
             this.visibleTimer=0;
             this.maxVisibleTimerValue=1500;

             this.stopDueToError=false;
            }
        setValues(val,maxVal,parentObj)
            {
            
             if(parentObj) this.parentObj=parentObj;
             this.val = val;
             this.maxVal = maxVal;
             if(this.maxVal > this.fixedMaxVal)
                this.width=this.fixedWidth*this.maxVal/this.fixedMaxVal;
            }
        updateValue(val)
            {
             this.val=val;
             this.activateShow();
            }
         display()
            {   

             let camx=0,camy=0;
             if(!this.screenOverlay)
                {
                 camx=gameManager.camera.position.x;
                 camy=gameManager.camera.position.y;
                }        
             if(!this.onScreen) return false;
             

             ctx.save();
             ctx.translate(this.position.x-camx,this.position.y-camy);
             // ctx.rotate(d2r(this.angle));
             // ctx.scale(this.sx,this.sy);
             ctx.beginPath();
             ctx.fillStyle=this.backgroundColor;
             ctx.strokeStyle=this.backgroundColor;
             ctx.lineWidth="6";
             ctx.rect(0,0,this.width,this.height);
             ctx.fill();
             ctx.stroke();
             ctx.beginPath();
             ctx.fillStyle=this.mainColor;
             ctx.strokeStyle=this.backgroundColor;
             ctx.lineWidth="6";
             ctx.rect(0,0,this.width*this.val/this.maxVal,this.height);
             ctx.fill();
             ctx.restore(); 
            }
         activateShow()
            {
             
             this.onScreen=true;
             this.visibleTimer=0;
            }
         update()
            {

             if(this.stopDueToError) return false;
             if(this.screenOverlay) return false;
             

             if(this.onScreen)
                    {   
                    
                    this.visibleTimer+=deltaTime;
                    if(this.visibleTimer > this.maxVisibleTimerValue)
                        {
                         this.visibleTimer=0;
                         this.onScreen=false;
                        }
                    }
            try{
                if(this.parentObj)
                this.position.setVec(this.parentObj.position.copy().add(this.offset));
               }
             catch(err)
                {
                    console.log(err.message);
                    this.stopDueToError=true;
                }
            }
        }
  //UI bar ends
  //2. Gamemanager start
  class GameManager
        {
          constructor()
          {
          this.userName='guest';
          this.camera=new Camera(0,0);
          this.gamePaused=false;
          this.runningClock=0;  
          this.testing=false;
          
          
          this.playerDiedClock=0;

          this.followMouse=false;
          this.visible_sprites=[];
          this.active_sprites=[];
          this.collission_sprites=[];
          this.entryexit_sprites=[];
          this.camera_stop_sprites=[];
          this.enemy_sprites=[];
          this.hit_box_sprites=[];
          this.scenesReady=[];
          this.scenesLoaded=[];
          this.tempCounter=0;
          this.player=null;
          this.playerDied=false;
          this.sceneForward=true;
          this.localStorageChecked=false;
          this.levelUpBox=new LevelUpBox(this.player);

          this.playerHealthBar= new UIBar(50,20,100,15,100,100,'#222222','#FF0000',
                                          [this.visible_sprites,this.active_sprites],
                                          false,0,-50*yscale,this.player,'playerhealth');
          this.playerEnergyBar= new UIBar(50,100,100,15,100,100,'#222222','#0000FF',
                                          [this.visible_sprites,this.active_sprites],
                                           false,0,50*yscale,this.player,'playerenergy');

          //mouse click detection variables
          this.numClicks=0;
          this.clickStartTime=0;
          this.mouseClickTrigger=true;
          this.maxClickGap=500;
          this.mouseRightTrigger=false;
          this.freezeOneFrame=false;

          // new IndicatorObjs(300,300,'#00FF00','indicator',[this.visible_sprites]);
          // new Soldier(300,300,200*xscale,200*yscale,[this.visible_sprites]);
          this.positionAdjuster=new PositionAdjuster(null,[this.visible_sprites,this.active_sprites]);
          }
        
          
          detectMouseClicks()
            {

             if(!mousePressed && !this.gamePaused && this.freezeOneFrame)
                {                
                this.freezeOneFrame=false;
                }
             if(mousePressed && this.mouseClickTrigger && !this.freezeOneFrame)
                {                 
                 this.numClicks+=1;
                 this.clickStartTime=this.runningClock;
                 this.mouseClickTrigger=false;
                }
             else if(!this.mouseClickTrigger && !mousePressed)
                {
                 this.mouseClickTrigger=true;
                }
             if(this.numClicks!=0 && (this.runningClock - this.clickStartTime > this.maxClickGap) )
                {
                 this.numClicks=0;
                }
            }
          runClock()
            {
            this.runningClock+=deltaTime;
            if(this.runningClock > 300000) this.runningClock=0;
            }
          update()
            {            
            this.runClock();
            this.runGame();            
            this.detectMouseClicks();
            if(!this.gamePaused) this.checkScenes();
            this.showLevelUpBox();


            }
           showLevelUpBox()
            {
             this.levelUpBox.update();
             this.levelUpBox.display();
            }
          runGame()
            {
             const [hori,vert]=this.camChecker();
             if(!this.followMouse)
                 {               
                 this.camera.smoothFocus(hori,vert);
                 }
             else
                 {
                    if(this.runningClock - this.sceneStartTime < 2000)                  
                     this.camera.smoothFocus(hori,vert);
                    else
                     this.camera.runWithMouse();
                 }
             for(let sprite of this.visible_sprites)
                {                                              
                sprite.display();
                }
             if(!this.gamePaused)
                 for(let sprite of this.active_sprites)
                    {                                              
                    sprite.update();
                    }
             else
                {
                 gameManager.positionAdjuster.update();
                }

             for(let hb of this.hit_box_sprites)
                {
                 if(gameManager.gamePaused)
                    continue;
                 if(hb.sprite_type=="player_damagebox")
                    {
                     for(let sprite of this.enemy_sprites)
                        {                        
                         if(b_collision(sprite.hit_box,hb))
                            {                               
                             hb.causeDamage(sprite);                                
                            }
                        }
                    }
                 else if(hb.sprite_type=="enemy_damagebox")
                    {
                      if(gameManager.playerDied) continue;                   
                      if(b_collision(gameManager.player.hit_box,hb))
                        {
                        hb.causeDamage(gameManager.player);
                        }
                    }
                }

             this.runUI();
            }
            unPauseGame()
                {
                 this.gamePaused=!this.gamePaused;
                 
                }
            pauseGame()
                {
                    this.gamePaused=true;
                    this.freezeOneFrame=true;
                }
            runUI()
                {
                    if(mouseRightPressed && !this.mouseRightTrigger)
                        {
                        this.mouseRightTrigger=true;
                        // if(!this.levelUpBox.confirmationBox.active)
                        if(this.gamePaused) this.levelUpBox.confirmationBox.active=true;
                        else this.pauseGame();
                        }
                    else if(!mouseRightPressed && this.mouseRightTrigger)
                        this.mouseRightTrigger=false;
                }
           camChecker()
            {
             if(gameManager.playerDied) return [false,false];
             if(!(this.camera.tgt && this.camera.tgt==this.player))
                {  

                return [true,true];
                }
             let resultMat=[true,true];          
             for(let camstopper of this.camera_stop_sprites)
                {
                 resultMat=camstopper.cameraCanFollow(this.player).map((x,i)=>x?resultMat[i]:false);                 
                }
             return resultMat;
            }
        getLocalStoragex(){            
            let localStorage_local = localStorage.getItem("GameSaveDataUserWise");
            if(!localStorage_local) return false;
            localStorage_local= JSON.parse(localStorage_local);
            if (this.userName in localStorage_local)
                return localStorage_local[this.userName];
            return false; 
         }
         saveStatusToLocalStoragex()
            {
            let sceneNo= this.scenesLoaded.filter(x=>x).length;
            let presentUser=this.userName;
            let datum={};
            datum[presentUser]={"sceneNo":sceneNo,
                               "player":{"health":this.player.health,
                                         "maxHealth":this.player.maxHealth,
                                         "weaponDamage":this.player.weaponDamage,
                                         "exp":this.player.experience,
                                         "maxEnergy":this.player.maxEnergy,
                                         "expToll":this.player.experienceToll
                                        },
                                "listOfDestroyedSprites":this.listOfDestroyedSprites
                                };
            localStorage.setItem("GameSaveDataUserWise",JSON.stringify(datum));
            console.log("Game Data saved to local storage");
            }
    applyVelocity(movingObj)
            {                    
             movingObj.hit_box.position.x+=movingObj.velocity.x;         
             for(let k in gameManager.collission_sprites)
                { 
                 let x=gameManager.collission_sprites[k];
                 if(!x.onScreen) continue;
                 if(x==movingObj || x==movingObj.hit_box) continue; 
                                
                 if(b_collision(movingObj.hit_box,x)) 
                    {  
                    
                    movingObj.performSpecTaskOnCollision(x);                           
                    // console.log('collision with '+x.sprite_type);         
                     if(movingObj.velocity.x > 0)
                        {                    
                        movingObj.hit_box.position.x=x.position.x - x.width/2-movingObj.hit_box.width/2-2;                        
                        }
                     else 
                        {
                        movingObj.hit_box.position.x=x.position.x + x.width/2 + movingObj.hit_box.width/2+2;                      
                        }
                    }
                }

             movingObj.hit_box.position.y+=movingObj.velocity.y;           
             for(let x of gameManager.collission_sprites)
                {
                 if(!x.onScreen) continue;
                 if(x==movingObj || x==movingObj.hit_box) continue;                
                 if(b_collision(movingObj.hit_box,x)) 
                    {
                    
                        movingObj.performSpecTaskOnCollision(x);  
                         
                    // console.log('collision with '+x.sprite_type);
                    if(movingObj.velocity.y > 0)
                        {
                        movingObj.hit_box.position.y=x.position.y-x.height/2-movingObj.hit_box.height/2-2;                        
                        }
                    else
                        {
                        movingObj.hit_box.position.y=x.position.y+x.height/2+movingObj.hit_box.height/2+2;                        
                        }
                    }
                }
            }
         applyVelocityRestrictions(movingObj)
            {
            if(movingObj.velocity.mag() < movingObj.maxVelocity) return;
            movingObj.velocity.normalize().mult(movingObj.maxVelocity);         
            }
        update_and_display_hitbox(movingObj,show=false)
            {  
            if(show) movingObj.hit_box.display();         
            movingObj.position.setVec(movingObj.hit_box.position);
            }
         performSpecTaskOnCollision(collidedObjType,dmg)
            {
            let arr=collidedObjType.sprite_type.split('_');
            if(arr.length<2) return false;
            if(arr[1]=='damagable')
                {                  
                collidedObjType.parent.takeDamage(dmg);                      
                }
            }

         
         
         alterSceneData()
            {
            if(this.localStorageChecked)
                {               
                return false;
                }
            this.localStorageChecked=true;           
            let localStoragex=this.getLocalStoragex();
            if(!localStoragex) 
                {
                console.log('nothing in localstorage..returning');
                return true;
                }
            let scene=localStoragex.sceneNo;
            this.player=new Soldier(100*xscale,
                                   200*yscale,
                                   100*xscale,
                                   100*yscale,
                                   [this.visible_sprites,this.active_sprites]
                                  );
            
            if(localStoragex.listOfDestroyedSprites)
                this.listOfDestroyedSprites=localStoragex.listOfDestroyedSprites;
            this.player.receiveParams(localStoragex.player.health,
                                      localStoragex.player.maxHealth,
                                      localStoragex.player.maxEnergy,
                                      localStoragex.player.weaponDamage,
                                      localStoragex.player.exp,
                                      localStoragex.player.expToll                                    
                                     );
            this.levelUpBox.receiveGameObject(this.player);
            console.log('player loaded from memory');
            for(let i=0;i < scene;i++)
                {
                 this.scenesReady[i]=true;
                 this.scenesLoaded[i]=true;
                }
             this.scenesLoaded[this.scenesLoaded.length-1]=false;


            }
         unload_components()
            {
             this.visible_sprites=[];
             this.active_sprites=[];
             this.collission_sprites=[];
             this.camera_stop_sprites=[]; 
             this.entryexit_sprites=[];
             if(!this.player)
                {
                 // this.visible_sprites=[this.positionAdjuster];
                 // this.active_sprites=[this.positionAdjuster];
                }
             else
                {
                 this.visible_sprites=[this.positionAdjuster,this.player,
                                       this.playerHealthBar,this.playerEnergyBar];
                 this.active_sprites=[this.positionAdjuster,this.player,
                                      this.playerHealthBar,this.playerEnergyBar];  
                 this.collission_sprites=[this.player.hit_box];
                 this.player.spriteGroups=[this.visible_sprites,this.active_sprites];
                 this.playerHealthBar.spriteGroups=[this.visible_sprites,this.active_sprites];
                 this.playerEnergyBar.spriteGroups=[this.visible_sprites,this.active_sprites];
                }
            }
         checkScenes()
            {
             this.alterSceneData();
             let n=this.scenesReady.length;          
             if(n==0)
                {
                 this.scenesReady[0]=true;
                 this.scenesLoaded[0]=false;
                 n+=1;
                }
             for(let i=0;i<n;i++)
                 {
                 if(this.scenesReady[i]==true && this.scenesLoaded[i]==false)
                    {
                    if(!(n==1 && this.sceneForward) && !this.testing)
                    this.unload_components();
                    this.loadScene(i);
                    break;
                    }
                 }
            }
         loadScene(n)
            {
            console.log('loading scene:'+n);
            this.tempCounter+=1;
            console.log('gameManager called '+this.tempCounter+ ' times for scene:'+n);
            if(this.tempCounter > 30) 
                {
                console.log('something is wrong');
                console.log(JSON.stringify(this.scenesReady));
                console.log(JSON.stringify(this.scenesLoaded));
                return false;
                }
            for(let elem of scenes[n])
                {
                 if(elem['sprite']=='player' && (this.player) )
                    continue;
                 else if(elem['sprite']=='player')  
                    {                                   
                    this.player=new Soldier(elem['x']*xscale,
                               elem['y']*yscale,
                               elem['width']*xscale,
                               elem['height']*yscale,
                               [this.visible_sprites,this.active_sprites]
                               );  
                    this.camera.tgt=this.player; 
                    console.log('player loaded from scene data');
                   this.levelUpBox.receiveGameObject(this.player);
                   }
                 else if(elem['sprite']=='wall')  
                    {                                   
                    new Wall(elem['x']*xscale,
                               elem['y']*yscale,
                               elem['width']*xscale,
                               elem['height']*yscale,
                               elem['hitboxoffsetx']*xscale,
                               elem['hitboxoffsety']*yscale,
                               elem['isHori'],
                               [this.visible_sprites,this.active_sprites]
                               );                   
                   }
                 else if(elem['sprite'].split('_')[0]=='entryexit')
                    new EntryExitPoint(elem['x']*xscale,
                               elem['y']*yscale,
                               elem['sprite'].split('_')[1],
                               [this.visible_sprites,this.entryexit_sprites,this.active_sprites]
                               );
                 else if(elem['sprite'].split('_')[0]=='camstopper')
                    new CameraStopper(elem['x']*xscale,
                               elem['y']*yscale,
                               elem['sprite'],
                               [this.visible_sprites,this.camera_stop_sprites,this.active_sprites]
                               );
                else if(elem['sprite'].split('_')[0]=='scenechanger')
                    new SceneChanger(elem['x']*xscale,
                               elem['y']*yscale,
                               elem['sprite'].split('_')[1],
                               [this.visible_sprites,this.active_sprites]
                               );
                else if(elem['sprite']=='flower')
                    new Flower(elem['x']*xscale,
                               elem['y']*yscale,
                               elem['width']*xscale,
                               elem['height']*yscale,
                               [this.visible_sprites]
                               );
                else if(elem['sprite']=='zombie')
                    new Zombie(elem['x']*xscale,
                               elem['y']*yscale,
                               elem['width']*xscale,
                               elem['height']*yscale,
                               elem['offsetx']*xscale,
                               elem['offsety']*yscale,
                               [this.visible_sprites,this.active_sprites,this.enemy_sprites],
                               elem['sprite_id']
                               );
                }
            this.placePlayerOnEntryExit(this.sceneForward?'entry':'exit');
            this.camera.tgt=this.camera_stop_sprites[this.sceneForward?0:1];
            this.scenesLoaded[n]=true;           
            this.inTransition=false;
            this.sceneStartTime= this.runningClock;
            console.log('scene No'+n+' loaded');
            presentMusicIndex=n;
            pauseMusic();
            startMusic();
            }
        placePlayerOnEntryExit(ent_ex)
            {
            this.player.stopEverything();
            for(let elem of this.entryexit_sprites)
                {
                if(elem.sprite_type==ent_ex)
                    {
                     console.log(`player placed at ${elem.position.x},${elem.position.y} of ${elem.sprite_type}`);
                     gameManager.player.hit_box.position.setVec(elem.position);
                    }
                }
            }
         changeScene(sc_id)
            {       
             this.inTransition=true;           

             if(sc_id=="scright")
                {
                 console.log('going forward to the next scene');
                 this.sceneForward=true;
                 this.scenesReady.push(true);
                 this.scenesLoaded.push(false);
                }
             else if(sc_id=="scleft")
                {
                console.log('going back to previous scene');
                this.sceneForward=false;
                this.scenesReady.pop();
                this.scenesLoaded.pop();
                this.scenesLoaded[this.scenesLoaded.length-1]=false;
                }
             else
                {

                this.sceneForward=true;
                this.scenesLoaded[this.scenesLoaded.length-1]=false;
                }
            }

        }
//2. Gamemanager ends

//21. Confirmation box starts
   class ConfirmationBox
        {
          constructor(x,y,parentScreen)
            {
              this.position=new CreateVector(x*xscale,y*yscale);
              this.parentScreen=parentScreen;
              this.width=400*xscale;
              this.height=300*yscale;
              this.btnGroups=[];
              this.active=false;
              this.sprite_type="confirmation_box";
              new YesNoButton(410*xscale,360*yscale,
                        80*xscale,80*yscale,'Yes',
                        'square',[this.btnGroups,parentScreen.uiBtns],'Yes',this
                       );
              new YesNoButton(625*xscale,360*yscale,
                        80*xscale,80*yscale,'No',
                        'square',[this.btnGroups,parentScreen.uiBtns],'No',this
                       );
              this.tex_x_pos=410*xscale;
              this.tex_y_pos=240*yscale;
              this.queryTex="Confirm your changes?";
            }
            update()
            {             
             if(!this.active) return false;
                                    
            }
         display()
            {
             if(!this.active) return false;
             ctx.save();
             ctx.translate(this.position.x,this.position.y);
             ctx.fillStyle="#d9b0ad";
             ctx.strokeStyle="#604020";
             ctx.beginPath();
             ctx.rect(-this.width/2,-this.height/2,this.width,this.height);          
             ctx.stroke();
             ctx.fill();             
             ctx.restore();            
             this.displayAndUpdateButtons();
             w2screen(this.queryTex,this.tex_x_pos,this.tex_y_pos);
            }
        displayAndUpdateButtons()
            {
             for(let btn of this.btnGroups)
                {                
                btn.update();
                btn.display();  
                }            
            }
        }
//21. Confirmation box ends
//20. levelup box starts
    class LevelUpBox
        {
         constructor(go)
            {             
             //we may have passed in spritegroups and added the level up box to
             //visible and active, but this is not feasible as we have to display
             //the level up box at the very top of the canvas.
             this.sprite_type="level up box";
             this.go=go;
             this.position=new CreateVector(canvas.width/2,canvas.height/2);
             this.width=800*xscale;
             this.height=600*yscale;
             this.mouseTrigger=true;
             this.uiBtns=[];
             this.confirmationBox=new ConfirmationBox(canvas.width/2,canvas.height/2,this);
             this.btnGroups=[];
             
            this.healthui=new UIBar(210*xscale,108*yscale,200*xscale,40*yscale,
                      100,500,'#CCC','#5CB85C',[this.btnGroups,this.uiBtns],
                      true,0,0,null,"healthuibar"
                     );
            new ArrowButton(this.position.x-300*xscale,this.position.y-150*yscale,
                        50*xscale,50*yscale,'',
                        'leftArrow',[this.btnGroups,this.uiBtns],'HealthLeft',this,this.healthui
                       );
            new ArrowButton(this.position.x+10*xscale,this.position.y-150*yscale,
                        50*xscale,50*yscale,'',
                        'rightArrow',[this.btnGroups,this.uiBtns],'HealthRight',this,this.healthui
                       );
            let weaponui=new UIBar(210*xscale,310*yscale,200*xscale,40*yscale,
                      100,500,'#CCC','#5CB85C',[this.btnGroups,this.uiBtns],
                      true,0,0,null,"weaponuibar"
                     );
            new ArrowButton(this.position.x-300*xscale,this.position.y+50*yscale,
                        50*xscale,50*yscale,'',
                        'leftArrow',[this.btnGroups,this.uiBtns],'WeaponLeft',this,this.weaponui
                       );
            new ArrowButton(this.position.x+10*xscale,this.position.y+50*yscale,
                        50*xscale,50*yscale,'',
                        'rightArrow',[this.btnGroups,this.uiBtns],'WeaponRight',this,this.weaponui
                       );
            
            
            //save and close buttons
            new Button(750*xscale,130*yscale,
                        200*xscale,80*yscale,'Close',
                        'square',[this.btnGroups,this.uiBtns],'Close',this
                       );
            new Button(750*xscale,310*yscale,
                        200*xscale,80*yscale,'Reset',
                        'square',[this.btnGroups,this.uiBtns],'Reset',this
                       );
             this.showSecondScreen=false;
            }
         clickedOutside()
            {
             if(mouseX > this.position.x-this.width/2 && mouseX < this.position.x+this.width/2)
             if(mouseY > this.position.y-this.height/2 && mouseY < this.position.y+this.height/2)
                return false;
             return true;
            }
        receiveGameObject(obj)
            {
             this.go=obj;
             this.healthui.updateValue(this.go.maxHealth);             
            }
         mouseClickDetectedOutside()
            {
            if(this.clickedOutside() && mousePressed && this.mouseTrigger)
                {
                 this.mouseTrigger=false;
                 // gameManager.gamePaused=false;
                 this.confirmationBox.active=true;
                }
            }
         turnBackMouseTriggerOn()
            {
             if(!mousePressed && !this.mouseTrigger)
             this.mouseTrigger=true;
            }
          switchScreen()
            {
                return false;
            }
          showExperience()
            {
             w2screen("Experience: "+this.go.experience,600*xscale,490*yscale);
            }
          update()
            {
             
             if(!gameManager.gamePaused || !gameManager.player) 
                {
                if(this.showSecondScreen) this.switchScreen();
                return false;   
                }       
             this.turnBackMouseTriggerOn();
             this.mouseClickDetectedOutside(); 
                                    
            }
         display()
            {
             if(!gameManager.gamePaused) return false;
             
             ctx.save();
             ctx.translate(this.position.x,this.position.y);
             ctx.fillStyle="#604020";
             ctx.strokeStyle="#604020";
             ctx.beginPath();
             ctx.rect(-this.width/2,-this.height/2,this.width,this.height);          
             ctx.stroke();
             ctx.fill();             
             ctx.restore();
             // if(this.showSecondScreen) this.showKeyReAssignDetails();
             // else this.showStats();
             this.showExperience();
             this.displayAndUpdateButtons();
             
             this.update_and_display_confirmation_box();
            }
        displayAndUpdateButtons()
            {

             for(let btn of this.btnGroups)
                {                
                btn.update();
                btn.display();  
                }            
            }
        update_and_display_confirmation_box()
            {
              this.confirmationBox.update();
              this.confirmationBox.display();
            }

        }
//20. levelup box ends
//21. button starts
class GenericButton
    {
        constructor(x,y,wid,hei,tex,btnType,btnGroups,btnName,parentPanel)
//btnGroups are used for updation and display by parent levelup box        
          {
           this.position=new CreateVector(x,y);
           this.parentPanel=parentPanel;
           this.tex=tex;
           this.sprite_type="generic button";
           this.btnName=btnName;
           this.btnType=btnType;
           this.onScreen=true;
           this.width=wid;
           this.height=hei;
           this.arrowCornerPoints=[[-0.5,-0.5],[0.5,0],[-0.5,0.5]];
           this.mouseOverMe=false;
           this.x_text_offset=-40;
           this.y_text_offset=10;
           
           if(this.btnType=='rightArrow')             
              this.tex='';
           else if (this.btnType=='leftArrow')
             {
              this.tex='';
              this.arrowCornerPoints=[[0.5,-0.5],[-0.5,0],[0.5,0.5]];
             } 
           this.arrowCornerPoints=this.arrowCornerPoints.map(x=>[x[0]*this.width,x[1]*this.height]);  
           this.fillColor='#a3a375';
           this.clickColor='#ccccb3';
           this.btnGroups=btnGroups;
           for(let grp of this.btnGroups)
              {
               grp.push(this);
              }
           this.mouseTrigger=false;
           }
        colorSwitch()
            {           
            let leftx=this.position.x - this.width/2;
            let rightx = this.position.x + this.width/2;
            let lefty=this.position.y - this.height/2;
            let righty = this.position.y + this.height/2;        
            if(mouseX > leftx && mouseX <rightx && mouseY > lefty && mouseY < righty )
                { 
                this.mouseOverMe=true;
                if(mousePressed)
                this.presentColor = this.fillColor;
                else
                this.presentColor=this.clickColor;  
                }
            else
                {    
                this.mouseOverMe=false;           
                this.presentColor=this.fillColor;
                }
            }
        update()
            {
             this.colorSwitch();  
             if(mousePressed && !this.mouseTrigger)
               {
                this.mouseTrigger=true;
                if(this.mouseOverMe)
                    {
                      this.specialButtonTask();
                    }
               }
             else if(!mousePressed && this.mouseTrigger)
                {
                 this.mouseTrigger=false;                
                }           
            }
        display()
            {              
             ctx.save();
             ctx.translate(this.position.x,this.position.y);
             ctx.fillStyle=this.presentColor;//#ccccb3
             ctx.strokeStyle='#000000';
             ctx.beginPath();
             // ctx.rect(-this.width/2,-this.height/2,this.width,this.height);
             if(this.btnType=='leftArrow' || this.btnType=='rightArrow')
                this.draw_arrow_button();
             else
                ctx.ellipse(0,0,this.width/2,this.height/2,0,0,2*Math.PI);
             ctx.stroke();
             ctx.fill();             
             ctx.restore();
             w2screen(this.tex,this.position.x+this.x_text_offset,
                               this.position.y+this.y_text_offset);
            }

        draw_arrow_button()
            {                
               ctx.moveTo(this.arrowCornerPoints[0][0],this.arrowCornerPoints[0][1]);
               ctx.lineTo(this.arrowCornerPoints[1][0],this.arrowCornerPoints[1][1]);
               ctx.lineTo(this.arrowCornerPoints[2][0],this.arrowCornerPoints[2][1]);
               ctx.closePath();
            }
        specialButtonTask()
            {
                console.log(`${this.btnType}`);
            }

    }
class Button extends GenericButton
        {
          constructor(x,y,wid,hei,tex,btnType,btnGroups,btnName,parentPanel)
            {
             super(x,y,wid,hei,tex,btnType,btnGroups,btnName,parentPanel);                    
            }
          specialButtonTask()
            {                
                if(this.parentPanel.confirmationBox.active)                
                return false;
                if(this.tex=="Reset")
                    {
                    if(confirm("Press Ok to delete progress and restart game from start"))
                                {
                                localStorage.removeItem("GameSaveDataUserWise");
                                window.location.href='soldierInAbattleField2.html';
                                }
                    }
                if(this.tex=="Close")
                    {
                      this.parentPanel.confirmationBox.active=true;
                    }
            }
        }
class YesNoButton extends GenericButton
        {
          constructor(x,y,wid,hei,tex,btnType,btnGroups,btnName,parentPanel)
            {
             super(x,y,wid,hei,tex,btnType,btnGroups,btnName,parentPanel); 
             this.sprite_type="yes_no_"+tex;  
             this.x_text_offset=-20;                 
            }
          specialButtonTask()
            {
                
                let go=this.parentPanel.parentScreen.go;//parentPanel is confirmation box
                                                        //parentScreen is levelup box
                switch(this.sprite_type)
                    {
                      case "yes_no_Yes":
                            go.finalizeParamsUpgraded();
                            break;
                      case "yes_no_No":
                            go.resetParamsUpgraded();
                            break;
                    }
                // gameManager.gamePaused=false;
                gameManager.unPauseGame();
                this.parentPanel.active=false;
            }
        }
class ArrowButton extends GenericButton
        {
          constructor(x,y,wid,hei,tex,btnType,btnGroups,btnName,parentPanel,parent_ui_bar)
            {
             super(x,y,wid,hei,tex,btnType,btnGroups,btnName,parentPanel);   
             this.parent_ui_bar=parent_ui_bar; 
             // console.log(this.parent_ui_bar.sprite_type);      
                       
            }
          specialButtonTask()
            {
              if(this.parentPanel.confirmationBox.active)                
                 return false; 
              if(this.btnName=="HealthRight") 
                  {             
                  let updatedHealth=this.parentPanel.go.increaseMaxHealthVirt(10);
                  this.parent_ui_bar.updateValue(updatedHealth);
                  }
              else if(this.btnName=="HealthLeft")
                  {             
                  let updatedHealth=this.parentPanel.go.decreaseMaxHealthVirt(10);
                  this.parent_ui_bar.updateValue(updatedHealth);
                  }
            }
        }

    let sprite_folder="../../Python/TopDownBossFight1/sprites";
    let WHITECLOUD=LoadImagex(sprite_folder,'cloud-1.png');
    class GeneralSprite
        {
        constructor(x,y,wid,hei,hitboxoffsetx,hitboxoffsety,spriteGroups)
            {            
             this.position= new CreateVector(x,y);           
             this.hitboxOffset= new CreateVector(hitboxoffsetx,hitboxoffsety);
             this.width = wid * xscale;
             this.height = hei * yscale;
             this.onScreen=true;
             this.angle=0;
             this.imagex= WHITECLOUD;       
             this.sprite_type='generalSprite';  
             this.spriteGroups= spriteGroups; 
             for(let x of this.spriteGroups)
                x.push(this);
            }
        display()
            {            
             if(!this.onScreen) return false;
             ctx.save();
             ctx.translate(this.position.x-gameManager.camera.position.x, 
                           this.position.y-gameManager.camera.position.y);  
             ctx.rotate(d2r(this.rotAngle));          
             ctx.drawImage(this.imagex,-this.width/2,-this.height/2,this.width,this.height);             
             ctx.restore();
            }
         update()
            {
             return true;
            }
        }
//4. position adjuster start
    //positionAdjuster start
    class PositionAdjuster
        {
        constructor(obj,spriteGroups)
            {
             this.obj=obj;
             this.sprite_type="pos_adjuster";
             this.onScreen=true;
             this.rad=50*xscale;
             this.moveSpeed=0;
             this.moveSpeedMax=200*xscale;
             this.shapeSpeed=0;
             this.shapeSpeedMax=50;
             this.objIndex=0;
             this.last_gpress_time=0;    
             for(let grp of spriteGroups)
                {
                 grp.push(this);
                }
            }
        changeObject(obj)
            {
             this.obj=obj;
            }
        display()
            {   
            if(!this.obj) return false;                     
            ctx.save();         
            ctx.translate(this.obj.position.x - gameManager.camera.position.x,this.obj.position.y - gameManager.camera.position.y); 
            ctx.fillStyle='#FFFF00';
            ctx.strokeStyle='#FF0000';              
            ctx.beginPath();
            ctx.arc(0,0,this.rad,0,2*Math.PI);
            ctx.fill();
            ctx.stroke();
            ctx.restore();
            }
        update()
            {             
             this.attractFocus();
             if(!this.obj) return false;
             this.adjustObjPosition();
             this.adjustObjShape();             
             this.showData();        
            }

        showData()
            {
             if(!this.obj) return false;
             w2screen(`sprite:${this.obj.sprite_type}`,300,100);
             w2screen(`x:${(this.obj.position.x/xscale).toFixed(0)},y:${(this.obj.position.y/yscale).toFixed(0)}`,300,150);
             w2screen(`width:${(this.obj.width/xscale).toFixed(0)},height:${(this.obj.height/yscale).toFixed(0)}`,300,200);
            }   
        attractFocus()
            {
            let groupToFocus;
            if (gameManager.gamePaused)
                groupToFocus=gameManager.levelUpBox.uiBtns;
            else
                groupToFocus=gameManager.visible_sprites;
            if(GetKeyPressedx('g'))
                {
                  
                  if(gameManager.runningClock - this.last_gpress_time > 250)
                    {
                      this.last_gpress_time=gameManager.runningClock;
                      this.objIndex+=1;
                      if(this.objIndex >= groupToFocus.length) this.objIndex=0;
                      if(groupToFocus[this.objIndex]==this)
                        this.objIndex+=1;
                      this.changeObject(groupToFocus[this.objIndex]);
                    }
                }
            }
        adjustObjPosition()
            {
             if(GetKeyPressedx('i') || GetKeyPressedx('j') || GetKeyPressedx('m') || GetKeyPressedx('l')) 
                this.moveSpeed=Lerp(this.moveSpeed,this.moveSpeedMax,16);
             else
                this.moveSpeed=0;
             if(GetKeyPressedx('i'))                          
                this.obj.position.y=this.obj.position.y - this.moveSpeed;
             else if(GetKeyPressedx('m'))
                this.obj.position.y=this.obj.position.y + this.moveSpeed;

             if(GetKeyPressedx('l'))
                this.obj.position.x=this.obj.position.x + this.moveSpeed;
             else if(GetKeyPressedx('j'))
                this.obj.position.x=this.obj.position.x - this.moveSpeed;
            }

        adjustObjShape()
            {
             if(GetKeyPressedx('t') || GetKeyPressedx('h') || GetKeyPressedx('b') || GetKeyPressedx('f')) 
                this.moveSpeed=Lerp(this.moveSpeed,this.moveSpeedMax,16);
             else
                this.moveSpeed=0;
             if(GetKeyPressedx('t'))                          
                this.obj.height=this.obj.height - this.moveSpeed;
             else if(GetKeyPressedx('b'))
                this.obj.height=this.obj.height + this.moveSpeed;

             if(GetKeyPressedx('h'))
                this.obj.width=this.obj.width + this.moveSpeed;
             else if(GetKeyPressedx('f'))
                this.obj.width=this.obj.width - this.moveSpeed;
            }

        }
    //positionAdjuster ends
//4. position adjuster ends

//image list for soldier starts
/*
let SOLDIER_IDLE=["https://drive.google.com/uc?export=view&id=1TnEzgF4aAX-Fz67GUQJH72aJQgtYMDtl",
                    "https://drive.google.com/uc?export=view&id=1QmFM4sG0E4tuW_Wc805jiD17_fMjKrlb",
                    "https://drive.google.com/uc?export=view&id=1Y_iqTdrdLgGyJlTvttn7_VwdqeK8w5Wa",
                    "https://drive.google.com/uc?export=view&id=1I8Ifyrzh5FSP8oB84EtXs8N3FOcyxcft",
                    "https://drive.google.com/uc?export=view&id=1kEnkX7rY6ZScAJCDKWslwNXmrwbD9HD3",
                    "https://drive.google.com/uc?export=view&id=1SCUf5Jx6Ef6iRIJOHJdBVpG-5vD8qBK2",
                    "https://drive.google.com/uc?export=view&id=1y3Q0MO8eh4EF8jeJaGwIHEgsqpKIb4ld",
                    "https://drive.google.com/uc?export=view&id=1qjyjdgGIW64RcH22FcgQCNrkBaEcKufS",
                    "https://drive.google.com/uc?export=view&id=1sxHPWoKa3LO5bxrDx_HTlPmLfGCf907z",
                    "https://drive.google.com/uc?export=view&id=1RAPlxelYQkFHRdkpkHswYvdtQeWUZ2RM",
                    "https://drive.google.com/uc?export=view&id=1M-GRbQcukuTA9EC1hJ0_-7zjJjkjDsgE",
                    "https://drive.google.com/uc?export=view&id=1O_LxHEy5ys74zV7jWQVC2BHcXMhxruDt",
                    "https://drive.google.com/uc?export=view&id=12SQy0hpS5Z9CdmplfV2UptelLxxXvrjI",
                    "https://drive.google.com/uc?export=view&id=1j5iJdwty8HhJitb8_6boHTuBhmDTl0Bx",
                    "https://drive.google.com/uc?export=view&id=1y78hO2vmVWR8A-e-iHEI6N8HQquYPMNl",
                    "https://drive.google.com/uc?export=view&id=1FsqPW7a8pKdkwkSrkg_F5W7QWBI_A6gv",
                    "https://drive.google.com/uc?export=view&id=1MEiAUutwrSzcBXPuQ2InGPuv0Oz9HWGb",
                    "https://drive.google.com/uc?export=view&id=1CT_hQaTQplIAQtjjmlL7SzLxu3EKhz1n",
                    "https://drive.google.com/uc?export=view&id=1XamHyuVK71G_CW79US-Eka9VsUb0FSWc",
                    "https://drive.google.com/uc?export=view&id=1Zt_mSgKkZK-32Z1xa66p8S-u-QHwBMSF"];
let SOLDIER_IDLE_OBJS=LoadImagexArray(SOLDIER_IDLE);
//This was not working
*/
// let sprite_folder="F:\\gitClones\\GamesPythonJavascript\\Python\\TopDownBossFight1\\sprites";
// let sprite_folder="D:\\git_loc\\GDev_Javascript_Python_C++\\Python\\TopDownBossFight1\\sprites";
sprite_folder="../../Python/TopDownBossFight1/sprites";

let folder_name=sprite_folder+"\\soldier\\idle";
let folder_name2=sprite_folder+"\\soldier\\move";
let soldier_image_names=Array(20).fill(0).map((x,i)=>`survivor-idle_handgun_${i}.png`);
let SOLDIER_IDLE_OBJS=LoadImages(folder_name,soldier_image_names);
soldier_image_names=Array(20).fill(0).map((x,i)=>`survivor-move_handgun_${i}.png`);
let SOLDIER_MOVE_OBJS=LoadImages(folder_name2,soldier_image_names);
//image list for soldier ends
//image list for soldier feet
folder_name=sprite_folder+"\\soldierFeet\\idle";
folder_name2=sprite_folder+"\\soldierFeet\\run";
let soldier_feet_image_names=Array(1).fill(0).map((x,i)=>`survivor-idle_${i}.png`);
let SOLDIER_FEET_IDLE_OBJS=LoadImages(folder_name,soldier_feet_image_names);
soldier_feet_image_names=Array(20).fill(0).map((x,i)=>`survivor-run_${i}.png`);
let SOLDIER_FEET_MOVE_OBJS=LoadImages(folder_name2,soldier_feet_image_names);
//image list for soldier feet ends


//5. soldier starts
class Soldier
    {
     constructor(x,y,wid,hei,spriteGroups)
        {
         this.position=new CreateVector(x,y);
         this.width=wid*xscale;
         this.height=hei*yscale;
         
         this.feetOffset=new CreateVector(-2*xscale,0*yscale);
         this.animations={
                          'idle':SOLDIER_IDLE_OBJS,
                          'move':SOLDIER_MOVE_OBJS
                         };
         this.feetAnimations={
                              'idle':SOLDIER_FEET_IDLE_OBJS,
                              'move':SOLDIER_FEET_MOVE_OBJS
         };
         this.animationFractions={'idle':0.8,'move':0.4,'slash':0.2};
         this.feetAnimationFractions={'idle':1,'move':1};
         this.animation='idle';
         this.feetAnimation='idle';
         this.animationFrame=0;
         this.feetAnimationFrame=0;
         this.animInQueue=null;
         this.feetAnimInQueue=null;
         
         this.sprite_type='player';
         this.spriteGroups=spriteGroups;
         for(let grp of spriteGroups)
            grp.push(this);
         this.angle=0;
         this.acceleration=new CreateVector(0,0);
         this.velocity=new CreateVector(0,0);
         this.targetVelocity=this.velocity.copy();
         this.maxVelocity=10*xscale;
         this.hit_box=new HitBox(x,y,this.width*0.5,this.height*0.5,
                                 [gameManager.collission_sprites],
                                 'playerhitbox_damagable',this);
         this.sceneStartTime=0;
         this.prevMouseClicks=0;

        
         // this.destX=0;
         // this.destY=0;
         this.turnSpeed=9;
         this.dest=new CreateVector(0,0);
         this.moveStartTime=0;
         this.permissionToMove=false;
         this.getMoving=false;
         this.destinationAngle=0;         
         this.waitBeforeShoot=gameManager.maxClickGap+10*xscale;
         this.proximDistance=30*xscale;

         this.onScreen=true;
         this.isActive=true;

         //health params
         this.maximumPossibleHealth=500;
         this.maxHealth=100;
         this.health=this.maxHealth;
         this.weaponDamage=10;
         this.experience=100;
         this.experienceToll=1;
         this.experienceTollArray=[this.experienceToll];
         //vars to temporarily store values for use in levelup bax
         this.prevMaxHealth=this.maxHealth;
         this.prevExperience=this.experience;
         this.prevWeaponDamage= this.weaponDamage;
         //ends
         this.maxEnergy=100;
         this.energy=this.maxEnergy;
         this.listOfDestroyedSprites=[];
         gameManager.playerHealthBar.setValues(this.health,this.maxHealth,this);
         gameManager.playerEnergyBar.setValues(this.energy,this.maxEnergy,this);

         //shooting params and bullet
         this.bulletOffset=new CreateVector(55*xscale,25*yscale);
         this.mousePositionFixedForShoot=false;
         this.ShootDirection=null;
         this.preparingToShoot=false;
         this.shootPrepareStartTime=0;
         this.maxSPST=400;
         this.mousePositionVecShoot=null;

         this.flickerCount=0;
         this.maxFlickerTime=100;
         this.invincibleState=false;
         this.invin_count=0;
         this.max_invin_time=3000;
         this.flickerOut=true;
        }
     setMaxHealth(newval)
        {
           if(this.experience<this.experienceToll)
             {
                console.log('not enough experience');
                return this.maxHealth;
             }
            if(this.maxHealth >= this.maximumPossibleHealth)
            {
                console.log('health already at peak');
                return this.maxHealth;
            }
           this.experience-=this.experienceToll;
           this.experienceToll=parseInt(this.experienceToll*1.2)+1;
           this.maxHealth+=newval;
           gameManager.playerHealthBar.setValues(this.health,this.maxHealth,this); 
           return this.maxHealth;
        }
     increaseMaxHealthVirt(newval)
        {
           let n=this.experienceTollArray.length;
           if(n==1)
            {
              this.prevExperience=this.experience;
              this.prevMaxHealth=this.maxHealth;
            }
           if(this.experience<this.experienceTollArray[n-1])
             {
                console.log('not enough experience');
                return this.maxHealth;
             }
            if(this.maxHealth >= this.maximumPossibleHealth)
            {
                console.log('health already at peak');
                return this.maxHealth;
            }

           this.experience-=this.experienceTollArray[n-1];
           this.experienceTollArray.push(parseInt(this.experienceTollArray[n-1]*1.2)+1);
           this.maxHealth+=newval;
           // gameManager.playerHealthBar.setValues(this.health,this.maxHealth,this); 
           return this.maxHealth;
        }

     decreaseMaxHealthVirt(newval)
        {
           let n=this.experienceTollArray.length;
           if(n<=1)
            {
              console.log("cant decrease any further");
              return false;
            }
           this.experienceTollArray.pop();
           this.experience+=this.experienceTollArray[n-2];  

           this.maxHealth-=newval;            
           return this.maxHealth;
        }
     finalizeParamsUpgraded()
        {
          let n=this.experienceTollArray.length;
          this.experienceToll= this.experienceTollArray[n-1];
          this.experienceTollArray=[this.experienceToll];
          gameManager.playerHealthBar.setValues(this.health,this.maxHealth,this);
          gameManager.saveStatusToLocalStoragex();
        }
    resetParamsUpgraded()
        {
            this.maxHealth=this.prevMaxHealth;
            this.experience=this.prevExperience;
            this.experienceToll= this.experienceTollArray[0];
            this.experienceTollArray=[this.experienceToll];
            console.log(`experience reset to ${this.experience}`)
            gameManager.levelUpBox.healthui.updateValue(this.maxHealth);
        }

     setGetMoving()
        {
         if (gameManager.followMouse && !GetKeyPressedx('e'))
            return false;
         if(!this.permissionToMove)
            return false;
        if(this.getMoving)
            return true;
        if(gameManager.runningClock - this.moveStartTime > this.waitBeforeShoot)
            {
             this.changeAnimation('move');
             this.changeFeetAnimation('move');
             this.getMoving=true;
             this.destinationAngle=this.dest.copy().sub(this.position).heading();
            }
        }
     moveToDestination()
        {
            if(!this.getMoving  ) return false;
            this.angle=AngleLerp(this.angle,this.destinationAngle,this.turnSpeed);
            this.acceleration.setVec(this.dest.copy().sub(this.position));  
            this.acceleration.normalize();
            // this.acceleration.pointToAngle(this.angle);
            this.reachedTarget();           

        }
     reachedTarget()
        {
         /*
         console.log('dest:'+this.dest.announce());
         console.log('pos:'+this.position.announce());
         console.log('sep:'+this.dest.copy().sub(this.position).mag());*/

         if(this.dest.copy().sub(this.position).mag()<this.proximDistance)
            {           
            this.stopEverything();
            }
        }
    receiveParams(health,maxHealth,maxEnergy,weaponDamage,experience,experienceToll)
        {        
        this.maxHealth = maxHealth;
        this.maxEnergy = maxEnergy;
        this.weaponDamage = weaponDamage;
        this.experience = experience;
        this.health = health; 
        //had to do this as experienceToll was included later
        if(experienceToll==undefined) this.experienceToll=1;
        else this.experienceToll=experienceToll;

        this.experienceTollArray=[this.experienceToll];         
        this.prevMaxHealth=this.maxHealth;
        this.prevExperience=this.experience;
        this.prevWeaponDamage=this.weaponDamage;

        gameManager.playerHealthBar.setValues(this.health,this.maxHealth,this);
        gameManager.playerEnergyBar.setValues(this.energy,this.maxEnergy,this);          
        }
     stopEverything()
        {
        this.permissionToMove=false;
        this.getMoving=false;
        this.velocity.set(0,0);
        this.acceleration.set(0,0);
        this.changeAnimation('idle');
        this.changeFeetAnimation('idle');
        }
     
     //under progress

     preparingToShootFn(){
        if(!this.mousePositionFixedForShoot){
            this.mousePositionFixedForShoot=true;
            this.shootPrepareStartTime=gameManager.runningClock;
            this.mousePositionVecShoot=new CreateVector(mouseX,mouseY);
            this.mousePositionVecShoot.add(gameManager.camera.position);
            this.ShootDirection=new CreateVector(mouseX,mouseY); 
            this.ShootDirection.add(gameManager.camera.position);   
            this.ShootDirection.sub(this.position);    
        }
        this.angle=AngleLerp(this.angle,this.ShootDirection.heading(),9);
        if(gameManager.runningClock - this.shootPrepareStartTime > this.maxSPST){
            this.mousePositionFixedForShoot=false;  
            this.preparingToShoot=false;          
            this.shoot();
        }
     }
     //underprogress

     detectMouseClicks_Listener()
        {
         if(this.preparingToShoot) {
            this.preparingToShootFn();
            return;
         }        
         if(gameManager.numClicks !=this.prevMouseClicks)
            {
             this.prevMouseClicks=gameManager.numClicks;             
            if(gameManager.numClicks==1)
                {                 
                 // console.log(`mouse clicked once at ${mouseX.toFixed(2)},${mouseY.toFixed(2)}`);
                 this.getMoving=false;
                 this.dest.set(mouseX+gameManager.camera.position.x,
                               mouseY+gameManager.camera.position.y);                 
                 this.moveStartTime=gameManager.runningClock;
                 this.permissionToMove=true;
                }
            else if(gameManager.numClicks==2)
                {                   
                    this.permissionToMove=false;
                    this.preparingToShoot=true;
                    /*
                    //delete these
                    this.turnToFaceMousePointer();
                    this.shoot();  
                    */

                 
                }
            else if(gameManager.numClicks==3)
                {                 
                 // console.log(`mouse clicked thrice at ${mouseX.toFixed(2)},${mouseY.toFixed(2)}`);
                }
            }
        } 
    turnToFaceMousePointer()
        {
         let dir=new CreateVector(mouseX,mouseY);
         dir.add(gameManager.camera.position);
         dir.sub(this.position);
         this.angle=dir.heading();
        }
    shoot()
        {  
        let bulletOffset=this.bulletOffset.copy().rotateByAngle(this.angle);              
        new Projectile(this.position.x+bulletOffset.x,
                       this.position.y+bulletOffset.y,
                       5*xscale,5*yscale,
                       this,
                       this.mousePositionVecShoot,
                       [gameManager.visible_sprites,gameManager.active_sprites]
                       ); 
        }    
    runAnimation()
        {
        this.animationFrame+=this.animationFractions[this.animation];           
        if(this.animationFrame >= this.animations[this.animation].length)
            {
             this.animationFrame=0;
             if(this.animInQueue) 
                {
                this.animation=this.animInQueue;
                this.animInQueue=null;
                }
            }
        }
    changeAnimation(anim)
        {
        if(this.animation=="slash") return false;
        
        if(this.animation == anim) return false;
        else
            {
            this.animation=anim;
            this.animationFrame=0;
            }
        }
    runFeetAnimation()
        {
        this.feetAnimationFrame+=this.feetAnimationFractions[this.feetAnimation];           
        if(this.feetAnimationFrame >= this.feetAnimations[this.feetAnimation].length)
            {
             this.feetAnimationFrame=0;
             if(this.feetAnimInQueue) 
                {
                this.feetAnimation=this.feetAnimInQueue;
                this.feetAnimInQueue=null;
                }
            }
        }
    changeFeetAnimation(anim)
        {       
        
        if(this.feetAnimation == anim) return false;
        else
            {
            this.feetAnimation=anim;
            this.feetAnimationFrame=0;
            }
        }

    move()
        {
         this.setGetMoving();
         this.moveToDestination();
         this.velocity.add(this.acceleration);
         gameManager.applyVelocityRestrictions(this);
         this.acceleration.set(0,0);
         gameManager.applyVelocity(this);
         
         gameManager.update_and_display_hitbox(this);
         this.detectMouseClicks_Listener();
        }
     performSpecTaskOnCollision()
        {
         return false;
        }
     update()
        {
         if(!this.isActive) return false;
         this.runAnimation();
         this.runFeetAnimation();
         this.move();
         this.manageInvincibility();
         // this.testCollisionWithLoot();
        }

    flickerControl()
        {
           
          if(!this.invincibleState) return true;
          this.flickerCount+=deltaTime;
          if(this.flickerCount > this.maxFlickerTime)
            {
             this.flickerCount=0;             
             this.flickerOut=!this.flickerOut;
            }
          return this.flickerOut;
        }

    manageInvincibility()
        {
        if(!this.invincibleState) return false;
        this.invin_count+= deltaTime;
        if(this.invin_count > this.max_invin_time)
            {
             this.invin_count=0;
             this.invincibleState=false;
            } 
        }
    display()
        {     
          this.displayFeet();       
         if(!this.onScreen || !this.flickerControl()) return false;
         
         ctx.save();
         ctx.translate(this.position.x-gameManager.camera.position.x, 
                       this.position.y-gameManager.camera.position.y);
         ctx.rotate(d2r(this.angle));
         // ctx.scale(this.sx,this.sy);
         try{

         ctx.drawImage(this.animations[this.animation][parseInt(this.animationFrame)],
                       -this.width/2,
                       -this.height/2,
                       this.width,
                       this.height
                      );
        }catch(err){
            console.log(this.animations[this.animation][parseInt(this.animationFrame)]);
        }

         /*
         if(this.flashThis())
         ctx.drawImage(this.healFlash,
                      -this.width/2,
                      -this.height/2,
                      this.width,
                      this.height
                      );*/
         ctx.restore(); 
        }

    displayFeet()
        {            
         /*if(!this.onScreen || !this.flickerControl()) return false;*/
         if(!this.onScreen ) return false;
         let feetOffset=this.feetOffset.copy().rotateByAngle(this.angle);
         ctx.save();
         ctx.translate(this.position.x-gameManager.camera.position.x+feetOffset.x, 
                       this.position.y-gameManager.camera.position.y+feetOffset.y);
         ctx.rotate(d2r(this.angle));
         // ctx.scale(this.sx,this.sy);
         try{
         ctx.drawImage(this.feetAnimations[this.feetAnimation][parseInt(this.feetAnimationFrame)],
                       -this.width/2,
                       -this.height/2,
                       this.width,
                       this.height
                      );
        }catch(err){
            console.log('error at display feet');
            console.log(this.feetAnimations[this.feetAnimation][parseInt(this.animationFrame)]);
        }

         /*
         if(this.flashThis())
         ctx.drawImage(this.healFlash,
                      -this.width/2,
                      -this.height/2,
                      this.width,
                      this.height
                      );*/
         ctx.restore(); 
        }

        
        
        takeDamage(dmg,dir=0)
            {   
                  
            if(this.invincibleState && !gameManager.playerDied) return false;
            // if(!gameManager.playerDied)
            // document.querySelector('#LossBuzz').play(); 
            this.invincibleState=true;      
            this.acceleration.add(new CreateVector(dir,0));
            this.health-=dmg;
            console.log('player health:'+this.health);
            gameManager.playerHealthBar.updateValue(this.health);           
            if(this.health<=0)
                {
                // if(gameManager.playerDied) document.querySelector('#LossBuzz').play();  
                this.health=0;
                console.log('destroyed');
                SpawnClouds(this.position);             
                destroySelf(this.hit_box);
                destroySelf(this);              
                this.isActive=false;
                gameManager.player=null;
                gameManager.playerDied=true;                
                gameManager.playerDiedClock= gameManager.runningClock;                              
                }
            }

    }
//5. soldier ends
//generic movable
class GenericMovable extends GeneralSprite
    {
    constructor(x,y,wid,hei,hitboxoffsetx,hitboxoffsety,spriteGroups)
        {
         super(x,y,wid,hei,hitboxoffsetx,hitboxoffsety,spriteGroups);
         this.hit_box=new HitBox(x,y,this.width*0.5,this.height*0.5,
                                 [gameManager.collission_sprites],
                                 'generichitbox',this);
         this.animations={};
         this.animationFractions={};
         this.animationSizeMults={};
         this.animation='idle';
         this.animationFrame=0;
         this.animInQueue=null;
         this.sprite_type='generic';
         this.acceleration=new CreateVector(0,0);
         this.velocity=new CreateVector(0,0);
         this.maxVelocity=10*xscale;         
        }
    runAnimation()
        {
        this.animationFrame+=this.animationFractions[this.animation];           
        if(this.animationFrame >= this.animations[this.animation].length)
            {
             this.animationFrame=0;
             if(this.animInQueue) 
                {
                this.animation=this.animInQueue;
                this.animInQueue=null;
                }
            }
        }
    changeAnimation(anim)
        {        
        if(this.animation == anim) return false;
        else
            {
            this.animation=anim;
            this.animationFrame=0;
            }
        }
    applyVelocity()
            {                    
             this.hit_box.position.x+=this.velocity.x;         
             for(let k in gameManager.collission_sprites)
                { 
                 let x=gameManager.collission_sprites[k];
                 if(!x.onScreen) continue;
                 if(x==this || x==this.hit_box) continue; 
                                
                 if(b_collision(this.hit_box,x)) 
                    {  
                    
                    this.performSpecTaskOnCollision(x);                           
                    // console.log('collision with '+x.sprite_type);         
                     if(this.velocity.x > 0)
                        {                    
                        this.hit_box.position.x=x.position.x - x.width/2-this.hit_box.width/2-2;                        
                        }
                     else 
                        {
                        this.hit_box.position.x=x.position.x + x.width/2 + this.hit_box.width/2+2;                      
                        }
                    }
                }

             this.hit_box.position.y+=this.velocity.y;           
             for(let x of gameManager.collission_sprites)
                {
                 if(!x.onScreen) continue;
                 if(x==this || x==this.hit_box) continue;                
                 if(b_collision(this.hit_box,x)) 
                    {
                    
                        this.performSpecTaskOnCollision(x);  
                         
                    // console.log('collision with '+x.sprite_type);
                    if(this.velocity.y > 0)
                        {
                        this.hit_box.position.y=x.position.y-x.height/2-this.hit_box.height/2-2;                        
                        }
                    else
                        {
                        this.hit_box.position.y=x.position.y+x.height/2+this.hit_box.height/2+2;                        
                        }
                    }
                }
            }
         applyVelocityRestrictions()
            {
            if(this.velocity.mag() < this.maxVelocity) return;
            this.velocity.normalize().mult(this.maxVelocity);         
            }
        update_and_display_hitbox(show=false)
            {  
            if(show) this.hit_box.display();         
            this.position.setVec(this.hit_box.position.copy().add(this.hitboxOffset));
            }
        move()
            {
             this.velocity.add(this.acceleration);
             this.acceleration.set(0,0);
             this.applyVelocity();
             this.applyVelocityRestrictions();
             this.update_and_display_hitbox();
            }
        update()
            {
             this.runAnimation();
             this.move();
            }
        display()
            {         
            if(!this.onScreen ) return false;
            ctx.save();
            ctx.translate(this.position.x-gameManager.camera.position.x, 
                          this.position.y-gameManager.camera.position.y);
            ctx.rotate(d2r(this.angle));
            let wid=this.width*this.animationSizeMults[this.animation][0];
            let hei=this.height*this.animationSizeMults[this.animation][1];
         
         try{
         ctx.drawImage(this.animations[this.animation][parseInt(this.animationFrame)],
                       -wid/2,
                       -hei/2,
                       wid,
                       hei
                      );
        }catch(err){
            console.log(this.animations[this.animation][parseInt(this.animationFrame)]);
        }

         /*
         if(this.flashThis())
         ctx.drawImage(this.healFlash,
                      -this.width/2,
                      -this.height/2,
                      this.width,
                      this.height
                      );*/
            ctx.restore(); 
            }
    } 
//generic movable ends
//generic enemy starts
class GenericEnemy extends GenericMovable
    {
    constructor(x,y,wid,hei,hitboxoffsetx,hitboxoffsety,spriteGroups,sprite_id,bossStatus)
        {
         super(x,y,wid,hei,hitboxoffsetx,hitboxoffsety,spriteGroups);
         this.bossStatus=bossStatus;
         this.sprite_id=sprite_id; //sprite_id uniquely identifies this sprite
         this.sprite_type='genericEnemy';
         this.hit_box.sprite_type='genericEnemyhitbox_damagable';
         this.animations={
                          "idle":[],
                          "move":[],
                          "attack":[]
                         };
         this.animationFractions={'idle':0.8,'move':0.4,'attack':0.2};
         this.animationSizeMults={'idle':[1,1],'move':[1,1],'attack':[1.4,1.4]};
         this.animation='idle';           
         this.state='idle'; 
         this.enemyDetectDistance=200*xscale;
         this.nearAttackDistance=120*xscale;
         this.farAttackDistance=250*xscale; 
         this.lastFarAttackTime=0;
         this.lastCloseAttackTime=0;
         this.maxFarAttackTimeGap=2000;
         this.maxCloseAttackTimeGap=2000;
         if(this.bossStatus) this.onScreen=false; 
         else this.onScreen=true;
         this.maxStrikeTime=2000; 
         this.bulletOffset=new CreateVector(55*xscale,25*yscale); 

         this.longAttacks=['farstrike'];
         this.shortAttacks=['strike'];  
         this.strikeBoxSpawned=false;
        }
     display(){
        super.display();
     }
     update(){        
        super.update();
        this.stateMachine();
        this.announceState();
     }
     takeDamage(){
        console.log("zombie reports damage");
     }
     announceState(){
        w2screen(this.state,
                    this.position.x-gameManager.camera.position.x,
                    this.position.y-gameManager.camera.position.y-60);
     }
     stateMachine(){
        switch(this.state){
            case 'idle':
             this.Idle_Actions();
             break;
            case 'agro':
             this.Agro_Actions();
             break;
            case 'strike':
             this.Strike();
             break;
            case 'farstrike':
             this.FarStrike();
             break;
            default:
              console.log('undefined state');
              break;
        }
     }
     
     Idle_Actions(){
        this.changeAnimation('idle');
        if(this.EnemyDetected()) 
            {            
            if(!this.onScreen)               
                this.MakeDramaticAppearance();           
            this.state='agro';
            }
        return false;
     }
     Agro_Actions(){
         this.changeAnimation('idle');
        if(!gameManager.player || !gameManager.player.isActive)
            return false;
        this.FaceEnemy();
        this.CarryOutAttacks();
     }
     
     Strike(){
        if(gameManager.runningClock - this.lastCloseAttackTime > this.maxStrikeTime){            
            this.state='agro';
            this.lastCloseAttackTime=gameManager.runningClock;
            this.strikeBoxSpawned=false;            
            return true;
        }
        let bulletOffset=this.bulletOffset.copy().rotateByAngle(this.angle); 
        if(!this.strikeBoxSpawned && this.animation=="attack" && parseInt(this.animationFrame)==2)
            {
            new DamageHitBox(this.position.x,
                             this.position.y,
                             40*xscale,40*yscale,
                             bulletOffset.x,bulletOffset.y,                             
                             5,0,
                            [
                            gameManager.visible_sprites,
                            gameManager.active_sprites,
                            gameManager.hit_box_sprites
                           ],
                             "enemy_damagebox",this
                            );
            this.strikeBoxSpawned=true;
            }
        this.changeAnimation('attack');
     }


     ZombieShoot()
        {  
        let bulletOffset=this.bulletOffset.copy().rotateByAngle(this.angle);  
        let tgtPoint=new CreateVector(10,0);       

        let fb=new Fireball(this.position.x+bulletOffset.x,
                       this.position.y+bulletOffset.y,
                       40*xscale,20*yscale,
                       this,
                       tgtPoint,
                       [gameManager.visible_sprites,gameManager.active_sprites]
                       ); 
        fb.rotAngle=this.angle;
        
        
        }  

     FarStrike(){
        
        if(gameManager.runningClock - this.lastFarAttackTime > this.maxStrikeTime){                     
            this.state='agro';
            this.lastFarAttackTime=gameManager.runningClock;
            this.fireBallSpawned=false;
            return true;
        }
        if(!this.fireBallSpawned && this.animation=="attack" && parseInt(this.animationFrame)==6)
            {
            this.ZombieShoot();
            this.fireBallSpawned=true;
            }
        if(this.fireBallSpawned && parseInt(this.animationFrame)==8)
            this.fireBallSpawned=false;
        this.changeAnimation('attack');
     }

     CarryOutAttacks(){
         // Draw_a_line(this.position,Get_A_Point(this.position,this.nearAttackDistance,this.angle));
         if(gameManager.player.position.copy().sub(this.position).mag() < this.nearAttackDistance){
            if(this.lastFarAttackTime!=0) this.lastFarAttackTime=0;                
            if(gameManager.runningClock - this.lastCloseAttackTime > this.maxCloseAttackTimeGap){
                this.lastCloseAttackTime= gameManager.runningClock; 
            //attack here
                this.state=this.shortAttacks[Math.floor(Math.random()*this.shortAttacks.length)];
            }
         }else{

            if(this.lastCloseAttackTime!=0) this.lastCloseAttackTime=0;                
            if(gameManager.runningClock - this.lastFarAttackTime > this.maxFarAttackTimeGap){
                this.lastFarAttackTime= gameManager.runningClock; 
            //attack here  
                this.state=this.longAttacks[Math.floor(Math.random()*this.longAttacks.length)];         
            }

         }
     }

     FaceEnemy(){
        let enemyDir=gameManager.player.position.copy().sub(this.position);
        this.angle=AngleLerp(this.angle,enemyDir.heading(),9);
     }
     EnemyDetected(){
        if(!gameManager.player || !gameManager.player.isActive) return false;
        if(gameManager.player.position.copy().sub(this.position).mag() < this.enemyDetectDistance)
        {
            return true;
        }
     }

     MakeDramaticAppearance(){
        this.onScreen=true;
        SpawnClouds(this.position);
     }

    } 
//generic enemy ends

//get zombie images
folder_name=sprite_folder+"\\Zombie\\idle";
let image_names=Array(17).fill(0).map((x,i)=>`skeleton-idle_${i}.png`);
let ZOMBIE_IDLE_IMAGES=LoadImages(folder_name,image_names);
folder_name=sprite_folder+"\\Zombie\\move";
image_names=Array(13).fill(0).map((x,i)=>`skeleton-move_${i}.png`);
let ZOMBIE_MOVE_IMAGES=LoadImages(folder_name,image_names);
folder_name=sprite_folder+"\\Zombie\\attack";
image_names=Array(13).fill(0).map((x,i)=>`skeleton-attack_${i}.png`);
let ZOMBIE_ATTACK_IMAGES=LoadImages(folder_name,image_names);
//14 zombie starts
class Zombie extends GenericMovable
    {
    constructor(x,y,wid,hei,hitboxoffsetx,hitboxoffsety,spriteGroups,sprite_id)
        {
         super(x,y,wid,hei,hitboxoffsetx,hitboxoffsety,spriteGroups);
         this.sprite_id=sprite_id; //sprite_id uniquely identifies this sprite
         this.sprite_type='zombie';
         this.hit_box.sprite_type='zombiehitbox_damagable';
         this.animations={
                          "idle":ZOMBIE_IDLE_IMAGES,
                          "move":ZOMBIE_MOVE_IMAGES,
                          "attack":ZOMBIE_ATTACK_IMAGES
                         };
         this.animationFractions={'idle':0.8,'move':0.4,'attack':0.2};
         this.animationSizeMults={'idle':[1,1],'move':[1,1],'attack':[1.4,1.4]};
         this.animation='idle';           
         this.state='idle'; 
         this.enemyDetectDistance=200*xscale;
         this.nearAttackDistance=120*xscale;
         this.farAttackDistance=250*xscale; 
         this.lastFarAttackTime=0;
         this.lastCloseAttackTime=0;
         this.maxFarAttackTimeGap=2000;
         this.maxCloseAttackTimeGap=2000;
         this.onScreen=false; 
         this.maxStrikeTime=2000; 
         this.bulletOffset=new CreateVector(60*xscale,10*yscale); 

         this.longAttacks=['farstrike'];
         this.shortAttacks=['strike'];  
         this.strikeBoxSpawned=false;

         this.health=100;
        }
     display(){
        super.display();
     }
     update(){        
        super.update();
        this.stateMachine();
        this.announceState();
     }
     takeDamage(dmg){
        console.log("zombie reports damage:"+dmg);
     }
     announceState(){
        w2screen(this.state,
                    this.position.x-gameManager.camera.position.x,
                    this.position.y-gameManager.camera.position.y-60);
     }
     stateMachine(){
        switch(this.state){
            case 'idle':
             this.Idle_Actions();
             break;
            case 'agro':
             this.Agro_Actions();
             break;
            case 'strike':
             this.Strike();
             break;
            case 'farstrike':
             this.FarStrike();
             break;
            default:
              console.log('undefined state');
              break;
        }
     }
     
     Idle_Actions(){
        this.changeAnimation('idle');
        if(this.EnemyDetected()) 
            {            
            if(!this.onScreen)               
                this.MakeDramaticAppearance();           
            this.state='agro';
            }
        return false;
     }
     Agro_Actions(){
         this.changeAnimation('idle');
        if(!gameManager.player || !gameManager.player.isActive)
            return false;
        this.FaceEnemy();
        this.CarryOutAttacks();
     }
     
     Strike(){
        if(gameManager.runningClock - this.lastCloseAttackTime > this.maxStrikeTime){            
            this.state='agro';
            this.lastCloseAttackTime=gameManager.runningClock;
            this.strikeBoxSpawned=false;            
            return true;
        }
        let bulletOffset=this.bulletOffset.copy().rotateByAngle(this.angle); 
        if(!this.strikeBoxSpawned && this.animation=="attack" && parseInt(this.animationFrame)==2)
            {

            new DamageHitBox(this.position.x,
                             this.position.y,
                             40*xscale,40*yscale,
                             bulletOffset.x,bulletOffset.y,                             
                             5,0,
                            [
                            // gameManager.visible_sprites,
                            gameManager.active_sprites,
                            gameManager.hit_box_sprites
                           ],
                             "enemy_damagebox",this
                            );
            this.strikeBoxSpawned=true;
            }
        this.changeAnimation('attack');
     }


     ZombieShoot()
        {  
        let bulletOffset=this.bulletOffset.copy().rotateByAngle(this.angle);  
        let tgtPoint=new CreateVector(10,0);       

        let fb=new Fireball(this.position.x+bulletOffset.x,
                       this.position.y+bulletOffset.y,
                       40*xscale,20*yscale,
                       this,
                       tgtPoint,
                       [gameManager.visible_sprites,gameManager.active_sprites]
                       ); 
        fb.rotAngle=this.angle;
        
        
        }   

     FarStrike(){
        
        if(gameManager.runningClock - this.lastFarAttackTime > this.maxStrikeTime){                     
            this.state='agro';
            this.lastFarAttackTime=gameManager.runningClock;
            this.fireBallSpawned=false;
            return true;
        }
        if(!this.fireBallSpawned && this.animation=="attack" && parseInt(this.animationFrame)==6)
            {
            this.ZombieShoot();
            this.fireBallSpawned=true;
            }
        if(this.fireBallSpawned && parseInt(this.animationFrame)==8)
            this.fireBallSpawned=false;
        this.changeAnimation('attack');
     }

     CarryOutAttacks(){
         // Draw_a_line(this.position,Get_A_Point(this.position,this.nearAttackDistance,this.angle));
         if(gameManager.player.position.copy().sub(this.position).mag() < this.nearAttackDistance){
            if(this.lastFarAttackTime!=0) this.lastFarAttackTime=0;                
            if(gameManager.runningClock - this.lastCloseAttackTime > this.maxCloseAttackTimeGap){
                this.lastCloseAttackTime= gameManager.runningClock; 
            //attack here
                this.state=this.shortAttacks[Math.floor(Math.random()*this.shortAttacks.length)];
            }
         }else{

            if(this.lastCloseAttackTime!=0) this.lastCloseAttackTime=0;                
            if(gameManager.runningClock - this.lastFarAttackTime > this.maxFarAttackTimeGap){
                this.lastFarAttackTime= gameManager.runningClock; 
            //attack here  
                this.state=this.longAttacks[Math.floor(Math.random()*this.longAttacks.length)];         
            }

         }
     }

     FaceEnemy(){
        let enemyDir=gameManager.player.position.copy().sub(this.position);
        this.angle=AngleLerp(this.angle,enemyDir.heading(),9);
     }
     EnemyDetected(){
        if(!gameManager.player || !gameManager.player.isActive) return false;
        if(gameManager.player.position.copy().sub(this.position).mag() < this.enemyDetectDistance)
        {
            return true;
        }
     }

     MakeDramaticAppearance(){
        this.onScreen=true;
        SpawnClouds(this.position);
     }

    } 



//image list for flower
folder_name="../Insects/Sprites/flowers";
soldier_feet_image_names=Array(7).fill(0).map((x,i)=>`flower${i}.png`);
FLOWER_STAGES=LoadImages(folder_name,soldier_feet_image_names);
//image list for flower ends
//class flower
class Flower extends GeneralSprite
    {
      constructor(x,y,wid,hei,spriteGroups)
        {
         super(x,y,wid,hei,0,0,spriteGroups);
         this.imageStages=FLOWER_STAGES; 
         this.i=0
         this.imagex=this.imageStages[this.i]; 
         this.onScreen=true;
         this.sprite_type='flower';  
         this.hit_box=new HitBox(x,y,this.width*0.5,this.height*0.5,
                                 [gameManager.collission_sprites],
                                 'flowerhitbox_damagable',this);  
         this.experienceGrant=10;   
        }
      display()
        {            
         if(!this.onScreen) return false;
         ctx.save();
         ctx.translate(this.position.x-gameManager.camera.position.x, 
                       this.position.y-gameManager.camera.position.y);           
         ctx.drawImage(this.imagex,-this.width/2,-this.height/2,this.width,this.height);             
         ctx.restore();
        }
      takeDamage(dmg,hb=0)
        {
         console.log("damage taken"); 
         SpawnClouds(this.position);
         gameManager.player.experience+=this.experienceGrant;
         destroySelf(this.hit_box);
         destroySelf(this);
        }
       
    }
//class flower ends
//cloud burst
    class CloudBurst
        {
         constructor(x,y,spriteGroups)
            {
             this.position = new CreateVector(x,y);
             this.width= 15 * xscale;
             this.sprite_type='cloud';
             this.height= 15 * yscale;
             this.imagex= WHITECLOUD;
             this.onScreen=true;
             this.isActive=true;
             this.spriteGroups=spriteGroups;
             for(let grp of spriteGroups)
                grp.push(this);
             this.angle=0;  
             this.birthTime=gameManager.runningClock;   
             this.maxLife=1500; 
             this.velocity=new CreateVector((Math.random()-0.5)*4,(Math.random()-0.5)*4);

            }
         display()
            {
            if(!this.onScreen) return false;                
            ctx.save();         
            ctx.translate(this.position.x - gameManager.camera.position.x,this.position.y - gameManager.camera.position.y); 
            ctx.drawImage(this.imagex,-this.width/2,-this.height/2,this.width,this.height);
            ctx.restore();
            }
         update()
            {
             this.move();
             if(gameManager.runningClock - this.birthTime > this.maxLife)
                {
                 destroySelf(this);
                }            
            }
         move()
            {
             this.position.add(this.velocity);
            }
        }
function SpawnClouds(pos,n=60)
    {
     for(let i=0;i<n;i++)
        new CloudBurst(pos.x,pos.y,[gameManager.visible_sprites,gameManager.active_sprites]);
    }
//cloud burst ends
//projectile image load
  let projectile_image=LoadImagex(sprite_folder,'redcube.png');
  class Projectile
    {
      constructor(x,y,wid,hei,parent,tgtPoint,spriteGroups)
        {
          this.position= new CreateVector(x,y);
          this.width=wid;
          this.height=hei;
          this.spriteGroups=spriteGroups;
          this.imagex=projectile_image;
          this.parent=parent;          
          this.onScreen=true;
          this.isActive=true;
          this.angle=0;
          this.rotAngle=0;
          this.velocity=new CreateVector(0,0);
          this.maxVelocity=5*xscale;
          this.acceleration=new CreateVector(1,0);
          // this.accelerationInit=this.acceleration.copy().pointToAngle(this.parent.angle).normalize();
          this.accelerationInit=tgtPoint.sub(this.position).normalize();

          this.hit_box=new HitBox(x,y,this.width*0.5,this.height,
                                 [gameManager.collission_sprites],
                                 'projectilehitbox');
          this.birthTime= gameManager.runningClock;
          this.sprite_type='projectile';
          for(let x of this.spriteGroups) x.push(this);
          this.damageCaused=5;
        }
      display()
        {            
         if(!this.onScreen) return false;         
         ctx.save();
         ctx.translate(this.position.x- gameManager.camera.position.x, 
                       this.position.y- gameManager.camera.position.y);
         ctx.rotate(d2r(this.rotAngle));             
         ctx.drawImage(this.imagex,-this.width/2,-this.height/2,this.width,this.height);            
         ctx.restore();
        }

      update()
        {
         this.move();
         this.checkLifeSpan();
        }
      applyForce()
        {
            this.acceleration.setVec(this.accelerationInit);

        }
      move()
        {
         this.applyForce(); 
         this.velocity.add(this.acceleration);        
         gameManager.applyVelocity(this);
         gameManager.applyVelocityRestrictions(this);
         this.acceleration.set(0,0);
         gameManager.update_and_display_hitbox(this);
        }
      checkLifeSpan()
        {
            if(gameManager.runningClock - this.birthTime > 2000)
            {
                destroySelf(this.hit_box);
                destroySelf(this);
                console.log('projectile destroyed');
            }
        }
       performSpecTaskOnCollision(collidedObjType)
        {
           
           // gameManager.performSpecTaskOnCollision(collidedObjType,this.damageCaused);
           if(collidedObjType.parent==this.parent) return;
           let arr=collidedObjType.sprite_type.split('_');          
            if(arr.length>1 && arr[1]=='damagable')
                collidedObjType.parent.takeDamage(this.damageCaused);   //,this.velocity.normalized()                              
           document.querySelector('#RockSmash').play();
           SpawnClouds(this.position);       
           destroySelf(this.hit_box);
           destroySelf(this);
        }

        
    }
    //projectile ends
    let fireball_image=LoadImagex(sprite_folder,'fireball.png');
    class Fireball extends Projectile
     {
        constructor(x,y,wid,hei,parent,tgtPoint,spriteGroups){
            super(x,y,wid,hei,parent,tgtPoint,spriteGroups);
            this.imagex=fireball_image;
            this.damageCaused=6;
            this.accelerationInit=new CreateVector(1,0);
            this.accelerationInit.rotateByAngle(this.parent.angle);
        }
     }

    let HORIZONTALWALL=LoadImagex(sprite_folder+'/Pipes','pipeHori.png');
    let VERTICALWALL=LoadImagex(sprite_folder+'/Pipes','pipe.png');
    class Wall extends GeneralSprite
        {
          constructor(x,y,wid,hei,hitboxoffsetx,hitboxoffsety,isHori,spriteGroups)
            {
              super(x,y,wid,hei,hitboxoffsetx,hitboxoffsety,spriteGroups);
              this.sprite_type=isHori?'horizontalwall':'verticalwall';
              this.hit_box_width=isHori?this.width:this.width*0.85;
              this.hit_box_height=isHori?this.height*0.85:this.height;
              this.hit_box=new HitBox(x,y,this.hit_box_width,this.hit_box_height,
                                 [gameManager.collission_sprites],
                                 'pipehitbox');
              if(isHori)
                this.imagex=HORIZONTALWALL;
              else
                this.imagex=VERTICALWALL;
            }
        }



//Game Classes end
    </script>

    <!-- start of canvas and gameManager running loop start -->
    
    <script>
        let backGroundColor="#000000";
        let gameManager=new GameManager();
        window.addEventListener('load', 
                        function () 
                                {
                                resize();                                   
                                var loop = function () 
                                                {                                                                               
                                                ctx.clearRect(0,0,canvas.width,canvas.height);  
                                                ctx.fillStyle = backGroundColor;
                                                ctx.fillRect(0,0,canvas.width, canvas.height);
                                                gameManager.update();   
                                                // showMouse();     
                                                };
                                setInterval(loop, deltaTime);                           
                                }
                        );
    </script>
    <!-- end of canvas and gameManager running loop end -->
</body>
</html>