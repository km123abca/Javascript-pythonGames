<!DOCTYPE html>
<html>
<head>
	<title>Platformer</title>
	<script src="scenedata.js"></script>
<script>	
	let mouseX,mouseY;
	let spacePress,upPress,rightPress,downPress,leftPress,gPress,fPress,enterPress;
	let ipress,lpress,mpress,jpress,tpress,hpress,bpress,ppress;
	let mousePressed;
    let clickDetector=false;

	// let backGroundColor="#16a1b3";
	let backGroundColor='#051405';
	let FPS=60;
	let deltaTime=1000 / FPS;
	function trackMouse(e)
	{
	mouseX=e.clientX;
	mouseY=e.clientY;
	}
	function showMouse()	
	{
		let mx=mouseX+gameManager.camera.position.x;
		let my=mouseY+gameManager.camera.position.y;
		mx=mx.toFixed(2);
		my=my.toFixed(2);
		w2screen(`${mx},${my}`,canvas.width/2,200);
	}
	const w2screen=(strr = "", px = 20, py = 30,fillStyle="#FFFFFF",siz=40) =>
    	{
	      ctx.font = `${siz}px Haettenschweiler`;
	      ctx.fillStyle = fillStyle;
	      ctx.fillText(strr, px, py);
    	}
    class CreateVector
    	{
		constructor(x,y)
			{
			 this.x=x;
			 this.y=y;	
			}	
		show(vecName='unknown vector')
			{
			 return (`${vecName}:${this.x},${this.y}`);
			}	
		set(x,y)
			{
			 this.x=x;
			 this.y=y;
			 return this;
			}
		setVec(vec)
			{
			 this.x=vec.x;
			 this.y=vec.y;			 
			}
		mag()
			{
			 return Math.sqrt(this.x**2+this.y**2);
			}
		add(vec)
			{
			this.x+=vec.x;
			this.y+=vec.y;
			return this;
			}
		sub(vec)
			{
			this.x-=vec.x;
			this.y-=vec.y;
			return this;
			}
		mult(num)
			{
			this.x*=num;
			this.y*=num;
			return this;
			}
		div(num)
			{
			if(num==0)
				{
				 alert("div by 0:!!!");
				 return new CreateVector(0,0);
				}
			this.x/=num;
			this.y/=num;
			return this;
			}
		normalize()
			{
			let mag=this.mag();
			if(mag==0) return this;
			this.x/=mag;
			this.y/=mag;
			return this;
			}
		normalized()
			{
			 return this.copy().normalize();
			}
		copy()
			{
			let copyVec=new CreateVector(this.x,this.y);
			return copyVec;
			}
		equals(vec)
			{
			 return this.x==vec.x && this.y==vec.y;
			}
		desc()
			{
			return `Vector:${this.x},${this.y}`
			}
		heading()
			{
			let angx=Math.atan2(this.y,this.x)/Math.PI*180;
			return angx<0?angx+360:angx;
			}
		pointToAngle(angle)
			{
			let mag=this.mag();
			this.x=mag*Math.cos(angle/180*Math.PI);
			this.y=mag*Math.sin(angle/180*Math.PI);			
			return this;
			}
		rotateByAngle(delta)
			{
			let ang=this.heading();
			return this.pointToAngle(ang+delta);
			}
		dot(vec)
			{
			return this.x*vec.x+this.y*vec.y;
			}		
    	}

    function PointInsideObject(objToCheck,pt)
    	{
    	if (pt.x >= objToCheck.position.x-objToCheck.width/2 && pt.x <= objToCheck.position.x+objToCheck.width/2)
		if (pt.y >= objToCheck.position.y-objToCheck.height/2 && pt.y <= objToCheck.position.y+objToCheck.height/2)
			return true
		return false
    	}
    function Raycast(originx,direction,lenx,objToCheck)
    	{
		//graphic	
		  	 
	 	 Draw_a_line(originx.copy().add(new CreateVector(0,0)),
	 	 	 		 originx.copy().add(new CreateVector(0,0)).add(direction.copy().mult(lenx))
	 	 	 		);	
	 	 	 
	 	//graphic

		let origin=originx.copy();
		let destin=originx.copy().add(direction.copy().mult(lenx));	
		let deltaz=2*xscale
		let startLen=0

		while (startLen < lenx)
			{
			if (PointInsideObject(objToCheck,origin.add(direction.copy().mult(deltaz))) )
				return true
			startLen+=deltaz
			}
		return false
		}
    function RaycastAll(originx,direction,lenx,arrOfArrObjs,arrAvoid)
    	{
    	
		//graphic		 	 
	 	 Draw_a_line(originx.copy().add(new CreateVector(0,0)),
	 	 	 		 originx.copy().add(new CreateVector(0,0)).add(direction.copy().mult(lenx))
	 	 	 		);	 	 
	 	//graphic

		let origin=originx.copy();
		let destin=originx.copy().add(direction.copy().mult(lenx));	
		let deltaz=2*xscale
		let startLen=0
			

		while (startLen < lenx)
			{
			for(let objxArr of arrOfArrObjs)
				for(let objToCheck of objxArr)
				{
				 let skipFlag=false;
				 for(let avoidObj of arrAvoid)
				 	{				 	
				 	if(avoidObj==objToCheck)
				 		{
				 		skipFlag=true;
				 		break;	
				 		}
				 	}
				 if (skipFlag) continue;

				 if (PointInsideObject(objToCheck,origin.add(direction.copy().mult(deltaz))) )
				 	{
				 	 console.log('reporting hit inside '+objToCheck.sprite_type);
				     return true;
					}
				}
			startLen+=deltaz;
			}
		return false
		}
	//collision check algorithm starts
	function b_collision(obj1,obj2)
		{
		 let cornerPoints1=[obj1.position.copy().add(new CreateVector(-obj1.width/2,-obj1.height/2)),
		 				   obj1.position.copy().add(new CreateVector(-obj1.width/2, obj1.height/2)),
		 				   obj1.position.copy().add(new CreateVector( obj1.width/2,-obj1.height/2)),
		 				   obj1.position.copy().add(new CreateVector( obj1.width/2, obj1.height/2))
		 				  ];
 		 let cornerPoints2=[obj2.position.copy().add(new CreateVector(-obj2.width/2,-obj2.height/2)),
		 				    obj2.position.copy().add(new CreateVector(-obj2.width/2, obj2.height/2)),
		 				    obj2.position.copy().add(new CreateVector( obj2.width/2,-obj2.height/2)),
		 				    obj2.position.copy().add(new CreateVector( obj2.width/2, obj2.height/2))
		 				  ];
		 cornerPoints1=cornerPoints1.map(x=>obj1.position.copy().add(x.copy().sub(obj1.position).rotateByAngle(obj1.angle)) );
		 cornerPoints2=cornerPoints2.map(x=>obj2.position.copy().add(x.copy().sub(obj2.position).rotateByAngle(obj2.angle)) );
		 return ArePointsInside(cornerPoints1,obj2)||ArePointsInside(cornerPoints2,obj1);
		}
	function ArePointsInside(pts,obj2)
		{
		let ptsy=pts.map(x=>GetRAVec(x,obj2.angle));
		let objx={position:GetRAVec(obj2.position,obj2.angle),width:obj2.width,height:obj2.height};
		for(let pt of ptsy)
			{
			 if(PointInsideObject(objx,pt)) return true;
			}
		return false;
		}
	//collision check algorithm ends
	//simple box collsion check
	function collisioncheckzVec(elem1,elem2)
				{
			return (inter_ects(elem1.position.x-elem1.width/2,elem1.position.y-elem1.height/2,
							   elem1.width,elem1.height,
					   		   elem2.position.x-elem2.width/2,elem2.position.y-elem2.height/2,
					   		   elem2.width,elem2.height
					  		  )
				   );
				}
	function circularCollision(elem1,elem2)
		{
			let centerSeperation=elem1.position.copy();
			centerSeperation.sub(elem2.position);
			centerSeperation=centerSeperation.mag();
			return centerSeperation < elem1.width/2+elem2.width/2;
		}
	function inter_ects(q1,q2,ql1,ql2,w1,w2,wl1,wl2)
				{
				if(w1>=q1)
					{
					if((w1-q1)<ql1)
						{
						if(w2>=q2)
							{
							if((w2-q2)<ql2) return true;
							return false;
							}
						else
							{
							if((q2-w2)<wl2) return true;
							return false;
							}
						}
					}
				else
					{
					if((q1-w1)<wl1)
						{
						if(w2>=q2)
							{
							if((w2-q2)<ql2) return true;
							return false;
							}
						else
							{
							if((q2-w2)<wl2) return true;
							return false;
							}
						}
					}
				}
	//simple box collision check ends
	function GetRAVec(a,angle)
		{
			let t=d2r(angle);
			let xval= a.x * Math.cos(t)+a.y * Math.sin(t);
			let yval=-a.x * Math.sin(t)+a.y * Math.cos(t);
			return new CreateVector(xval,yval);
		}
	function GetrRAVec(a,angle)
		{
			let t=d2r(angle);
			let xval= a.x * Math.cos(t)-a.y * Math.sin(t);
			let yval= a.x * Math.sin(t)+a.y * Math.cos(t);
			return new CreateVector(xval,yval);
		}
	function d2r(ang)
		{
		return ang/180*Math.PI;
		}
	function r2d(ang)
		{
		return ang/Math.PI*180;
		}
	function Lerp(startValue,endValue,LerpFac)
		{
		return startValue+(endValue-startValue)/LerpFac;
		}
    function AngleLerp(startValue,endValue,lerpFac)
    	{
    	// console.log('received start:'+startValue);
    	// console.log('received end:'+endValue);
    	if (Math.abs(endValue - startValue) < SepFrom360(startValue) + SepFrom360(endValue))
    		return startValue+(endValue-startValue)/lerpFac	
    	return CloseAngleDistance360(startValue,(SepFrom360(startValue)+SepFrom360(endValue))/lerpFac )
    	}
	function SepFrom360(angle)
		{
		if (angle < 180)
			return angle
		return 360 - angle
		}
	function CloseAngleDistance360(startAngle,delta)
		{
		if (startAngle < 180)
			{
			if (startAngle > delta)
				return startAngle - delta;
			return 360 - (delta - startAngle);
			}
		else
			{
			 if (360 - startAngle > delta)
			 	return startAngle + delta;
			 return delta - (360 - startAngle);
			}
		}
	function LoadImages(folderPath,imageNames)
		{
		let result=[];
		for(let imgx of imageNames)
			{
			let createdImage=new Image();
			// console.log('./'+folderPath+'/'+imgx);
			try
				{
				createdImage.src='./'+folderPath+'/'+imgx;
				}
			catch(err)
				{
				console.log(err);				
				}
			result.push(createdImage);
			}
		return result;
		}
	function LoadImagex(folderPath,imageName)
		{
			let createdImage= new Image();
			createdImage.src='./'+folderPath+'/'+imageName;
			return createdImage;
		}

	
	let tempTimer=0;
	function DisplayInGaps(strx)
		{
		 if(gameManager.runningClock - tempTimer > 2000)
		 	{
		 	  tempTimer=gameManager.runningClock;
		 	  console.log(strx);
		    }
		}

	function Draw_a_line(startPos,endPos,color='#FF0000')
		{
		ctx.strokeStyle=color;
		ctx.beginPath();
		ctx.moveTo(startPos.x - gameManager.camera.position.x,startPos.y - gameManager.camera.position.y);
		ctx.lineTo(endPos.x - gameManager.camera.position.x,endPos.y - gameManager.camera.position.y);
		ctx.stroke();
		}

	function destroySelf(objx)
		{	
		 	 
		 for(let i in objx.spriteGroups)
		 {		  
	 	  for(let j in objx.spriteGroups[i])
	 		{

	 		 if(objx.spriteGroups[i][j]==objx)
	 		 	{ 	  
	 		 	  objx.spriteGroups[i].splice(j,1);
	 		 	  break;
	 		 	}	
	 		}
		 }
		 
		}
	
let BLACKCLOUD= LoadImagex('sprites','cloud-1dark.png');
let WHITECLOUD= LoadImagex('sprites','cloud-1.png');
let THORNYBALL = LoadImagex('sprites','Thornyball.png');
let PICKAXEIMG = LoadImagex('sprites/huskMiner','Pick.png');
let THORNIMAGE = LoadImagex('sprites/misc','thorn.png');
let ELEVATORIMAGE=LoadImagex('sprites/misc','Elevator.png');
let FORESTIMAGE = LoadImagex('sprites/Shrub','TreeCopse.png');
let FLOWERIMAGE= LoadImagex('sprites/misc','Flower.png');
let GATEIMAGE= LoadImagex('sprites/misc','gate.png');
let VERTICALSHRUB=LoadImagex('sprites/Shrub','VerticalShrub.png');
let GRAYBOX =LoadImagex('sprites','graybox.png');
let HORIZONTALPLATFORMTILE=`./sprites/workshop/platform1.png`;  
let FORESTBACKGROUND=LoadImagex('sprites','ForestBackground.jpg');  

let SAWWHEEL1= LoadImagex('sprites/workshop','sawwheel1.png');
let SAWWHEEL2= LoadImagex('sprites/workshop','sawwheel2.png');
let SAWWHEEL3= LoadImagex('sprites/workshop','sawwheel3.png');
    
</script>
</head>
<body style='background-color:black;'>
<canvas style='border:3px solid black;' onmousemove="trackMouse(event)">
<!--audio list-->
	<audio id="backgroundMusic" onended="resetMusicVar()">
		<source src="./sounds/techno_bg_music.mp3" type="audio/mpeg">
	</audio>
	<audio id="greenPath" onended="resetMusicVar()">
		<source src="./sounds/Hollow Knight OST - Greenpath.mp3" type="audio/mpeg">
	</audio>
	<audio id="crystalPeak" onended="resetMusicVar()">
		<source src="./sounds/Hollow Knight OST - Crystal Peak.mp3" type="audio/mpeg">
	</audio>
    <audio id="sawWheelBG" onended="restartSawWheelBG()">
        <source src="./sounds/sawWheel.mp3" type="audio/mpeg">
    </audio>
	<audio id="capraMusic" onended="restartCapraMusic()">
		<source src="./sounds/Capra.mp3" type="audio/mpeg">
	</audio>
	<audio id="fogGate" >
		<source src="./sounds/fogGate.wav" type="audio/mpeg">
	</audio>
	<audio id="GetCoin" >
		<source src="./sounds/GetCoin.wav" type="audio/mpeg">
	</audio>
	<audio id="GoalBloop" >
		<source src="./sounds/GoalBloop.wav" type="audio/mpeg">
	</audio>
	<audio id="HitPaddleBloop" >
		<source src="./sounds/HitPaddleBloop.wav" type="audio/mpeg">
	</audio>
	<audio id="parry" >
		<source src="./sounds/parry.wav" type="audio/mpeg">
	</audio>
	<audio id="Jump" >
		<source src="./sounds/Jump.wav" type="audio/mpeg">
	</audio> 
	<audio id="RockSmash" >
		<source src="./sounds/RockSmash.wav" type="audio/mpeg">
	</audio>
    <audio id="retroJump" >
        <source src="./sounds/retroJump.wav" type="audio/mpeg">
    </audio>
	<audio id="LossBuzz" >
		<source src="./sounds/LossBuzz.wav" type="audio/mpeg">
	</audio>
	<audio id="whoosh" >
		<source src="./sounds/whoosh.wav" type="audio/mpeg">
	</audio>
	<audio id="cornifer" >
		<source src="./sounds/individualSounds/Cornifer_01.wav" type="audio/mpeg">
	</audio>
	<audio id="cornifer2" >
		<source src="./sounds/individualSounds/Cornifer_02.wav" type="audio/mpeg">
	</audio>
	<audio id="mawlekscream" >
		<source src="./sounds/individualSounds/mawlek_scream.wav" type="audio/mpeg">
	</audio>
<script>
	const playRandomCornifer=()=>{
		if(Math.random()<0.5)
			document.querySelector('#cornifer').play();
		else
			document.querySelector('#cornifer2').play();
	}
</script>
<!--audio list ends-->
<script>
	var canvas = document.querySelector('canvas');
	//music starts
	var bgMusic= document.querySelector('#backgroundMusic');
	var fogGateSound= document.querySelector('#fogGate');
	var coinSound= document.querySelector('#GetCoin');
	var capraMusic= document.querySelector('#capraMusic');
    var sawWheelBG=document.querySelector('#sawWheelBG');

	//background scores
	var greenPath= document.querySelector('#greenPath');
	var crystalPeak= document.querySelector('#crystalPeak');
    
	var musicList=[greenPath,crystalPeak];
    var musicFileNames=["Hollow Knight OST - Greenpath.mp3","Hollow Knight OST - Crystal Peak.mp3"];
    var bossMusicList=[capraMusic];
    var bossMusicFileNames=['Capra.mp3']
	//background scores end
	let okToStartMusic=false;
	let musicStarted=false;
	let presentMusicIndex=0;
	var pauseBossMusic=()=>{
						for(let i in bossMusicList) bossMusicList[i].src="";
						for(let i in bossMusicList) bossMusicList[i].src=`./sounds/${bossMusicFileNames[i]}`;	
							};
	var pauseMusic=()=>{
						musicStarted=false;
						for(let i in musicList) musicList[i].src="";
						for(let i in musicList) musicList[i].src=`./sounds/${musicFileNames[i]}`;
	};
	var startMusic=()=>{
						if(!musicStarted && okToStartMusic)
							{
							 musicStarted=true;
                             musicList[presentMusicIndex % musicList.length].volume=0.2;
							 musicList[presentMusicIndex % musicList.length].play();
							}	
						};

	var resetMusicVar=()=>{
		musicStarted=false;
		startMusic();
	}

	
	var restartCapraMusic=()=>{
		capraMusic.play();
	}
    var restartSawWheelBG=()=>{
        sawWheelBG.play();
    }
	//music ends
	
   	ctx = canvas.getContext('2d');
   	canvas.width = window.innerWidth-35;
  	canvas.height = window.innerHeight-100;
  	let xscale=canvas.width/1273;
    let yscale=canvas.height/873;
    var resize = function () 
		{
		canvas.width = window.innerWidth-35;
		canvas.height = window.innerHeight-100;
		};

	window.addEventListener('resize', resize);
	//keypresses start
    let upArrow=false,leftArrow=false,rightArrow=false,downArrow=false;
    let keysPressed=new Set();
    let specKeys=new Set([38]);
    
    GetSpecialKeyNames=(keyCode)=>{
        if(keyCode==38) return 'upArrow';
        return -1;
    }
    CapturePressedKey=(keyCode,pressed=true)=>{

        if (specKeys.has(keyCode)){
            if(pressed)
            keysPressed.add(GetSpecialKeyNames(keyCode));
            else
            keysPressed.delete(GetSpecialKeyNames(keyCode));
            return;
        }

    	if(!((keyCode>64 && keyCode<91)||(keyCode > 96 && keyCode < 123)||(keyCode==32))) return false;
    	let charx=String.fromCharCode(keyCode);
    	let charx2=String.fromCharCode(keyCode+32);    	
    	if(pressed && !keysPressed.has(charx))    		
    		keysPressed.add(charx);
    	else if(!pressed)
    	    {
    	     keysPressed.delete(charx);
    	     keysPressed.delete(charx2);
    	    }
    }

    GetKeyPressedx=(x)=>{
    	return keysPressed.has(x)||keysPressed.has(x.toUpperCase());
    }

    let pressedKeyCode=-1;
	document.onkeydown=function(e)
	                 {
	                 	// console.log(`pressed ${e.keyCode}`);
	                 	// CapturePressedKey(e.keyCode);             	
	                 	if(!okToStartMusic)
	                 		{
	                 		 okToStartMusic=true;
	                 		 startMusic();
	                 		}
                        CapturePressedKey(e.keyCode);
                        pressedKeyCode=e.keyCode;
	                 	if(e.keyCode==37) leftArrow=true;
	                 	if(e.keyCode==38) upArrow=true;                        
	                 	if(e.keyCode==39) rightArrow=true;
	                 	if(e.keyCode==40) downArrow=true;
	                 }

	document.onkeypress=function (e)
					{
					pressedKeyCode=e.keyCode;
					// console.log(e.keyCode);	
					CapturePressedKey(e.keyCode);		
					if(e.keyCode==32) spacePress=true;
					if(e.keyCode==119) upPress=true;
					if(e.keyCode==100) rightPress=true;
					if(e.keyCode==115) downPress=true;
					if(e.keyCode==97) leftPress=true;
					if(e.keyCode==103) gPress=true;
					if(e.keyCode==102) fPress=true;
					if(e.keyCode==13)  enterPress=true;	

					if(e.keyCode==105) ipress=true;	
					if(e.keyCode==108) lpress=true;	
					if(e.keyCode==109) mpress=true;		
					if(e.keyCode==106) jpress=true;

					if(e.keyCode==116) tpress=true;	
					if(e.keyCode==104) hpress=true;	
					if(e.keyCode==98) bpress=true;	

					if(e.keyCode==112)
									{

									// gameManager.gamePaused=!gameManager.gamePaused; 
									if(gameManager)
										{
										 gameManager.togglePauseScreen();
										}
									ppress=true;
									}	
					};
	document.onkeyup=function (e)
					{	
					// console.log(`released ${e.keyCode}`);
					pressedKeyCode=-1;
					CapturePressedKey(e.keyCode,false);
					if(e.keyCode==32) spacePress=false;					
					if(e.keyCode==87) upPress=false;
					if(e.keyCode==68) rightPress=false;
					if(e.keyCode==83) downPress=false;
					if(e.keyCode==65) leftPress=false;
					if(e.keyCode==71) gPress=false;
					if(e.keyCode==70) fPress=false;
					if(e.keyCode==13)  enterPress=false;

					if(e.keyCode==73) ipress=false;
					if(e.keyCode==76) lpress=false;
					if(e.keyCode==77) mpress=false;
					if(e.keyCode==74) jpress=false;

					if(e.keyCode==84) tpress=false;
					if(e.keyCode==72) hpress=false;
					if(e.keyCode==66) bpress=false;

					if(e.keyCode==80) ppress=false;

					if(e.keyCode==37) leftArrow=false;
                 	if(e.keyCode==38) upArrow=false;
                 	if(e.keyCode==39) rightArrow=false;
                 	if(e.keyCode==40) downArrow=false;
					};
	document.onmousedown=function(e)
					{
					mousePressed=true;													
					};	
	document.onmouseup=function(e)
					{
					mousePressed=false;												
					};
	//keypresses end

	let checkVar=true;
	//Game Classes Start

	class IndicatorObjs
		{
		constructor(x,y,colorx,sprite_type,spriteGroups)
			{
			 this.position=new CreateVector(x,y);
			 this.sprite_type=sprite_type;
			 this.angle=0;
			 this.colorx=colorx;
			 this.rad=20*xscale;
			 for(let grp of spriteGroups)
			 	grp.push(this);
			 this.onScreen=true;
			 this.width=111;
			 this.height=111;
			}
		display()
			{	
			if(!this.onScreen) return false; 				
			ctx.save();			
			ctx.translate(this.position.x - gameManager.camera.position.x,this.position.y - gameManager.camera.position.y);	
			ctx.fillStyle=this.colorx;
			ctx.strokeStyle=this.colorx;				
			ctx.beginPath();
			ctx.arc(0,0,this.rad,0,2*Math.PI);
			ctx.fill();
			ctx.stroke();
			ctx.restore();
			w2screen(this.sprite_type,
				     this.position.x-gameManager.camera.position.x,
				     this.position.y-50*yscale-gameManager.camera.position.y);
			}
		}
	//start of dummy point
	class MarkedSpot extends IndicatorObjs
		{
		constructor(x,y,sprite_type,spriteGroups)
			{

			  super(x,y,'#0000FF',sprite_type,spriteGroups);
			  // this.sprite_type=sprite_type;
			}
		 update()
		  {	
		  	return false;
		  }
		}
	//end of dummy point

	class SceneChanger extends IndicatorObjs
		{
		constructor(x,y,sprite_type,spriteGroups)
			{
			  super(x,y,'#00FFFF',sprite_type,spriteGroups);
			  // this.sprite_type=sprite_type;
			  this.width=50*xscale;
			  this.height=200*yscale;
			  this.cornerPts=[[-1,-1],[1,-1],[1,1],[-1,1]];
			  this.cornerPts=this.cornerPts.map(x=>[x[0]*this.width/2,x[1]*this.height/2]);
			  
			}
		update()
			{			
			 if(!gameManager.player) return false; 
			 if(!gameManager.inTransition && b_collision(this,gameManager.player))
			 	{			 	  
			 	  gameManager.changeScene(this.sprite_type);
			 	}
			}
		display()
			{			
			if(!this.onScreen)
				return false;
			ctx.save();
            ctx.translate(this.position.x - gameManager.camera.position.x,this.position.y - gameManager.camera.position.y);                          
            ctx.fillStyle=this.colorx;
            ctx.strokeStyle=this.colorx;
            ctx.beginPath();
            ctx.moveTo(this.cornerPts[0][0],this.cornerPts[0][1]);
            for(var g=1;g<this.cornerPts.length;g++)
                ctx.lineTo(this.cornerPts[g][0],this.cornerPts[g][1]);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();               
            ctx.restore();
			}
		}
	class EntryExitPoint extends IndicatorObjs
		{
		constructor(x,y,sprite_type,spriteGroups)
			{
			  super(x,y,'#0000FF',sprite_type,spriteGroups);
			  // this.sprite_type=sprite_type;
			}
		 update()
		  {	
		  	return false;
		  	/*
		  	if(gameManager.camera.tgt==this)
		  	{		  	 
		  	 switch(this.sprite_type)
		  	 	{
		  	 	 case 'entry':
		  	 	 	if(gameManager.player.position.x > this.position.x)
		  	 	 		gameManager.camera.tgt=gameManager.player;
		  	 	 		break;
		  	 	 case 'exit':
		  	 	 	if(gameManager.player.position.x < this.position.x)
		  	 	 		gameManager.camera.tgt=gameManager.player;
		  	 	 		break;
		  	 	}
		  	}
		  	*/

		  }
		}

	class CameraStopper extends IndicatorObjs
		{
		constructor(x,y,sprite_type,spriteGroups)
		  {
		  	super(x,y,'#00FF00',sprite_type,spriteGroups);
		  	// this.sprite_type=sprite_type;
		  	if(sprite_type=='camstopper_right') gameManager.bottomY=y;
		  }
		cameraCanFollow(objx)
		  {
		  	let resultArray=[true,true];
		    if((this.sprite_type=='camstopper_left' && objx.position.x < this.position.x) ||
		       (this.sprite_type=='camstopper_right' && objx.position.x > this.position.x)
		      )
		    	resultArray[0]=false;//return [false,true];
		    // if((this.sprite_type=='camstopper_left' && objx.position.y < this.position.y) ||
		    //    (this.sprite_type=='camstopper_right' && objx.position.y > this.position.y)
		    //   )
		    // 	resultArray[1]=false;
            if(this.sprite_type=='camstopper_right' && objx.position.y > this.position.y)
                resultArray[1]=false;
		    return resultArray;//return [true,true];
		  }
		 update()
		  {		
		  if(!gameManager.player) return false;  
		  if(gameManager.camera.tgt==this)
		  	{		  	 
		  	 switch(this.sprite_type)
		  	 	{
		  	 	 case 'camstopper_left':
		  	 	 	if(gameManager.player.position.x > this.position.x)
		  	 	 		gameManager.camera.tgt=gameManager.player;
		  	 	 		break;
		  	 	 case 'camstopper_right':
		  	 	 	if(gameManager.player.position.x < this.position.x)
		  	 	 		gameManager.camera.tgt=gameManager.player;
		  	 	 		break;
		  	 	}
		  	}
		  }
		}


	//positionAdjuster start
	class PositionAdjuster
		{
		constructor(obj,spriteGroups)
			{
			 this.obj=obj;
			 this.sprite_type="pos_adjuster";
			 this.onScreen=true;
			 this.rad=50*xscale;
			 this.moveSpeed=0;
			 this.moveSpeedMax=200*xscale;
			 this.shapeSpeed=0;
			 this.shapeSpeedMax=50;
			 this.objIndex=0;
			 this.last_gpress_time=0;	 
			 for(let grp of spriteGroups)
			 	{
			 	 grp.push(this);
			 	}
			}
		changeObject(obj)
			{
			 this.obj=obj;
			}
		display()
			{	
			if(!this.obj) return false;		 				
			ctx.save();			
			ctx.translate(this.obj.position.x - gameManager.camera.position.x,this.obj.position.y - gameManager.camera.position.y);	
			ctx.fillStyle='#FFFF00';
			ctx.strokeStyle='#FF0000';				
			ctx.beginPath();
			ctx.arc(0,0,this.rad,0,2*Math.PI);
			ctx.fill();
			ctx.stroke();
			ctx.restore();
			}
		update()
			{
			 this.attractFocus();
			 if(!this.obj) return false;
			 this.adjustObjPosition();
			 this.adjustObjShape();			 	
			 this.showData();		 
			}

		showData()
			{
			 if(!this.obj) return false;
			 w2screen(`sprite:${this.obj.sprite_type}`,300,100);
			 w2screen(`x:${(this.obj.position.x/xscale).toFixed(0)},y:${(this.obj.position.y/yscale).toFixed(0)}`,300,150);
			 w2screen(`width:${(this.obj.width/xscale).toFixed(0)},height:${(this.obj.height/yscale).toFixed(0)}`,300,200);
			}	
		attractFocus()
			{
			if(gPress)
				{
				  
				  if(gameManager.runningClock - this.last_gpress_time > 250)
				  	{
				  	  this.last_gpress_time=gameManager.runningClock;
				  	  this.objIndex+=1;
				  	  if(this.objIndex >= gameManager.visible_sprites.length) this.objIndex=0;
				  	  if(gameManager.visible_sprites[this.objIndex]==this)
				  	  	this.objIndex+=1;
				  	  this.changeObject(gameManager.visible_sprites[this.objIndex]);
				  	}
				}
			}
		adjustObjPosition()
			{
			 if(ipress || jpress || mpress || lpress) 
			 	this.moveSpeed=Lerp(this.moveSpeed,this.moveSpeedMax,16);
			 else
			 	this.moveSpeed=0;
			 if(ipress)		 				 	 
			 	this.obj.position.y=this.obj.position.y - this.moveSpeed;
			 else if(mpress)
			 	this.obj.position.y=this.obj.position.y + this.moveSpeed;

			 if(lpress)
			 	this.obj.position.x=this.obj.position.x + this.moveSpeed;
			 else if(jpress)
			 	this.obj.position.x=this.obj.position.x - this.moveSpeed;
			}

		adjustObjShape()
			{
			 if(tpress || hpress || bpress || fPress) 
			 	this.moveSpeed=Lerp(this.moveSpeed,this.moveSpeedMax,16);
			 else
			 	this.moveSpeed=0;
			 if(tpress)		 				 	 
			 	this.obj.height=this.obj.height - this.moveSpeed;
			 else if(bpress)
			 	this.obj.height=this.obj.height + this.moveSpeed;

			 if(hpress)
			 	this.obj.width=this.obj.width + this.moveSpeed;
			 else if(fPress)
			 	this.obj.width=this.obj.width - this.moveSpeed;
			}

		}
	//positionAdjuster ends


	class Platform
		{
		 constructor(x,y,width,height,spriteGroups)
		 	{
		 	 // console.log(`platform with width:${width} loaded`);
		 	 this.position=new CreateVector(x,y);
		 	 this.width=width;
		 	 this.height=height;
		 	 this.angle=0;
		 	 let imgx=new Image();
		 	 imgx.src=`./sprites/Pipes/pipeHori.png`;
		 	 this.animations={'idle':[imgx]};
		 	 this.animation='idle';
		 	 this.animationFrame=0;
		 	 this.mc=false;
		 	 this.onScreen=true;
		 	 this.sprite_type='platform';
		 	 for(let grp of spriteGroups)
		 	 	grp.push(this);

		 	}
		 update()
		 	{
		 	 //this.runAnimation();
		 	 // console.log(`${this.sprite_type+this.width} updating`);
		 	 // this.manualControls();
		 	 return false;
		 	}
		 display()
		 	{
		 	 if(!this.onScreen) return false;

		 	 ctx.save();
		 	 ctx.translate(this.position.x-gameManager.camera.position.x, 
		 	 	 		   this.position.y-gameManager.camera.position.y);
		 	 ctx.rotate(d2r(this.angle));
		 	 ctx.drawImage(this.animations[this.animation][this.animationFrame],
		 	 			   -this.width/2,
		 	 			   -this.height/2,
		 	 			   this.width,
		 	 			   this.height
		 	 			  );
		 	 ctx.restore(); 
		 	}
		  	manualControls()
		  		{
		  		if(upPress) this.position.y-=5;
		  		if(downPress) this.position.y+=5;
		  		if(leftPress) this.position.x-=5;
		  		if(rightPress) this.position.x+=5;

		  		if(gPress) this.angle+=1;
		  		if(fPress) this.angle-=1;
		  		// this.checkCollisions();
		  		}
		  	checkCollisions()
		  		{
		  		 for(let sp of gameManager.visible_sprites)
		  		 	{		
		  		 	if(sp==this || sp.sprite_type=="pos_adjuster") continue;
		  		 	// console.log(sp.sprite_type);  		 	
		  		 	if(checkVar)
			  		 	{
			  		 	try
				  		 	{
				  		 	if(b_collision(this,sp))
				  		 		{
				  		 		 console.log('collision');
				  		 		} 
				  		 	}
				  		 catch(err)
				  		 	{
				  		 		checkVar=false;
				  		 		console.log(err);
				  		 	}
			  		 	}
		  		 	}
		  		}		 
		}

	class Wall 
		{
		constructor(x,y,wid,hei,isHorizontal,copies,spriteGroups,destructTime=0)
			{
			 this.destructTime=destructTime;             
			 this.position=new CreateVector(x,y);
			 this.width=wid;
			 this.height=hei;
             this.birthTime=gameManager.runningClock;
			 this.onScreen=true;
			 this.sprite_type="combinedwall";
			 this.isHorizontal=isHorizontal;
			 if(!isHorizontal) this.sprite_type="combinedwallVertical"
			 let imgx=new Image();
			 if(this.isHorizontal)
		 	 imgx.src=`./sprites/workshop/platform1.png`;		 	 
		 	 else
		 	 	imgx.src=`./sprites/workshop/shrubwall.png`;
		 	 this.imgx=imgx;
		 	 this.spriteGroups=spriteGroups;
			 for(let grp of spriteGroups)
			 	grp.push(this);
			 this.angle=this.isHorizontal?0:90;
			 this.copies=copies;
             this.obeyGravity=false;
             this.widFrac=destructTime==0?1:0.9;
			 if(this.isHorizontal)             
			 this.hit_box=new HitBox(this.position.x+this.copies*this.width/2-this.width/2,
			 						 this.position.y,
			 						 this.width*this.copies*this.widFrac,
			 						 this.height*0.5,
			                         [ 
			                          // gameManager.visible_sprites,
			                          gameManager.collission_sprites
			                         ],this,
				                     'hori_wallhitbox');
			else
			this.hit_box=new HitBox(this.position.x,
			 						 this.position.y+this.copies*this.height/2-this.height/2,
			 						 this.width*0.5,
			 						 this.height*(this.copies+0.8),
			                         [ 
			                          // gameManager.visible_sprites,
			                          gameManager.collission_sprites
			                         ],this,
				                     'vert_wallhitbox');
            this.dustSpawned=false;	
            this.gravityScale=1*yscale;
            this.velocity=new CreateVector(0,0);
            this.acceleration=new CreateVector(0,0);
            this.maxVelocity=new CreateVector(5*xscale,20*yscale);
			}
		update()
		 	{
             this.selfDestruct();
             if(this.obeyGravity)
                {
                this.applyGravity();   
                this.velocity.add(this.acceleration);
                this.acceleration.set(0,0);
                this.applyVelocity();
                this.applyVelocityRestrictions();
                this.update_and_display_hitbox();
                // console.log(`${this.position.x.toFixed(2)},${this.position.y.toFixed(2)}`);
                }          		 	
		 	}
        applyGravity()
            {
             this.acceleration.y+=this.gravityScale;
            }
        selfDestruct(){
            if(this.destructTime==0)
                return;
            if(gameManager.runningClock - this.birthTime > 0.9*this.destructTime)
            {
                if(!this.dustSpawned){
                    this.dustSpawned=true;
                    SpawnClouds(this.position);
                }
            }
            if(gameManager.runningClock - this.birthTime > this.destructTime && !this.obeyGravity){
                if(okToStartMusic)
                document.querySelector('#RockSmash').play();
                this.obeyGravity=true;
            }
            if(gameManager.runningClock - this.birthTime-2000 > this.destructTime){
                console.log('wall gone');
                destroySelf(this.hit_box);
                destroySelf(this);
            }
        }
//velocity application
         applyVelocity()
            {                    
             this.hit_box.position.x+=this.velocity.x;          
             for(let k in gameManager.collission_sprites)
                { 
                 let x=gameManager.collission_sprites[k];
                 if(!x.onScreen) continue;
                 if(x==this || x==this.hit_box) continue;               
                 if(b_collision(this.hit_box,x)) 
                    {    
                            
                     this.collidedObj=x.sprite_type;     
                     if(this.velocity.x > 0)
                        {                    
                        this.hit_box.position.x=x.position.x - x.width/2-this.hit_box.width/2-2;    

                        }
                     else 
                        {
                        this.hit_box.position.x=x.position.x + x.width/2 + this.hit_box.width/2+2;                      
                        }
                    }
                }

             this.hit_box.position.y+=this.velocity.y;
             for(let x of gameManager.collission_sprites)
                {

                 if(!x.onScreen) continue;
                 if(x==this || x==this.hit_box) continue;

                 if(b_collision(this.hit_box,x)) 
                    {
                         
                    this.collidedObj=x.sprite_type;                 
                    if(this.velocity.y > 0)
                        {
                        this.hit_box.position.y=x.position.y-x.height/2-this.hit_box.height/2-2;    
                        this.acceleration.add(new CreateVector(0,2*-this.velocity.y));                  
                        }
                    else
                        {
                        this.hit_box.position.y=x.position.y+x.height/2+this.hit_box.height/2+2;        
                        this.acceleration.add(new CreateVector(0,2*this.velocity.y));               
                        }
                    }
                }
            }
         update_and_display_hitbox()
            {           
            this.position.setVec(this.hit_box.position);
            }
         applyVelocityRestrictions()
            {
             let xdir=this.velocity.x/Math.abs(this.velocity.x);
             let ydir=this.velocity.y/Math.abs(this.velocity.y);
             if(Math.abs(this.velocity.y) > this.maxVelocity.y)
                this.velocity.y=ydir*this.maxVelocity.y;
             if(Math.abs(this.velocity.x) > this.maxVelocity.x)
                this.velocity.x=xdir*this.maxVelocity.x;
            }
//velocity application ends

		display()
			{
			 if(!this.onScreen) return false;
			 for(let i=0;i<this.copies;i++)
			 	this.displayUnit(i);
			}
		displayUnit(i)
		 	{
		 	 ctx.save();
		 	 if(this.isHorizontal)
			 	 ctx.translate(this.position.x+i*this.width-gameManager.camera.position.x, 
			 	 	 		   this.position.y-gameManager.camera.position.y);
		 	 else
			 	 ctx.translate(this.position.x-gameManager.camera.position.x, 
			 	 	 		   this.position.y+i*this.height-gameManager.camera.position.y);
		 	 ctx.rotate(d2r(this.angle));
		 	 ctx.drawImage(this.imgx,
		 	 			   -this.width/2,
		 	 			   -this.height/2,
		 	 			   this.width,
		 	 			   this.height
		 	 			  );
		 	 ctx.restore(); 
		 	}

		}

	class HitBox
		{
		 constructor(x,y,wid,hei,spriteGroups,parent,hitboxName="unknown hitbox",
		 	fillColor="#b3ffff")
		 	{
             this.parent=parent;
		 	 this.position= new CreateVector(x,y);
		 	 this.width = wid;
			 this.height= hei;
			 this.onScreen=true;
			 this.sprite_type=hitboxName;
			 this.angle=0;
			 this.spriteGroups=spriteGroups;
			 for(let grp of spriteGroups)
			 	grp.push(this);
		 	}
		 update()
		 	{
		 	 return true;
		 	}
		 updatePosition(pos)
		 	{
		 	 if(!this.position.equals(pos))
		 	 	this.position.setVec(pos);		
		 	}
		 display()
		 	{		 	 
		 	 if(!this.onScreen) return false;
		 	 ctx.save();
		 	 ctx.translate(this.position.x-gameManager.camera.position.x, 
		 	 	 		   this.position.y-gameManager.camera.position.y);
		 	 ctx.rotate(d2r(this.angle));
		 	 // ctx.scale(this.sx,this.sy);
		 	 ctx.fillStyle='#b3ffff';
		 	 ctx.strokeStyle='#00FF00';
		 	 ctx.beginPath();
		 	 ctx.rect(-this.width/2,-this.height/2,this.width,this.height);
		 	 ctx.stroke();
		 	 ctx.fill();		 	 
		 	 ctx.restore();
		 	}

		}



	class DamageHitBox extends HitBox
		{
		constructor(x,y,wid,hei,spriteGroups,hitboxName="unknown hitbox",parentx,xoffset,yoffset,dmg=10,dmghitback=0,life=50)
			{
			super(x,y,wid,hei,spriteGroups,parentx,hitboxName);
			this.spriteGroups=spriteGroups;
			this.startTime= gameManager.runningClock;
			this.parentx=parentx;
			this.offset=new CreateVector(xoffset,yoffset);
			this.dmg=dmg;
			this.hitback=dmghitback;
			this.life=life;
			}
		causeDamage(go)
			{
			  console.log(`caused damage to ${go.sprite_type}`);
			  go.takeDamage(this.dmg,this.hitback);
			  if(this.parentx.hitBoxMadeContact)
			  	{
			  	 this.parentx.hitBoxMadeContact(this.hitboxName);			  	 
			  	}
			  this.destroySelf();
			  SpawnClouds(go.position);			 
			}
		update()
			{
			 if(gameManager.runningClock - this.startTime > this.life)
			 	{			 			 	
			 	this.destroySelf();			 	
			 	}
			 this.updatePosition();
			}
		updatePosition()
			{			 
			 let offset=this.offset.copy();
			 offset.x*=this.parentx.sx;
			 offset.y*=this.parentx.sy;
			 super.updatePosition(this.parentx.position.copy().add(offset));
			}
		destroySelf()
			{
			 for(let i in this.spriteGroups)
			 {
		 	for(let j in this.spriteGroups[i])
		 		{
		 		 if(this.spriteGroups[i][j]==this)
		 		 	{		 		 	  
		 		 	  this.spriteGroups[i].splice(j,1);
		 		 	  break;
		 		 	}	
		 		}
			 }
			}
		}

	function SpawnClouds(pos,n=60,type="normal")
		{
		 for(let i=0;i<n;i++)
		 	new CloudBurst(pos.x,pos.y,[gameManager.visible_sprites,gameManager.active_sprites],type);
		}

	class CloudBurst
		{
		 constructor(x,y,spriteGroups,type="normal")
		 	{
		 	 this.position = new CreateVector(x,y);
		 	 this.width= 15 * xscale;
		 	 this.sprite_type='cloud';
		 	 this.height= 15 * yscale;
		 	 this.imagex= WHITECLOUD;
             if(type!="normal") this.imagex=BLACKCLOUD;
		 	 this.onScreen=true;
		 	 this.isActive=true;
		 	 this.spriteGroups=spriteGroups;
		 	 for(let grp of spriteGroups)
			 	grp.push(this);
			 this.angle=0;	
			 this.birthTime=gameManager.runningClock;	
			 this.maxLife=1500;	
			 this.velocity=new CreateVector((Math.random()-0.5)*4,(Math.random()-0.5)*4);

		 	}
		 display()
		 	{
			if(!this.onScreen) return false; 				
			ctx.save();			
			ctx.translate(this.position.x - gameManager.camera.position.x,this.position.y - gameManager.camera.position.y);	
			ctx.drawImage(this.imagex,-this.width/2,-this.height/2,this.width,this.height);
			ctx.restore();
		 	}
		 update()
		 	{
		 	 this.move();
		 	 if(gameManager.runningClock - this.birthTime > this.maxLife)
		 	 	{
		 	 	 destroySelf(this);
		 	 	}		 	 
		 	}
		 move()
		 	{
		 	 this.position.add(this.velocity);
		 	}
		}
	class GeneralSprite
		{
		constructor(x,y,wid,hei,hitboxoffsetx,hitboxoffsety,spriteGroups)
			{			 
			 this.position= new CreateVector(x,y);			 
			 this.hitboxOffset= new CreateVector(hitboxoffsetx,hitboxoffsety);
			 this.width = wid * xscale;
			 this.height = hei * yscale;
			 this.onScreen=true;
			 this.angle=0;
			 this.imagex= WHITECLOUD;		
			 this.sprite_type='generalSprite';	
			 this.spriteGroups= spriteGroups; 
			 for(let x of this.spriteGroups)
			 	x.push(this);
			}
		display()
		 	{		 	 
		 	 if(!this.onScreen) return false;

		 	 ctx.save();

		 	 ctx.translate(this.position.x-gameManager.camera.position.x, 
		 	 	 		   this.position.y-gameManager.camera.position.y);		 	 
		 	 ctx.drawImage(this.imagex,-this.width/2,-this.height/2,this.width,this.height);		 	 
		 	 ctx.restore();
		 	}
		 update()
		 	{
		 	 return true;
		 	}
		//addition on 05-09-2024 to add up on the functionality of general sprite
//velocity application
         applyVelocity(hit_box,velocity)
            {                    
             hit_box.position.x+=velocity.x;          
             for(let k in gameManager.collission_sprites)
                { 
                 let x=gameManager.collission_sprites[k];
                 if(!x.onScreen) continue;
                 if(x==this || x==hit_box) continue;               
                 if(b_collision(hit_box,x)) 
                    {                     
                     if(velocity.x > 0)                                            
                        hit_box.position.x=x.position.x - x.width/2-hit_box.width/2-2;   
                     else                     
                        hit_box.position.x=x.position.x + x.width/2 + hit_box.width/2+2;        
                    }
                }
             hit_box.position.y+=velocity.y;
             for(let x of gameManager.collission_sprites)
                {

                 if(!x.onScreen) continue;
                 if(x==this || x==hit_box) continue;

                 if(b_collision(hit_box,x)) 
                    {                                 
                    if(velocity.y > 0)                        
                        hit_box.position.y=x.position.y-x.height/2-hit_box.height/2-2;  
                    else                        
                        hit_box.position.y=x.position.y+x.height/2+hit_box.height/2+2;     
                    }
                }
            }
         update_and_display_hitbox(hit_box)
            {           
            this.position.setVec(hit_box.position.copy().add(this.hitboxOffset));
            }
         applyVelocityRestrictions(velocity,maxVelocity)
            {
             let xdir=velocity.x/Math.abs(velocity.x);
             let ydir=velocity.y/Math.abs(velocity.y);
             if(Math.abs(velocity.y) > maxVelocity.y)
                velocity.y=ydir*maxVelocity.y;
             if(Math.abs(velocity.x) > maxVelocity.x)
                velocity.x=xdir*maxVelocity.x;
            }
		//addition ends
		}

   class Elevator extends GeneralSprite
   	    {
           constructor(x,y,wid,hei,turnTime,spriteGroups)
           	{
           		super(x,y,wid,hei,0,0,spriteGroups);
           		this.sprite_type="elevator";
      
           		this.elevate_box=new HitBox(this.position.x,
           			                    this.position.y,
                	                    this.width,
                	                    this.height,
                                         [ 
                                         // gameManager.elevatorboxes,
                                         // gameManager.visible_sprites,
                                         gameManager.collission_sprites                           
                                         ],this,
                                        'elevatorbox');


           		this.velocity=new CreateVector(0*xscale,3*yscale);
           		this.maxVelocity=new CreateVector(5*xscale,5*yscale);
           		this.imagex=ELEVATORIMAGE;
           		// this.hitboxOffset.y=-this.height*0.1;
           		this.lastTurnTime=gameManager.runningClock;
           		this.turnTime=2000;
           	}
           	update()
           	{
           	    this.move();
           		this.update_and_display_elevatorbox();
           		this.turn();
           	}
           	update_and_display_elevatorbox()
           	{           		
           	this.position.setVec(this.elevate_box.position.copy().add(this.hitboxOffset));
            if(b_collision(this.elevate_box,gameManager.player.hit_box))
                {
                let gap=this.elevate_box.position.y-gameManager.player.hit_box.position.y;
                if(this.velocity.y<0)
                    gameManager.player.hit_box.position.y=this.elevate_box.position.y-this.elevate_box.height/2-gameManager.player.hit_box.height/2- 3;
                else 
                    gameManager.player.hit_box.position.y=this.elevate_box.position.y+this.elevate_box.height/2+gameManager.player.hit_box.height/2+3;
                
                }           	
           	}
           	turn()
           	{
           		if(gameManager.runningClock-this.lastTurnTime > this.turnTime)
           		{
           			this.lastTurnTime=gameManager.runningClock;
           			this.velocity.y*=-1;
           		}
           	}
           	move()
           	{
           		this.elevate_box.position.x+=this.velocity.x;
           		this.elevate_box.position.y+=this.velocity.y;         		

           	}
   	    }

   class MovingPlatform extends GeneralSprite
        {
           constructor(x,y,wid,hei,turnTime,spriteGroups)
            {
                super(x,y,wid,hei,0,0,spriteGroups);
                this.sprite_type="MovingPlatform";
      
                this.moving_box=new HitBox(this.position.x,
                                        this.position.y,
                                        this.width,
                                        this.height,
                                         [ 
                                         // gameManager.elevatorboxes,
                                         // gameManager.visible_sprites,
                                         gameManager.collission_sprites                           
                                         ],this,
                                        'movingboxhitbox');


                this.velocity=new CreateVector(4*xscale,0*yscale);
                this.maxVelocity=new CreateVector(5*xscale,5*yscale);
                this.imagex=ELEVATORIMAGE;
                // this.hitboxOffset.y=-this.height*0.1;
                this.lastTurnTime=gameManager.runningClock;
                this.turnTime=turnTime;
                this.inContact=false;
            }
            update()
            {
                this.move();
                this.update_and_display_elevatorbox();
                this.turn();
                this.inContact=false;
            }
            update_and_display_elevatorbox()
            {                   
            this.position.setVec(this.moving_box.position.copy().add(this.hitboxOffset));

            if(!gameManager.player || gameManager.player.isActive) 
            {
                this.inContact=false;
                return; 
            }
            /*
            if(b_collision(this.moving_box,gameManager.player.hit_box))                
                this.inContact=true;
            else 
                this.inContact=false;*/              
                              
            }
            
            turn()
            {
                if(gameManager.runningClock-this.lastTurnTime > this.turnTime)
                {
                    this.lastTurnTime=gameManager.runningClock;
                    this.velocity.x*=-1;
                }
            }
            move()
            {
                this.moving_box.position.x+=this.velocity.x;
                this.moving_box.position.y+=this.velocity.y;   
                // if(!gameManager.player || gameManager.player.isActive) return; 
                if(this.inContact)
                    gameManager.player.hit_box.position.x+=this.velocity.x;          

            }
        }


        
   class Bullet extends GeneralSprite
        {
           constructor(x,y,wid,hei,parent,spriteGroups)
            {
                super(x,y,wid,hei,0,0,spriteGroups); 

                this.hit_box=new HitBox(this.position.x,this.position.y,
                	                    this.width*0.5,
                	                    this.height*0.5,
                                     [ //gameManager.collission_sprites,
                                      // gameManager.visible_sprites
                                     ],this,
                                     'bullethitbox');//checkforproblems
                this.imagex=THORNYBALL;
                this.rotAngle=0; 
                this.rotSpeed=0.25;
                this.parent=parent;
                this.speed=20*xscale;
                // this.velocity=new CreateVector(this.speed*this.parent.sx*xscale,0);
                this.velocity=new CreateVector(0,0);
                this.maxVelocity=new CreateVector(40*xscale,20*yscale);
                this.acceleration=new CreateVector(0,0); 
                this.lifeTime=3000;
                this.birthTime=gameManager.runningClock;

            } 
         applyForce(){
            this.acceleration.x=this.parent.sx*xscale*6;
         }
         display()
            {            
             if(!this.onScreen) return false;
             ctx.save();
             ctx.translate(this.position.x-gameManager.camera.position.x, 
                           this.position.y-gameManager.camera.position.y);
             ctx.rotate(d2r(this.rotAngle));
             // ctx.scale(this.sx,this.sy);             
             ctx.drawImage(this.imagex,-this.width/2,-this.height/2,this.width,this.height);             
             ctx.restore();
            }
         update()
            {
             this.applyForce();
             this.velocity.add(this.acceleration);
             this.acceleration.set(0,0);
             this.applyVelocity();
             this.applyVelocityRestrictions();             
             this.rotateself();
             this.update_and_display_hitbox();  
             this.checkLife();           
            }
        rotateself()
            {
             this.rotAngle+=this.rotSpeed;
             if(this.rotAngle > 360) this.rotAngle=0;
            }
         checkLife()
            {
                if(gameManager.runningClock - this.birthTime > this.lifeTime)
                {
                    destroySelf(this.hit_box);
                    destroySelf(this); 
                }
            }
         applyVelocity()
            {                    
             this.hit_box.position.x+=this.velocity.x;          
             for(let k in gameManager.collission_sprites)
                { 
                 let x=gameManager.collission_sprites[k];
                 if(!x.onScreen) continue;
                 if(x==this.hit_box || x==this.parent.hit_box) continue;               
                 if(b_collision(this.hit_box,x)) 
                    {            
                     if(x.sprite_type=='huskhitbox') 
                        x.parent.takeDamage(5);
                    destroySelf(this.hit_box);
                    destroySelf(this);  
                    SpawnClouds(this.position,5); 
                                 
                    }
                }

             this.hit_box.position.y+=this.velocity.y;
             for(let k in gameManager.collission_sprites)
                {

                 let x=gameManager.collission_sprites[k];
                 if(!x.onScreen) continue;
                 if(x==this.hit_box || x==this.parent.hit_box) continue;              
                 if(b_collision(this.hit_box,x)) 
                    {            
                     if(x.sprite_type=='huskhitbox' || x.sprite_type=='lancehitbox') 
                        x.parent.takeDamage(5);
                     else
                     document.querySelector('#retroJump').play();
                    destroySelf(this.hit_box);
                    destroySelf(this);  
                    SpawnClouds(this.position,5); 
                                   
                    }
                }
            }
         applyVelocityRestrictions()
            {
             let xdir=this.velocity.x/Math.abs(this.velocity.x);
             let ydir=this.velocity.y/Math.abs(this.velocity.y);
             if(Math.abs(this.velocity.y) > this.maxVelocity.y)
                this.velocity.y=ydir*this.maxVelocity.y;
             if(Math.abs(this.velocity.x) > this.maxVelocity.x)
                this.velocity.x=xdir*this.maxVelocity.x;
            }

         update_and_display_hitbox()
            {           
            this.position.setVec(this.hit_box.position);
            }


        }
    class flame extends GeneralSprite
        {
            constructor(x,y,width,height,spriteGroups)
                {
                    super(x,y,width,height,0,0,spriteGroups);
                    this.enlargedHeight=4*height;
                    this.sprite_type='flame';

                    this.animations={
                                     'small':{'imgsheet':LoadImagex('sprites/misc','fire1_64.png'),
                                               'width':640,
                                               'height':384,                        
                                               'rows':6,
                                               'cols':10,
                                               'maxFrames':60,
                                               'width_extend':1,
                                               'height_extend':1,
                                               'anim_speed':0.15
                                              },
                                    };  
                    this.animation='small';
                    this.animInQueue=null;
                    this.animationFrame=0;
                    this.startx=0;
                    this.starty=0;
                    this.imgWidth=0;
                    this.imgHeight=0;
                    this.startTime=gameManager.runningClock;
                    this.flareTime=500;
                    this.lifeTime=2000;
                    this.heightGrow=false;
                    this.sx=1;
                    this.sy=1;
                    this.flame_hitbox_spawned=false;
                }
        update()
            {
                if(this.heightGrow)
                this.growFlame();

                if(gameManager.runningClock - this.startTime >this.lifeTime){
                    destroySelf(this);
                }else if(gameManager.runningClock - this.startTime >this.flareTime){
                    this.heightGrow=true;  
                }
            }
        growFlame(){
            if(this.height<this.enlargedHeight) 
                {
                    this.height+=40;
                    this.position.y-=20;
                }
                else if(!this.flame_hitbox_spawned){
                    this.flame_hitbox_spawned=true;
                    new DamageHitBox(this.position.x,this.position.y, //x,y
                                  20*xscale,this.height*2, //width,height
                                  [gameManager.active_sprites,
                                   gameManager.hitbox_sprites,
                                   // gameManager.visible_sprites
                                  ],
                                 'enemy_hitbox',this,//hitboxName,parent
                                 0*xscale,0*yscale,//xoffset,yoffset
                                 10,0,//damage,damagehitback
                                 1000//life
                                 ); 
                    // destroySelf(this);
                }
        }
        display()
            {
                // super.display();
                // return;
             if(!this.onScreen) return false;

             this.runAnimation();
             // console.log('here at 2976');
             ctx.save();
             ctx.translate(this.position.x-gameManager.camera.position.x, 
                           this.position.y-gameManager.camera.position.y);
             ctx.rotate(d2r(this.angle));
             // ctx.scale(this.sx,this.sy);
             // if(this.flickerControl())
             // ctx.drawImage(this.imagex,-this.width/2,-this.height/2,this.width,this.height);
             ctx.drawImage(this.animations[this.animation]['imgsheet'],
                            this.startx,this.starty,this.imgWidth,this.imgHeight,
                           -this.width/2,
                           -this.height/2,
                           this.width*this.animations[this.animation]['width_extend'],
                           this.height*this.animations[this.animation]['height_extend']
                          );
             
             ctx.restore();
             // w2screen(this.animation,this.position.x-gameManager.camera.position.x,this.position.y-50*yscale-gameManager.camera.position.y);
            }
        runAnimation()
            {
              this.animationFrame+=this.animations[this.animation]['anim_speed'];
              if(this.animationFrame >= this.animations[this.animation]['maxFrames'])
                {
                this.animationFrame=0;
                if(this.animInQueue) 
                    {
                    this.animation=this.animInQueue;
                    //console.log('back to '+this.animation);
                    this.animInQueue=null;
                    }
                }
              let rowIndex=parseInt(parseInt(this.animationFrame)/this.animations[this.animation]['cols']);
              let colIndex=parseInt(this.animationFrame)%this.animations[this.animation]['cols'];
              this.startx=colIndex * this.animations[this.animation]['width']/this.animations[this.animation]['cols'];
              this.starty=rowIndex * this.animations[this.animation]['height']/this.animations[this.animation]['rows'];
              this.imgWidth = this.animations[this.animation]['width']/this.animations[this.animation]['cols'];
              this.imgHeight = this.animations[this.animation]['height']/this.animations[this.animation]['rows'];
            }
        switchAnimation(animx)
            {
             if(this.animation != animx)
                {                 
                this.animationFrame=0;
                this.animation=animx;
                }
            }
        }
        
   class WallGripper extends GeneralSprite
        {

         constructor(x,y,width,height,spriteGroups)
            {
             
             super(x,y,width,height,0,0,spriteGroups);             
             this.sprite_type='WallGripper';
             this.imagex= GRAYBOX;
            } 
        } 

	class Flower extends GeneralSprite
		{
		constructor(x,y,wid,hei,hitboxoffsetx,hitboxoffsety,exp,spriteId,spriteGroups)
			{
			  super(x,y,wid,hei,hitboxoffsetx,hitboxoffsety,spriteGroups);
			  this.sprite_type='flower';
			  this.imagex=FLOWERIMAGE;
			  this.exp=exp;
			  this.spriteId=spriteId;
              this.hit_box=new HitBox(this.position.x+this.hitboxOffset.x,
                                      this.position.y+this.hitboxOffset.y,
                                      this.width*0.6,
                                      this.height*0.9,
                                        [ gameManager.collission_sprites,
                                          // gameManager.visible_sprites
                                        ],this,
                                     'loothitbox');
			}	
		giveExp(objx)
			{
            SpawnClouds(this.position,10);
			objx.giveExp(this.exp);
            destroySelf(this.hit_box);
			destroySelf(this);
			gameManager.listOfDestroyedSprites.push(this.spriteId);
			coinSound.play();			
			}	
		}

	class Thorn extends GeneralSprite
		{
		  constructor(x,y,wid,hei,hitboxoffsetx,hitboxoffsety,spriteGroups)
		  	{
		  	 super(x,y,wid,hei,hitboxoffsetx,hitboxoffsety,spriteGroups);
		  	 this.sprite_type='thorn';
  		 	 this.hit_box=new HitBox(this.position.x,this.position.y,this.width*0.9,this.height*0.5,
                         [ gameManager.kill_plants,
                          // gameManager.visible_sprites
                         ],this,
                         'thornhitbox');
  		 	 this.imagex= THORNIMAGE;
		  	}
		  update()
		  	{
		  	 update_and_display_hitbox();
		  	}
		  update_and_display_hitbox()
		 	{	 		
	 		this.position.setVec(this.hit_box.position.copy().add(this.hitboxOffset));
		 	}
		}
	class SawWheel extends GeneralSprite
		{
			constructor(x,y,wid,hei,hitboxoffsetx,hitboxoffsety,spriteGroups,
				        moveTime,moveTimeInit,speed,isHoriWheel
				       )
			  	{
			  	 super(x,y,wid,hei,hitboxoffsetx,hitboxoffsety,spriteGroups);
			  	 this.sprite_type='sawwheel';
	  		 	 this.hit_box=new HitBox(this.position.x,this.position.y,this.width*0.9,this.height*0.5,
	                         [ 
	                         gameManager.kill_plants,
	                          // gameManager.visible_sprites
	                         ],this,
	                         'thornhitbox');
	  		 	 this.sprite_type='sawwheel';
	  		 	 this.imagex= SAWWHEEL1;
	  		 	 this.imagesx=[SAWWHEEL1,SAWWHEEL2,SAWWHEEL3];
	  		 	 this.animationFrame=0;
	  		 	 this.moveTime=moveTime;
	  		 	 this.moveTimer=0;	  		 	 
	  		 	 this.horiWheel=isHoriWheel;
	  		 	 this.speed=speed;
	  		 	 if(this.horiWheel) this.velocity=new CreateVector(this.speed*xscale,0);
	  		 	 else this.velocity=new CreateVector(0,this.speed*yscale);
	  		 	 this.initMoveDone=false;
	  		 	 this.moveTimeInit=moveTimeInit;
                 console.log('started sawwheel music');
                 this.myMusicStarted=false;
                 
			  	}
			  animateMe()
			  	{
			  	 this.animationFrame+=0.2;
			  	 if(this.animationFrame > this.imagesx.length) this.animationFrame=0;
			  	 this.imagex= this.imagesx[parseInt(this.animationFrame)];
			  	}
              startMusicIfNotStarted()
                {
                  if(!this.myMusicStarted && okToStartMusic){
                    this.myMusicStarted=true;
                    sawWheelBG.play();
                  }
                }
			  update()
			  	{
			  	 // return false;
                 this.startMusicIfNotStarted();
			  	 this.move();
			  	 this.animateMe();
			  	 this.update_and_display_hitbox();
			  	}
			  
			  initMove()
			  	{
			  	 this.moveTimer+=deltaTime;
			  	 if(this.moveTimer > this.moveTimeInit)
			  	 	{
			  	 	 this.moveTimer=0;
			  	 	 this.velocity.mult(-1);
			  	 	 this.initMoveDone=true;			  	 	 
			  	 	}
			  	 this.hit_box.position.add(this.velocity);
			  	}
			  move()
			  	{
			  	 // console.log('moving');
			  	 if(!this.initMoveDone)
			  	 	{
			  	 	  this.initMove();
			  	 	  return;
			  	 	}
			  	 this.moveTimer+=deltaTime;
			  	 if(this.moveTimer > this.moveTime)
			  	 	{
			  	 	 this.moveTimer=0;
			  	 	 this.velocity.mult(-1);			  	 	 
			  	 	}
			  	 this.hit_box.position.add(this.velocity);
			  	}
			  update_and_display_hitbox()
			 	{	 		
		 		this.position.setVec(this.hit_box.position.copy().add(this.hitboxOffset));
			 	}	
		}
	class GrassShrub extends GeneralSprite
		{
		  constructor(x,y,wid,hei,hitboxoffsetx,hitboxoffsety,spriteGroups)
		  	{
		  	 super(x,y,wid,hei,hitboxoffsetx,hitboxoffsety,spriteGroups);
		  	 this.sprite_type='shrub';  		 	 
  		 	 this.imagex= FORESTIMAGE;
		  	}		 
		}
	class ThornyBall
		{
		 constructor(x,y,wid,hei,parentx,offsetx,offsety,spriteGroups,horiVel=14,lifeTime=3000)
			{			 
			 this.sprite_type='thornyball';
			 this.position= new CreateVector(x,y);
			 if(parentx)
			 this.offsetpos=new CreateVector(parentx.sx*offsetx,parentx.sy*offsety);
			 else
			 	this.offsetpos=new CreateVector(0,0);
			 this.position.add(this.offsetpos);
			 this.parentx=parentx;
			 this.width = wid * xscale;
			 this.height = hei * yscale;
			 this.onScreen=true;
			 this.isActive=true;
			 this.angle=0;
			 this.rotAngle=0;
			 this.rotSpeed=5;
			 this.imagex=THORNYBALL;
			 this.collidedObj='none';
			 if(!parentx)	
			 	this.velocity=new CreateVector(0,0);
			 else		 
			 	this.velocity=new CreateVector(parentx.sx*horiVel*xscale,0);
             
			 this.gravityScale=2*yscale;
			 this.maxVelocity=new CreateVector(horiVel*xscale,12*yscale);
			 this.spriteGroups=spriteGroups;
			 this.acceleration=new CreateVector(0,0);
			 for(let x of this.spriteGroups)
			 	x.push(this);
 		 	 this.hit_box=new HitBox(this.position.x,this.position.y,this.width*0.5,this.height*0.5,
		 	                         [ //gameManager.collission_sprites,
		 	                          // gameManager.visible_sprites
		 	                         ],this,
		 	                         'tballhitbox');
            this.birthTime=gameManager.runningClock;
            this.lifeTime=lifeTime;
			}
		 mindHealth()
		 	{
		 	 if(gameManager.runningClock - this.birthTime > this.lifeTime)
		 	 	 {
		 	 	 SpawnClouds(this.position);
		 	  	 destroySelf(this.hit_box);
		 	  	 destroySelf(this);
		 	 	 }
		 	}
		 update_and_display_hitbox()
		 	{	 		
	 		this.position.setVec(this.hit_box.position);
		 	}
		 display()
		 	{		 	 
		 	 if(!this.onScreen) return false;
		 	 ctx.save();
		 	 ctx.translate(this.position.x-gameManager.camera.position.x, 
		 	 	 		   this.position.y-gameManager.camera.position.y);
		 	 ctx.rotate(d2r(this.rotAngle));
		 	 // ctx.scale(this.sx,this.sy);
		 	 // if(this.flickerControl())
		 	 ctx.drawImage(this.imagex,-this.width/2,-this.height/2,this.width,this.height);		 	 
		 	 ctx.restore();
		 	}
		 rotateself()
		 	{
		 	 this.rotAngle+=this.rotSpeed;
		 	 if(this.rotAngle > 360) this.rotAngle=0;
		 	}

		 update()
		 	{
		 	 this.applyGravity();
		 	 this.velocity.add(this.acceleration);
		 	 this.acceleration.set(0,0);
		 	 this.applyVelocity();
		 	 this.applyVelocityRestrictions();
		 	 this.checkCollisions();
		 	 this.rotateself();
		 	 this.update_and_display_hitbox();
		 	 this.mindHealth();
		 	}
		 applyGravity()
		 	{
		 	 this.acceleration.y+=this.gravityScale;
		 	}
		 applyVelocity()
		 	{		 	 	 	 
		 	 this.hit_box.position.x+=this.velocity.x;		 	
		 	 for(let k in gameManager.collission_sprites)
		 	 	{ 
		 	 	 let x=gameManager.collission_sprites[k];
		 	 	 if(!x.onScreen) continue;
		 	 	 if(x==this.hit_box) continue;		 	 	 
		 	 	 if(b_collision(this.hit_box,x)) 
		 	 	 	{	 		 
		 	 	 	 this.collidedObj=x.sprite_type; 	 
		 	 	 	 if(this.velocity.x > 0)
		 	 	 	 	{		 	 	 	 
		 	 	 	 	this.hit_box.position.x=x.position.x - x.width/2-this.hit_box.width/2-2;	

		 	 	 	  	}
		 	 	 	 else 
		 	 	 	 	{
		 	 	 	    this.hit_box.position.x=x.position.x + x.width/2 + this.hit_box.width/2+2;		 	 	 	    
		 	 	 		}
		 	 	 	}
		 	 	}

		 	 this.hit_box.position.y+=this.velocity.y;
		 	 for(let x of gameManager.collission_sprites)
		 	 	{

		 	 	 if(!x.onScreen) continue;
		 	 	 if(x==this) continue;		 	 	 
		 	 	 if(b_collision(this.hit_box,x)) 
		 	 	 	{
		 	 	 	this.collidedObj=x.sprite_type;		 	 	    
		 	 	 	if(this.velocity.y > 0)
		 	 	 		{
		 	 	 		this.hit_box.position.y=x.position.y-x.height/2-this.hit_box.height/2-2;	
		 	 	 		this.acceleration.add(new CreateVector(0,2*-this.velocity.y));	 	 	 		
		 	 	 		}
		 	 	 	else
		 	 	 		{
		 	 	 		this.hit_box.position.y=x.position.y+x.height/2+this.hit_box.height/2+2;		
		 	 	 		this.acceleration.add(new CreateVector(0,2*this.velocity.y)); 	 	 		
		 	 	 		}
		 	 	 	}
		 	 	}
		 	}
		 applyVelocityRestrictions()
		 	{
		 	 let xdir=this.velocity.x/Math.abs(this.velocity.x);
		 	 let ydir=this.velocity.y/Math.abs(this.velocity.y);
		 	 if(Math.abs(this.velocity.y) > this.maxVelocity.y)
		 	 	this.velocity.y=ydir*this.maxVelocity.y;
		 	 if(Math.abs(this.velocity.x) > this.maxVelocity.x)
		 	 	this.velocity.x=xdir*this.maxVelocity.x;
		 	}

		 checkCollisions()
		 	{
		 	  for(let sp of gameManager.collission_sprites) 
		 	  	{		 	  	 
		 	  	 if(sp.sprite_type=='playerhitbox' && b_collision(this,sp))
		 	  	 	{
		 	  	 	  SpawnClouds(this.position);
		 	  	 	  destroySelf(this.hit_box);
		 	  	 	  destroySelf(this);
		 	  	 	  if(this.parentx)
		 	  	 	  	gameManager.player.takeDamage(10,this.parentx.sx);
		 	  	 	  else
		 	  	 	  	gameManager.player.takeDamage(10,0);
		 	  	 	}
		 	  	}
		 	}

		}
	//Spear starts
	class Spear 
		{
		 constructor(x,y,wid,hei,dirx,spriteGroups,parentx)
		 	{	
		 	 this.sprite_type='spear';
		 	 this.parentx=parentx;
		 	 this.position=new CreateVector(x,y);
		     this.width = wid * xscale;
		     this.height = hei * yscale;
		     let folderPath='sprites/lanceSentry/';
		     this.onScreen= true;
			 this.isActive=true;
			 this.angle=dirx.heading();
			 this.sx=1;
			 this.sy=1;
			 this.force=dirx.mult(5);
			 this.startx=0;
			 this.starty=0;
			 this.imgWidth=0;
			 this.imgHeight=0;
			 this.acceleration=new CreateVector(0,0);
			 this.velocity=new CreateVector(0,0);
			 this.maxVelocity=10*xscale;	
			 //animations start
			 this.animations={
					 	'static':{'imgsheet':LoadImagex(folderPath,'Javelin.png'),
					  		    'width':474,
					  		    'height':22,			  		    
					  		    'rows':1,
					  		    'cols':1,
					  		    'maxFrames':1,
					  		    'width_extend':1,
					  		    'height_extend':1,
					  		    'anim_speed':0.01
					  		    },
					  	'snap':{'imgsheet':LoadImagex(folderPath,'JavelinSnap.png'),
					  		    'width':1187,
					  		    'height':126,			  		    
					  		    'rows':1,
					  		    'cols':3,
					  		    'maxFrames':3,
					  		    'width_extend':1,
					  		    'height_extend':1,
					  		    'anim_speed':0.08
				  				 }
			  				};
			 //animations end
			 this.animation='static';
			 this.animInQueue=null;
			 this.animationFrame=0;			 
			 this.sprite_type='spear';
			 this.state='static';
			 this.spriteGroups=spriteGroups;
			 for(let grp of spriteGroups)
			 	grp.push(this);
			 this.hit_box=new HitBox(x,y,30*xscale,30*yscale,[],this,'spearhitbox');
			 // this.hit_box.angle=this.angle;
			 this.hit_box_offset=new CreateVector(50*xscale,0);
			 this.snapping=false;
		 	}

		update_and_display_hitbox()
		 	{	 		
		 	let hit_box_offset=this.hit_box_offset.copy().rotateByAngle(this.angle);
	 		this.position.setVec(this.hit_box.position.copy().add(hit_box_offset.mult(-1)));
		 	}
		runAnimation()
			{
			  this.animationFrame+=this.animations[this.animation]['anim_speed'];
			  if(this.animationFrame >= this.animations[this.animation]['maxFrames'])
			  	{
		  		this.animationFrame=0;
		  		if(this.animInQueue) 
		  			{
		  			this.animation=this.animInQueue;
		  			//console.log('back to '+this.animation);
		  			this.animInQueue=null;
		  			}
			  	}
			  let rowIndex=parseInt(parseInt(this.animationFrame)/this.animations[this.animation]['cols']);
			  let colIndex=parseInt(this.animationFrame)%this.animations[this.animation]['cols'];
			  this.startx=colIndex * this.animations[this.animation]['width']/this.animations[this.animation]['cols'];
			  this.starty=rowIndex * this.animations[this.animation]['height']/this.animations[this.animation]['rows'];
			  this.imgWidth = this.animations[this.animation]['width']/this.animations[this.animation]['cols'];
			  this.imgHeight = this.animations[this.animation]['height']/this.animations[this.animation]['rows'];
			}
		 checkForSnap()
		 	{
		 	 if(!this.snapping) return false;
		 	 this.force.set(0,0);
		 	 this.velocity.set(0,0);		 	 
		 	 // return false;
		 	 if(parseInt(this.animationFrame)==1)
		 	 	{	
		 	 	 // console.log('spear destroyed');
		 	 	 destroySelf(this);
		 	 	 destroySelf(this.hit_box);
		 	 	 SpawnClouds(this.position);		 	 	 
		 	 	}
		 	}
		 move()
		 	{		 	
		 	 this.acceleration.add(this.force);	 
		 	 this.velocity.add(this.acceleration);
		 	 this.acceleration.set(0,0);
		 	 this.applyVelocity();
		 	 this.applyVelocityRestrictions();
		 	 this.update_and_display_hitbox();
		 	}
		switchAnimation(animx)
			{
			 if(this.animation != animx)
			 	{
			 	this.animationFrame=0;
			 	this.animation=animx;			 	
			 	}
			}
		 applyVelocity()
		 	{		 	  
		 	 this.hit_box.position.x+=this.velocity.x;		 	
		 	 for(let x of gameManager.collission_sprites)
		 	 	{
		 	 	 if(!x.onScreen) continue;
		 	 	 if(x==this.hit_box) continue;
		 	 	 if(x==this.parentx.hit_box) continue;
		 	 	 
		 	 	 if(b_collision(this.hit_box,x)) 
		 	 	 	{
		 	 	 	 if(!this.snapping)
		 	 	 	 	{
		 	 	 	 	this.switchAnimation('snap');
		 	 	 	 	
		 	 	 	 	SpawnClouds(this.position);
		 	 	 	    this.snapping=true;
		 	 	 	    if(x.sprite_type=='playerhitbox')
		 	 	 	    	{
		 	 	 	    	 gameManager.player.takeDamage(10);
		 	 	 	    	}
		 	 	 		}		 	 	 	

		 	 	 	 if(this.velocity.x > 0)
		 	 	 	 	{
		 	 	 	 	this.hit_box.position.x=x.position.x-x.width/2-this.hit_box.width/2-2;
		 	 	 	 	}
		 	 	 	 else 
		 	 	 	    {
		 	 	 	 	this.hit_box.position.x=x.position.x+x.width/2+this.hit_box.width/2+2;
		 	 	 	    }
		 	 	 	 
		 	 	 	}		 	 	 
		 	 	}

		 	 this.hit_box.position.y+=this.velocity.y;
		 	 for(let x of gameManager.collission_sprites)
		 	 	{
		 	 	 if(!x.onScreen) continue;
		 	 	 if(x==this.hit_box) continue;
		 	 	 if(x==this.parentx.hit_box) continue;

		 	 	 if(b_collision(this.hit_box,x)) 
		 	 	 	{
		 	 	 	if(!this.snapping)
		 	 	 		{
		 	 	 		this.switchAnimation('snap');
		 	 	 		SpawnClouds(this.position);		 	 	 		
		 	 	 		this.snapping=true;
		 	 	 		if(x.sprite_type=='playerhitbox')
		 	 	 	    	{
		 	 	 	    	 gameManager.player.takeDamage(10);
		 	 	 	    	}
		 	 	 		}		 	 	 	
		 	 	 	if(this.velocity.y > 0)
		 	 	 		{
		 	 	 		this.hit_box.position.y=x.position.y-x.height/2-this.hit_box.height/2-2;
		 	 	 		}
		 	 	 	else
		 	 	 		{
		 	 	 		this.hit_box.position.y=x.position.y+x.height/2+this.hit_box.height/2+2;	
		 	 	 		}
		 	 	 	
		 	 	 	}
		 	 	}
		 	}
		 applyVelocityRestrictions()
		 	{
		 	 if(this.velocity.mag()>this.maxVelocity)
		 	 	{
		 	 	 this.velocity.normalize().mult(this.maxVelocity);
		 	 	}
		 	}
		update()
		  	{
		 	  this.runAnimation();		 	  
		 	  this.move();	 	
		 	  this.checkForSnap();  
		  	}
		display()
		  	{
		 	 if(!this.onScreen) return false;		 	
		 	 ctx.save();
		 	 ctx.translate(this.position.x-gameManager.camera.position.x, 
		 	 	 		   this.position.y-gameManager.camera.position.y);
		 	 ctx.rotate(d2r(this.angle));
		 	 ctx.scale(this.sx,this.sy);		 	 			 	 
		 	 ctx.drawImage(this.animations[this.animation]['imgsheet'],
		 	 				this.startx,this.starty,this.imgWidth,this.imgHeight,
		 	 			   -this.width/2,
		 	 			   -this.height/2,
		 	 			   this.width*this.animations[this.animation]['width_extend'],
		 	 			   this.height*this.animations[this.animation]['height_extend']
		 	 			  );
		 	 // context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height);
		 	 ctx.restore();
		  	}

		 	
		}
	//Spear ends
    //Traitor starts
	class TraitorLord
		{
			constructor(x,y,wid,hei,spriteGroups,spriteId='traitor0')
			{
				this.position=new CreateVector(x,y);
				this.spriteGroups=spriteGroups;
                this.traitorMusicStarted=false;
				this.playerVisible=false;
				if(gameManager.player && gameManager.player.isActive)
					this.tgt=gameManager.player;
				this.width=wid;
				this.height=hei;
                this.expVal=1000;
				this.imgWidth=0;
				this.imgHeight=0;
				this.animInQueue=null;
		 		this.startx=0;
		 		this.starty=0;
				this.sprite_type="TraitorLord";
				this.spriteId=spriteId;
				this.isBoss=this.spriteId.split("_")[0]=="boss";
				this.isActive=!this.isBoss;
				this.onScreen=!this.isBoss;
				this.acceleration=new CreateVector(0,0);
			 	this.velocity=new CreateVector(0,0);
                this.traitor_normalVelocityx=20*xscale;
                this.traitor_plungeVelocityx=50*xscale;
			 	this.maxVelocity=new CreateVector(20*xscale,20*yscale);

			 	this.gravityScale=2*yscale;
			 	this.state='idle';
			 	this.sx=1;
    		 	this.sy=1;
    		 	this.angle=0;
    		 	this.animation='idle';
    		 	this.animationFrame=0;
    		 	this.invincibleState=false;
 	  			this.invin_count=0;
 	 			this.max_invin_time=500;
 	 			this.flickerCount=0;
	 			this.maxFlickerTime=100;
	 			this.traitorAttackInitiated=false;
	 			this.attackStartTime=0;
	 			this.traitorStrikeDist=100*xscale;
			 	for(let grp of spriteGroups)
			 		grp.push(this);	
			 	this.hit_box=new HitBox(x,y,this.width*0.4,this.height*0.8,[
                                                        gameManager.collission_sprites,
                                                        // gameManager.visible_sprites
                                                        // gameManager.active_sprites
                                                        ],this,'traitorlordhitbox'); //checkforproblems
			 	this.image_offset=new CreateVector(-30*xscale,-15*yscale);
			 	this.health=100;
		 		this.maxHealth=100;
		 		this.uiBarTimer=0;
		 		this.uiBarMaxTime=3000;
		 		this.healthBarOffset=new CreateVector(-30*xscale,-150*yscale);
		 		this.traitorHealthBar= new UIBar(0,0,100,15,this.health,this.maxHealth,'#222222','#FF0000',[gameManager.visible_sprites],false,'traitorhealth');
		 		this.traitorHealthBar.onScreen=false;
		 		this.lastAttackTime=0;
                this.rareAttackTime=gameManager.runningClock+4000;
                this.rareAttackTimeGap=4000;
		 		this.maxAttackGap=1000;
		 		this.attacks=['traitorstrike','traitorHighThrow','traitor_teleport'];
                this.rareAttacks=['shockwave'];
                // this.attacks=['traitor_teleport'];
		 		this.enemyClosed=false;
		 		this.traitorAttackPrepTime=500;
                this.traitorAttackCloseTime=4*this.traitorAttackPrepTime;
		 		this.initPrepOver=false;
                this.animRepeater=0;

                this.traitor_moveBackStartedTime=0;
                this.traitor_moveBackDirection=new CreateVector(-1,0);	 		
                this.downCheckRaycast=130*yscale;

			 	//setting up animations
			 	let folderPath='sprites/TraitorLord';
			 	this.animations={
						 	'idle':{'imgsheet':LoadImagex(folderPath,'idle.png'),
						  		    'width':859,
						  		    'height':322,			  		    
						  		    'rows':1,
						  		    'cols':3,
						  		    'maxFrames':3,
						  		    'width_extend':1,
						  		    'height_extend':1,
						  		    'anim_speed':0.05
						  		     },
				  'attackanticipate':{'imgsheet':LoadImagex(folderPath,'attackanticipate.png'),
						  		    'width':2424,
						  		    'height':291,			  		    
						  		    'rows':1,
						  		    'cols':6,
						  		    'maxFrames':6,
						  		    'width_extend':1,
						  		    'height_extend':1,
						  		    'anim_speed':0.5
						  		     },
				 'attackpart1':{'imgsheet':LoadImagex(folderPath,'attackpart1.png'),
						  		    'width':988,
						  		    'height':358,			  		    
						  		    'rows':1,
						  		    'cols':2,
						  		    'maxFrames':2,
						  		    'width_extend':1,
						  		    'height_extend':1,
						  		    'anim_speed':0.1
						  		     },
				 'attackpart2':{'imgsheet':LoadImagex(folderPath,'attackpart2.png'),
						  		    'width':414,
						  		    'height':298,			  		    
						  		    'rows':1,
						  		    'cols':1,
						  		    'maxFrames':1,
						  		    'width_extend':1,
						  		    'height_extend':1,
						  		    'anim_speed':0.1
						  		     },
				 'attackrecover':{'imgsheet':LoadImagex(folderPath,'attackrecover.png'),
						  		    'width':1545,
						  		    'height':284,			  		    
						  		    'rows':1,
						  		    'cols':4,
						  		    'maxFrames':4,
						  		    'width_extend':1,
						  		    'height_extend':1,
						  		    'anim_speed':0.1
						  		     },
				'jump':{'imgsheet':LoadImagex(folderPath,'jump.png'),
						  		    'width':1464,
						  		    'height':426,			  		    
						  		    'rows':1,
						  		    'cols':4,
						  		    'maxFrames':4,
						  		    'width_extend':1,
						  		    'height_extend':1,
						  		    'anim_speed':0.15
						  		     },
				'jumpanticipate':{'imgsheet':LoadImagex(folderPath,'jumpanticipate.png'),
						  		    'width':2016,
						  		    'height':348,			  		    
						  		    'rows':1,
						  		    'cols':5,
						  		    'maxFrames':5,
						  		    'width_extend':1,
						  		    'height_extend':1,
						  		    'anim_speed':0.15
						  		     },
				'jumpslash':{'imgsheet':LoadImagex(folderPath,'jumpslash.png'),
						  		    'width':990,
						  		    'height':361,			  		    
						  		    'rows':1,
						  		    'cols':2,
						  		    'maxFrames':2,
						  		    'width_extend':1,
						  		    'height_extend':1,
						  		    'anim_speed':0.15
						  		     },
				'jumpslash_anticipate':{'imgsheet':LoadImagex(folderPath,'jumpslash_anticipate.png'),
						  		    'width':990,
						  		    'height':361,			  		    
						  		    'rows':1,
						  		    'cols':1,
						  		    'maxFrames':1,
						  		    'width_extend':1,
						  		    'height_extend':1,
						  		    'anim_speed':0.15
						  		     },
				'shockwave':{'imgsheet':LoadImagex(folderPath,'shockwave.png'),
						  		    'width':2913,
						  		    'height':438,			  		    
						  		    'rows':1,
						  		    'cols':8,
						  		    'maxFrames':8,
						  		    'width_extend':1,
						  		    'height_extend':1,
						  		    'anim_speed':0.05
						  		     },
				'shockwave_anticipate':{'imgsheet':LoadImagex(folderPath,'shockwave_anticipate.png'),
						  		    'width':2142,
						  		    'height':350,			  		    
						  		    'rows':1,
						  		    'cols':6,
						  		    'maxFrames':6,
						  		    'width_extend':1,
						  		    'height_extend':1,
						  		    'anim_speed':0.15
						  		     },
				'shockwave_recover':{'imgsheet':LoadImagex(folderPath,'shockwave_recover.png'),
						  		    'width':1026,
						  		    'height':275,			  		    
						  		    'rows':1,
						  		    'cols':3,
						  		    'maxFrames':3,
						  		    'width_extend':1,
						  		    'height_extend':1,
						  		    'anim_speed':0.15
						  		     },
				'walk':{'imgsheet':LoadImagex(folderPath,'walk.png'),
						  		    'width':2874,
						  		    'height':550,			  		    
						  		    'rows':1,
						  		    'cols':2,
						  		    'maxFrames':9,
						  		    'width_extend':1,
						  		    'height_extend':1,
						  		    'anim_speed':0.15
						  		     },						  	 
						  		 };
                this.traitor_flame_gap=190*xscale;
                this.throwPrepTime=1000;
                this.teleport_appear_distance=200*xscale;                
                this.agroStartTime=0;
                this.onAir=false;
			}
		 applyVelocity()
		 	{		 	
             // if(this.state=='traitorstrike') console.log(this.velocity.x); 	 	 
		 	 this.hit_box.position.x+=this.velocity.x;		 	
		 	 for(let x of gameManager.collission_sprites)
		 	 	{
		 	 	 if(!x.onScreen) continue;
		 	 	 if(x==this.hit_box) continue;
		 	 	 
		 	 	 if(b_collision(this.hit_box,x)) 
		 	 	 	{		 	 	 	
		 	 	 	 if(this.velocity.x > 0)
		 	 	 	 	this.hit_box.position.x=x.position.x-x.width/2-this.hit_box.width/2-2;
		 	 	 	 else 
		 	 	 	 	this.hit_box.position.x=x.position.x+x.width/2+this.hit_box.width/2+2;
		 	 	 	}
		 	 	 		 	 	
		 	 	}

		 	 this.hit_box.position.y+=this.velocity.y;
		 	 for(let x of gameManager.collission_sprites)
		 	 	{
		 	 	 if(!x.onScreen) continue;
		 	 	 if(x==this.hit_box) continue;
		 	 	 if(b_collision(this.hit_box,x)) 
		 	 	 	{
		 	 	 	
		 	 	 	if(this.velocity.y > 0)
		 	 	 		this.hit_box.position.y=x.position.y-x.height/2-this.hit_box.height/2-2;
		 	 	 	else
		 	 	 		this.hit_box.position.y=x.position.y+x.height/2+this.hit_box.height/2+2;	
		 	 	 	}
		 	 	}
		 	}
		applyVelocityRestrictions()
		 	{
		 	 let xdir=this.velocity.x/Math.abs(this.velocity.x);
		 	 let ydir=this.velocity.y/Math.abs(this.velocity.y);
		 	 if(Math.abs(this.velocity.y) > this.maxVelocity.y)
		 	 	this.velocity.y=ydir*this.maxVelocity.y;
		 	 if(Math.abs(this.velocity.x) > this.maxVelocity.x)
		 	 	this.velocity.x=xdir*this.maxVelocity.x;
		 	}
		applyGravity()
		 	{
		 	 this.acceleration.y+=this.gravityScale;
		 	}
		 move()
		 	{		 		 
		 	 this.velocity.add(this.acceleration);
		 	 // console.log(this.acceleration.show('acceleration'));
		 	 // console.log(`${this.velocity.x},${this.velocity.y}`);
		 	 this.acceleration.set(0,0);		 	 		 	
		 	 this.applyVelocity();
		 	 this.applyVelocityRestrictions();
		 	 this.update_and_display_hitbox(); 
		 	}
		 update_and_display_hitbox()
		 	{	 		
	 		this.position.setVec(this.hit_box.position.copy().add(this.image_offset));
		 	}
        removeBars()
            {
             for(let go of gameManager.active_sprites)
                {
                 if(go.spriteId && go.spriteId=="BossFightTriggGO")
                    go.bossHasDiedRemoveBars();
                }
            }
		 takeDamage(dmg,dir=0)
		 	{
		 	//this.acceleration.add(new CreateVector(dir,0));
		 	if(this.invincibleState) return false;	
		 	this.invincibleState=true;	
	 		this.health-=dmg;
	 		this.traitorHealthBar.updateValue(this.health);
	 		this.traitorHealthBar.onScreen=true;
	 		if(this.health<0)
	 			{
	 			if(this.tgt && this.tgt.isActive)
	 				this.tgt.giveExp(this.expVal);
	 			SpawnClouds(this.position);
                
                pauseBossMusic();
                pauseMusic();
                startMusic();                
               
                fogGateSound.play();
                this.removeBars();
	 			destroySelf(this);
	 			destroySelf(this.hit_box);
	 			destroySelf(this.traitorHealthBar);

	 			if(this.isBoss){
	 			gameManager.listOfDestroyedSprites.push(this.spriteId);
                //saving the game will cause this enemy to not appear
                }
	 			this.isActive=false;
	 			}	
		 	}

    	runAnimation()
    		{
			  this.animationFrame+=this.animations[this.animation]['anim_speed'];
			  if(this.animationFrame >= this.animations[this.animation]['maxFrames'])
			  	{
		  		this.animationFrame=0;
		  		if(this.animInQueue) 
		  			{
		  			this.animation=this.animInQueue;
		  			//console.log('back to '+this.animation);
		  			this.animInQueue=null;
		  			}
			  	}
			  let rowIndex=parseInt(parseInt(this.animationFrame)/this.animations[this.animation]['cols']);
			  let colIndex=parseInt(this.animationFrame)%this.animations[this.animation]['cols'];
			  this.startx=colIndex * this.animations[this.animation]['width']/this.animations[this.animation]['cols'];
			  this.starty=rowIndex * this.animations[this.animation]['height']/this.animations[this.animation]['rows'];
			  this.imgWidth = this.animations[this.animation]['width']/this.animations[this.animation]['cols'];
			  this.imgHeight = this.animations[this.animation]['height']/this.animations[this.animation]['rows'];
			}
		switchAnimation(animx)
			{
			 if(this.animation != animx)
			 	{
			 	this.animationFrame=0;
			 	this.animation=animx;			 	
			 	}
			}
		 stateMachine()
		 	{
		 	 switch(this.state)
		 	 	{
		 	 	 case 'idle':
		 	 	 	this.idleTraitor();
		 	 	 	break;	
		 	 	 case 'agro':
		 	 	 	this.agroTraitor();
		 	 	 	break;
		 	 	 case 'traitorstrike':
		 	 	 	this.traitorStrike();
		 	 	 	break;	
                 case 'traitorMovingBack':
                    this.traitorMovingBack();
                    break; 	
                 case 'shockwave':
                    this.traitorShockwave();
                    break; 
                 case 'traitorHighThrow':
                    this.traitorHighThrow();
                    break;	 
                case 'traitor_teleport':
                    this.traitor_teleport();
                    break;
		 	 	 default:
		 	 	 	break;
		 	 	}
		 	}
		 idleTraitor(){
		 	this.switchAnimation('idle');
           
		 	this.turnTowardsPlayer();		 	
		 }

		 agroTraitor(){
            if(!gameManager.player || !gameManager.player.isActive) return false;
            if(this.agroStartTime==0){            	
            	document.querySelector('#mawlekscream').play();
            	this.agroStartTime=gameManager.runningClock;
            }
		 	this.turnTowardsPlayer();
            
            if(!this.traitorMusicStarted && gameManager.runningClock-this.agroStartTime>1000)
                    {
                     this.traitorMusicStarted= true;
                     // this.lookForBFightTrigger();
                     pauseMusic();
                     capraMusic.src="./sounds/Capra.mp3";
                     capraMusic.play();
                    }
            
            if(gameManager.runningClock - this.rareAttackTime > this.rareAttackTimeGap)
                {

                this.state=this.rareAttacks[Math.floor(Math.random()*this.rareAttacks.length)];            
                }
		 	else if(gameManager.runningClock - this.lastAttackTime > this.maxAttackGap)
		 		this.state=this.attacks[Math.floor(Math.random()*this.attacks.length)];
		 	
		 }
		 traitor_teleport(){
            if(!this.initPrepOver)
            {
                this.initPrepOver=true;
                this.turnTowardsPlayer();
                if(!this.playerVisible)
                {
                    console.log('player is not visible');
                    this.state='agro';
                    this.initPrepOver=false;
                    return;
                }
                //x,y,wid,hei,spriteGroups,parent,hitboxName="unknown hitbox")
                let testBox=new HitBox(gameManager.player.position.x + 
                                       this.sx * this.teleport_appear_distance,
                                       gameManager.player.position.y -  150*yscale,
                                       100*xscale,100*yscale,[],this,"testBox"
                                      );
                
                for(let x of gameManager.collission_sprites)
                {
                    if(b_collision(testBox,x))
                    {
                        testBox.position.x=gameManager.player.position.x - this.sx * 100*xscale;
                        break;
                    }
                }
                this.hit_box.position.setVec(testBox.position);
                SpawnClouds(this.hit_box.position,60,'black');
                this.state='agro';
                this.initPrepOver=false;
                this.rareAttackTime=gameManager.runningClock;
                this.lastAttackTime=gameManager.runningClock;
            }
         }
         
         traitorOnAir(){
         	if(this.checkIfOnGround() && this.onAir){
         		this.onAir=false;
         		gameManager.screenShakeTimer=gameManager.runningClock;
         	}else if(!this.checkIfOnGround() && !this.onAir){
         		this.onAir=true;
         	}
         }
		 traitorStrike(){
            if(!gameManager.player || !gameManager.player.isActive) return false;
		 	if(!this.traitorAttackInitiated){
		 		this.traitorAttackInitiated=true;
		 		this.attackStartTime=gameManager.runningClock;
                
		 	}
		 	if(!this.initPrepOver){
                if(Math.abs(gameManager.player.position.x - this.position.x) < 
                    this.traitorStrikeDist*1.5)
                    {
                        this.initPrepOver=true;
                        this.velocity.y=0;
                        return false;
                    }
		 		if(gameManager.runningClock - this.attackStartTime < this.traitorAttackPrepTime)
		 			this.acceleration.add(new CreateVector(0,-4*yscale));
		 		else{
		 			this.initPrepOver=true;
		 			this.velocity.y=0;
		 			}
		 		return false;
		 	}
		 	if(!this.enemyClosed){
		 		let plungeForce=new CreateVector(this.sx,0);
                if(this.checkIfOnGround() && this.maxVelocity.x!=this.traitor_plungeVelocityx) {
                    this.maxVelocity.x=this.traitor_plungeVelocityx;
                    // plungeForce.x*=50;
                    
                }
		 		this.acceleration.add(plungeForce);

		 		let timedOut=gameManager.runningClock- this.attackStartTime > this.traitorAttackCloseTime;
		 		if(timedOut ||
		 			Math.abs(gameManager.player.position.x - this.position.x) < this.traitorStrikeDist)
		 		{
		 			this.enemyClosed=true;
                    this.velocity.x=0;
                    this.maxVelocity.x=this.traitor_normalVelocityx;
                    this.acceleration.set(0,0);
		 			this.switchAnimation('attackanticipate');
		 		}
		 		return false;
		 	}
		 	
		 	if(this.animation=='attackanticipate' && this.animInQueue!='attackpart1'){
		 		this.animInQueue='attackpart1';
		 	}else if(this.animation=='attackpart1' && this.animInQueue!='attackpart2'){
		 		this.animInQueue='attackpart2';
		 	}else if(this.animation=='attackpart2' && this.animInQueue!='attackrecover'){
		 		this.animInQueue='attackrecover';
		 	}else if(this.animation=='attackrecover' && this.animInQueue!='idle'){
		 		this.animInQueue='idle';
		 	}		 	
		 	if(this.enemyClosed && this.animation=='idle'){
		 		this.enemyClosed=false;
		 		this.lastAttackTime=gameManager.runningClock;
		 		this.state='agro';
		 		this.traitorAttackInitiated=false;
		 		this.initPrepOver=false;
                this.traitorStruck=false;
                if(!(!gameManager.player || !gameManager.player.isActive))
                if(Math.abs(this.position.x - gameManager.player.position.x)<100*xscale)
                    this.sideWaysPush();
		 	}
            if(this.animation=='attackpart2' && !this.traitorStruck){
                this.traitorStruck=true;
                new DamageHitBox(this.position.x,this.position.y, //x,y
                                  150*xscale,100*yscale, //width,height
                                  [gameManager.active_sprites,
                                   gameManager.hitbox_sprites,
                                   // gameManager.visible_sprites
                                  ],
                                 'enemy_hitbox',this,//hitboxName,parent
                                 90*xscale,10*yscale,//xoffset,yoffset
                                 80,this.sx*30*xscale,//damage,damagehitback
                                 10//life
                                 ); 
            }
		 }
         sideWaysPush(){            
            this.state='traitorMovingBack';
         }
         
         traitorHighThrow(){
            if(!this.traitorAttackInitiated){
                this.traitorAttackInitiated=true;
                SpawnClouds(this.position,60,"black");
                this.attackStartTime=gameManager.runningClock;
            }
            if(!this.initPrepOver){
                if(gameManager.runningClock - this.attackStartTime < this.throwPrepTime)
                    return;
                this.initPrepOver=true;
                this.switchAnimation('attackanticipate');
            }
            if(this.animation=='attackanticipate' && this.animInQueue!='attackpart1'){
                this.animInQueue='attackpart1';
            }else if(this.animation=='attackpart1' && this.animInQueue!='attackpart2'){
                this.animInQueue='attackpart2';
            }else if(this.animation=='attackpart2' && this.animInQueue!='attackrecover'){
                this.animInQueue='attackrecover';
            }else if(this.animation=='attackrecover' && this.animInQueue!='idle'){
                this.animInQueue='idle';
            }
            if(this.animation=='attackpart2' && !this.traitorStruck){
                this.traitorStruck=true;
                new ThornyBall(this.position.x,
                           this.position.y,
                           50*xscale,
                           50*yscale,
                           this,200*xscale,0,
                           [gameManager.visible_sprites,gameManager.active_sprites],40,800
                                  ); 
            }
            if(this.animation=='idle' && this.initPrepOver){                
                this.lastAttackTime=gameManager.runningClock;
                this.state='agro';
                this.traitorAttackInitiated=false;
                this.initPrepOver=false;
                this.traitorStruck=false;
            }   
         }
         traitorShockwave(){
            if(!this.traitorAttackInitiated){
                this.traitorAttackInitiated=true;
                for(let i=1;i<=5;i++)
                {
                new flame(this.position.x-this.traitor_flame_gap*i*xscale,
                          this.position.y+50*yscale,100*xscale,200*yscale,
                          [gameManager.visible_sprites,gameManager.active_sprites]
                    );
                new flame(this.position.x+this.traitor_flame_gap*i*xscale,
                          this.position.y+50*yscale,100*xscale,200*yscale,
                          [gameManager.visible_sprites,gameManager.active_sprites]
                    );
                }
                this.switchAnimation('shockwave_anticipate');
                this.animInQueue='shockwave';
                return true;
            }
            if(this.animation=='shockwave' && this.animInQueue!='shockwave_recover')
                this.animInQueue='shockwave_recover';
            else if(this.animation=='shockwave_recover' && 
                    this.animRepeater<2 &&  
                    this.animInQueue!='shockwave'){
                this.animInQueue='shockwave';
                this.animRepeater+=1;
                }
            else if(this.animation=='shockwave_recover' && 
                    this.animRepeater==2 &&
                    this.animInQueue!='idle')
                this.animInQueue='idle';
            if(this.traitorAttackInitiated && this.animation=='idle'){
                this.state='agro';  
                this.lastAttackTime=gameManager.runningClock;
                this.rareAttackTime=gameManager.runningClock;
                this.traitorAttackInitiated=false; 
                this.animRepeater=0; 

            }

         }

        checkIfOnGround()
        {
        for(let x of gameManager.collission_sprites)
            {
             if(!x.onScreen || x==this.hit_box) continue;
             
             if(Raycast(this.position.copy(),new CreateVector(0,1),this.downCheckRaycast,x) )
                {
                return true;
                }
            }
        return false;
        }

         
         traitorMovingBack(){
            if(this.traitor_moveBackStartedTime==0){
                this.traitor_moveBackStartedTime=gameManager.runningClock;
                this.traitor_moveBackDirection.x=-this.sx;}
            if(gameManager.runningClock-this.traitor_moveBackStartedTime> 500){
                this.traitor_moveBackStartedTime=gameManager.runningClock;
                this.traitor_moveBackDirection.x*=-1;
            }
            if(Math.abs(this.position.x - gameManager.player.position.x)<100*xscale){
                this.acceleration.add(this.traitor_moveBackDirection);

            }else{
                this.velocity.x=0;
                this.acceleration.set(0,0);
                this.state='agro';
                this.traitor_moveBackStartedTime=0;

            }
         }
		 turnTowardsPlayer(){
		 	if (this.playerInFront())
		 		{
		 		this.sx=1;
		 		this.playerVisible=true;
		 		if(this.state!='agro') this.state='agro';
		 		}
		 	else if(this.playerInFront(-1))
		 		{
		 		this.sx=-1;
		 		this.playerVisible=true;
		 		if(this.state!='agro') this.state='agro';
		 		}
            else 
		 	this.playerVisible=false;
		 }
		 playerInFront(n=1){
		 	if(!gameManager.player || !gameManager.player.isActive) 
		 		return true;		 	
		 	let offsets=[-40*yscale,0,40*yscale];
		 	let dist=1000*xscale;
		 	for(let offset of offsets)
                {
                let yoffset=new CreateVector(0,offset);
                if(Raycast(this.position.copy().add(yoffset),new CreateVector(n,0),dist,gameManager.player))
                    return true;
                }
            return false;
		 }


		flickerControl()
			{
			  if(!this.invincibleState) return true;
			  this.flickerCount+=deltaTime;
			  if(this.flickerCount > this.maxFlickerTime)
			  	{
			  	 this.flickerCount=0;
			  	 return true;
			  	}
			  return false;
			}

		updateHealthBarPos()
			{
				if(this.traitorHealthBar.onScreen)
					{	
					this.uiBarTimer+=deltaTime;
					if(this.uiBarTimer > this.uiBarMaxTime)
					{
					 this.uiBarTimer=0;
					 this.traitorHealthBar.onScreen=false;
					}
					}
				this.traitorHealthBar.position.setVec(this.position.copy().add(this.healthBarOffset));
			}
		manageInvincibility()
			{
			if(!this.invincibleState) return false;
			this.invin_count+= deltaTime;
			if(this.invin_count > this.max_invin_time)
				{
				 this.invin_count=0;
				 this.invincibleState=false;
				} 
			}
    	display()
		 	{		 	 
		 	 if(!this.onScreen) return false;             
		 	 this.runAnimation();
		 	 ctx.save();
		 	 ctx.translate(this.position.x-gameManager.camera.position.x, 
		 	 	 		   this.position.y-gameManager.camera.position.y);
		 	 ctx.rotate(d2r(this.angle));
		 	 ctx.scale(this.sx,this.sy);
		 	 if(this.flickerControl())
		 	 ctx.drawImage(this.animations[this.animation]['imgsheet'],
		 	 				this.startx,this.starty,this.imgWidth,this.imgHeight,
		 	 			   -this.width/2,
		 	 			   -this.height/2,
		 	 			   this.width*this.animations[this.animation]['width_extend'],
		 	 			   this.height*this.animations[this.animation]['height_extend']
		 	 			  );
		 	 // context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height);
		 	 ctx.restore();
		 	 // w2screen(this.state,this.position.x-gameManager.camera.position.x,this.position.y-50*yscale-gameManager.camera.position.y);
		 	}
          usercontrol(){
             if(ipress && !this.clickDetector){
                this.traitor_flame_gap+=3;
                console.log((this.traitor_flame_gap/xscale).toFixed(2));
                this.clickDetector=true;
            }else if(!ipress) this.clickDetector=false;
            // this.checkIfOnGround();
          }
		  update()
		  	{
		  	  if(!this.isActive) return false;
              // this.usercontrol();
              this.traitorOnAir();
		 	  this.runAnimation();
		 	  this.stateMachine();
		 	  this.update_and_display_hitbox();
		 	  this.applyGravity();
		 	  this.move();
		 	  this.updateHealthBarPos();
		 	  this.manageInvincibility();
		 	  // w2screen(this.state,this.position.x-gameManager.camera.position.x,this.position.y-50*yscale-gameManager.camera.position.y);
		  	}
		}
        //traitor ends
	//Lance starts
	class Lance
		{
		 constructor(x,y,wid,hei,spriteGroups,spriteId='lance0')
		    {
		     this.position=new CreateVector(x,y);
             this.initPosition=new CreateVector(x,y);
		     this.width = wid;
		     this.height = hei;
		     this.spriteId=spriteId;
		     let folderPath='sprites/lanceSentry/';
		     this.onScreen= true;
			 this.isActive=true;
			 this.angle=0;
			 this.sx=1;
			 this.sy=1;
			 this.startx=0;
			 this.starty=0;
			 this.imgWidth=0;
			 this.imgHeight=0;
			 this.raycastLength=520*xscale;
			 this.playerOutDistance= 1500*xscale;
			 this.playerGap=500*xscale;
			 this.throwDone=false;

			 this.acceleration=new CreateVector(0,0);
			 this.velocity=new CreateVector(0,0);
			 this.normalvx=5*xscale;
			 this.rushvx=10*xscale;
			 this.showervx=3.5*xscale;
			 this.maxVelocity=new CreateVector(5*xscale,2*yscale);		
			 this.horiForce=new CreateVector(1*xscale,0);	 
			 this.gravityScale=2*yscale;
			 this.restClock=0;
			 this.restTime=2000;
			 this.lastAttackTime=0;
			 if(gameManager.player)
			 	this.tgt= gameManager.player;
			 //animations
			 this.animations={
			 	'anticipate':{'imgsheet':LoadImagex(folderPath,'Anticipate.png'),
			  		    'width':1527,
			  		    'height':310,			  		    
			  		    'rows':1,
			  		    'cols':4,
			  		    'maxFrames':4,
			  		    'width_extend':1,
			  		    'height_extend':1,
			  		    'anim_speed':0.1},
			 	'charge':{'imgsheet':LoadImagex(folderPath,'Charge.png'),
			  		    'width':1177,
			  		    'height':156,			  		    
			  		    'rows':1,
			  		    'cols':3,
			  		    'maxFrames':3,
			  		    'width_extend':1,
			  		    'height_extend':1,'anim_speed':0.2},
			 	'death':{'imgsheet':LoadImagex(folderPath,'Death.png'),
			  		    'width':749,
			  		    'height':127,			  		    
			  		    'rows':1,
			  		    'cols':4,
			  		    'maxFrames':4,
			  		    'width_extend':1,
			  		    'height_extend':1,'anim_speed':0.2},
			 	'idle':{'imgsheet':LoadImagex(folderPath,'Idle.png'),
			  		    'width':1653,
			  		    'height':435,			  		    
			  		    'rows':2,
			  		    'cols':5,
			  		    'maxFrames':7,
			  		    'width_extend':1,
			  		    'height_extend':1,'anim_speed':0.2},
			 	'recover':{'imgsheet':LoadImagex(folderPath,'Recover.png'),
			  		    'width':1119,
			  		    'height':254,			  		    
			  		    'rows':1,
			  		    'cols':3,
			  		    'maxFrames':3,
			  		    'width_extend':1,
			  		    'height_extend':1,'anim_speed':0.05},
			 	'throw':{'imgsheet':LoadImagex(folderPath,'Throw.png'),
			  		    'width':1916,
			  		    'height':757,			  		    
			  		    'rows':3,
			  		    'cols':5,
			  		    'maxFrames':13,
			  		    'width_extend':1,
			  		    'height_extend':1,'anim_speed':0.2}
						 };
						 //animations
			 this.animation='idle';
			 this.animInQueue=null;
			 this.animationFrame=0;			 
			 this.sprite_type='lance_sentry';
			 this.state='idle';
			 this.spriteGroups=spriteGroups;
			 for(let grp of spriteGroups)
			 	grp.push(this);
			 this.hit_box=new HitBox(x,y,this.width*0.5,this.height*0.5,[
			 	                                                        gameManager.collission_sprites
			 	                                                        // gameManager.visible_sprites
			 	                                                        // gameManager.active_sprites
			 	                                                        ],this,
                                                                        'lancehitbox');
			 this.image_offset=new CreateVector(0,0*xscale);

			 this.invincibleState=false;
		 	 this.invin_count=0;
		 	 this.max_invin_time=500;
		 	 this.flickerCount=0;
			 this.maxFlickerTime=100;
			 // this.longRangeAttacks=['throw','rush'];
			 this.gapClosings=["ballShower","slowApproach"];
			 // this.gapClosings=["ballShower"];
			 this.attacksList=["throwSpear","rush","rush","rush"];
			 // this.attacksList=["rush","rush","rush"];
			 this.pointed=false;
			 this.maxAttackGap=1000;
			 this.spearThrown=false;
			 this.tgtVec=new CreateVector(0,0);
			 this.enemysx=0;

			 this.phase1Rush=false;
			 this.rushVarsSet=false;
			 this.rushForce=new CreateVector(0,5*yscale);
             this.riseup_start_time=0;
			 this.probeDir=new CreateVector(0,1);
			 this.rushProbeDist=100*yscale;
			 this.movementHalted=false;
			 this.rushClock=0;
			 this.rushHaltTime=500;
			 this.phase2Rush=false;
			 this.rushForceHori=new CreateVector(2*xscale,0);
		 	this.rushHoriTime=1500;
		 	this.ballHoriTime=3000;
		 	this.rushAscentTime=2000;
		 	this.spearPointSpawned=false;
		 	this.hitPlayer=false;
		 	this.health=100;
		 	this.maxHealth=100;
		 	this.uiBarTimer=0;
		 	this.uiBarMaxTime=3000;
		 	this.healthBarOffset=new CreateVector(-30*xscale,-150*yscale);
		 	this.lanceHealthBar= new UIBar(0,0,100,15,this.health,this.maxHealth,'#222222','#FF0000',[gameManager.visible_sprites],false,'lancehealth');
		 	this.ballTimer=0;
		 	this.ballGapMax=1000;
		 	this.expVal=50;
            this.spotToCheckT=null;

            
            this.waitLimbo=0;
			 //lance constructor ends
		    }
		manageInvincibility()
			{
			if(!this.invincibleState) return false;
			this.invin_count+= deltaTime;
			if(this.invin_count > this.max_invin_time)
				{
				 this.invin_count=0;
				 this.invincibleState=false;
				} 
			}
		
		 takeDamage(dmg,dir=0)
		 	{
		 	//this.acceleration.add(new CreateVector(dir,0));
		 	if(this.invincibleState) return false;	
		 	this.invincibleState=true;
            document.querySelector('#retroJump').play();	
	 		this.health-=dmg;
	 		this.lanceHealthBar.updateValue(this.health);
	 		this.lanceHealthBar.onScreen=true;
	 		if(this.health<0)
	 			{
	 			this.tgt.giveExp(this.expVal);
	 			SpawnClouds(this.position);
	 			destroySelf(this);
	 			destroySelf(this.hit_box);
	 			destroySelf(this.lanceHealthBar);
                fogGateSound.play();
	 			gameManager.listOfDestroyedSprites.push(this.spriteId);
	 			this.isActive=false;
                DestroyAllBarriersInScene();
	 			}	
		 	}

		updateHealthBarPos()
			{
				if(this.lanceHealthBar.onScreen)
					{	
					this.uiBarTimer+=deltaTime;
					if(this.uiBarTimer > this.uiBarMaxTime)
					{
					 this.uiBarTimer=0;
					 this.lanceHealthBar.onScreen=false;
					}
					}
				this.lanceHealthBar.position.setVec(this.position.copy().add(this.healthBarOffset));
			}
		flickerControl()
			{
			  if(!this.invincibleState) return true;
			  this.flickerCount+=deltaTime;
			  if(this.flickerCount > this.maxFlickerTime)
			  	{
			  	 this.flickerCount=0;
			  	 return true;
			  	}
			  return false;
			}
		switchAnimation(animx)
			{
			 if(this.animation != animx)
			 	{
			 	this.animationFrame=0;
			 	this.animation=animx;			 	
			 	}
			}
		runAnimation()
			{
			  this.animationFrame+=this.animations[this.animation]['anim_speed'];
			  if(this.animationFrame >= this.animations[this.animation]['maxFrames'])
			  	{
		  		this.animationFrame=0;
		  		if(this.animInQueue) 
		  			{
		  			this.animation=this.animInQueue;
		  			//console.log('back to '+this.animation);
		  			this.animInQueue=null;
		  			}
			  	}
			  let rowIndex=parseInt(parseInt(this.animationFrame)/this.animations[this.animation]['cols']);
			  let colIndex=parseInt(this.animationFrame)%this.animations[this.animation]['cols'];
			  this.startx=colIndex * this.animations[this.animation]['width']/this.animations[this.animation]['cols'];
			  this.starty=rowIndex * this.animations[this.animation]['height']/this.animations[this.animation]['rows'];
			  this.imgWidth = this.animations[this.animation]['width']/this.animations[this.animation]['cols'];
			  this.imgHeight = this.animations[this.animation]['height']/this.animations[this.animation]['rows'];
			}
		 stateMachine()
		 	{
		 	 switch(this.state)
		 	 	{
		 	 	 case 'idle':
		 	 	 	this.idleActions();
		 	 	 	break;
		 	 	 case 'agro':
		 	 	 	this.agroActions();
		 	 	 	break;
		 	 	 case 'throwSpear':
		 	 	 	this.throwSpear();
		 	 	 	break;
		 	 	 case 'rush':
		 	 	    this.rush();
		 	 	    break;
		 	 	 case 'slowApproach':
		 	 	 	this.slowApproach();
		 	 	 	break;
		 	 	 case 'ballShower':
		 	 	 	this.ballShower();
		 	 	 	break;
		 	 	 case 'riseup':
		 	 	  	this.riseup();
		 	 	  	break;
		 	 	 case 'quickThrow':
		 	 	 	this.quickThrow();
		 	 	 	break;
                 case 'waitLimbo':
                    this.WaitLimbo();
                    break;
		 	 	 default:
		 	 	 	break;
		 	 	}
		 	}
        CheckIfPlayerWentOutOfScope()
            {  
              if(!this.spotToCheckT){
                for(let x of gameManager.markedSpots)
                {                
                if(x.sprite_type=="enemystoptop")
                    this.spotToCheckT=x;
                }
              }

              if(!this.spotToCheckT || !gameManager.player.isActive){
                // console.log('no spot');
                return;
              }    
                       
              if(this.spotToCheckT.position.y > gameManager.player.position.y)
                {                  
                  this.state='waitLimbo';
                  this.switchAnimation('idle');
                  this.limboStart=gameManager.runningClock;
                }  

            }
        WaitLimbo(){
            if(gameManager.player.position.y >= this.spotToCheckT.position.y){
                this.state="agro";
            }
            if(gameManager.runningClock- this.limboStart> 2000){                
                SpawnClouds(this.position);
                this.hit_box.position.setVec(this.initPosition);
                // this.position.x=0;
                // this.position.y=0;
                this.state='idle';
            }
        }
		PlayerDetected(dist=this.raycastLength)
			{
			  if(!this.tgt) return false;
	          let offsets=[-40*yscale,0,40*yscale];
	          let probeRay=new CreateVector(1,0);
	          let angles=[0,60,90,120];
	          for(let anglex of angles)
	          	{	      		
	      		if(Raycast(this.position.copy(),probeRay.pointToAngle(anglex),dist,this.tgt))
	      			return Math.sign(this.position.x-this.tgt.position.x);
	          	}
	          return 0;
			}
		 idleActions()
		 	{
		 	 this.velocity.x=Lerp(this.velocity.x,0,2*xscale);
		 	 if(Math.abs(this.angle) > 1)
		 	 	this.angle=AngleLerp(this.angle,0,30);
		 	 let pd=this.PlayerDetected();
		 	 if(Math.abs(pd))
		 	 	{
		 	 	 this.sx=pd;
		 	 	}
		 	 if(Math.abs(pd)==1)
		 	 	this.state='agro';
		 	 
		 	}
		 turnInTgtDirection()
		 	{
		 	/*
		 	 let pd=this.PlayerDetected();
		 	 if(Math.abs(pd))
		 	 	{
		 	 	 this.sx=pd;		 	 	 
		 	 	}
		 	 */
		 	 return false;
		 	}
		 slowApproach()
		 	{
		 	 if(Math.abs(this.angle) > 1)
		 	 	this.angle=AngleLerp(this.angle,0,30);
		 	 if(this.enemysx==0)
		 	 	{
		 	 	 this.enemysx=Math.sign(this.position.x - this.tgt.position.x);			 	 	 	 	
                 this.maxVelocity.x=20*xscale;    	 
		 	 	}	

		 	 this.acceleration.add(this.horiForce.copy().mult(this.sx*-1));
		 	 if(Math.abs(this.position.x - this.tgt.position.x) < this.playerGap*0.5 || 
                this.enemysx != this.sx)
		 	 	{
		 	 	this.state='agro';
                this.lastAttackTime=0;
		 	 	this.enemysx=0;
                this.maxVelocity.x=this.normalvx;
		 	 	}
		 	}
		 
		 agroActions()
		 	{
              if(!gameManager.player || !gameManager.player.isActive)
              {
                this.state='idle';
                return;
              }
              this.CheckIfPlayerWentOutOfScope();
		 	  this.sx=Math.sign(this.position.x-this.tgt.position.x);
		 	  if(Math.abs(this.angle) > 1)
		 	 	this.angle=AngleLerp(this.angle,0,30);
		 	  let enemyGap=this.position.x - this.tgt.position.x;
		 	  this.velocity.x=Lerp(this.velocity.x,0,2*xscale);
		      if(gameManager.playerDied || !this.tgt || Math.abs(enemyGap) > this.playerOutDistance)
				{				 			 
				 this.state='idle';				
				}	
			  else if(Math.abs(enemyGap) > this.playerGap)
			  	{
			  	 // this.state='slowApproach';
			  	 this.state=this.gapClosings[Math.floor(Math.random()*this.gapClosings.length)];
			  	}			
			  if(gameManager.runningClock - this.lastAttackTime > this.maxAttackGap)	
			  	{			  	 
			  	 this.state = this.attacksList[Math.floor(Math.random()*this.attacksList.length)];
			  	}		  
		 	}

		 quickThrow()
		 	{
		 	 if(!this.pointed) 
		 	 	{
		 	 	this.pointed=true;
		 	 	this.switchAnimation('throw');
		 	 	this.tgtVec=new CreateVector(this.sx * -1,0);		 	 	
		 	 	}
		 	 else if(this.animation=='throw' && parseInt(this.animationFrame)==8 && !this.spearThrown)
		 	 	{
		 	 	this.spearThrown=true;
		 	 	document.querySelector('#whoosh').play();
 	 			new Spear(this.position.x,this.position.y,200*xscale,50*yscale,
 	  	 		   	  this.tgtVec,
 	  	 			  [gameManager.visible_sprites,gameManager.active_sprites],
 	  	 			  this);
		 	 	}
		 	  else if(this.animation=='throw' && parseInt(this.animationFrame)==12)		 	  
		 	  	{	 	  			 	  		
	 	  		this.switchAnimation('idle');
	 	  		this.throwDone=true;
	 	  		this.restClock=gameManager.runningClock;
		 	  	}
		 	  else if(this.throwDone && gameManager.runningClock - this.restClock > this.restTime)
		 	  	{
		 	  	this.throwDone=false;
				this.lastAttackTime=gameManager.runningClock;
	 	  		this.state='riseup';
	 	  		this.pointed=false;	 	  		
	 	  		this.switchAnimation('idle');
	 	  		this.spearThrown=false;
		 	  	}	
		 	}
		 
		 throwSpear()
		 	{
              this.velocity.x=Lerp(this.velocity.x,0,2*xscale);
		 	  if(!this.pointed)
		 	  	{
		 	  	  this.sx=Math.sign(this.position.x-this.tgt.position.x);
		 	  	  // this.turnInTgtDirection();
		 	  	  // this.sx=Math.sign(this.position.x-this.tgt.position.x);
		 	  	  let tgtVec= this.tgt.position.copy().sub(this.position);
		 	  	 
		 	  	  let tgtAngle= tgtVec.heading()+ (this.sx==1?180:0);
		 	  	  if(tgtAngle < 0) tgtAngle+=360;
		 	  	  else if(tgtAngle > 360) tgtAngle-=360;

		 	  	  this.angle=AngleLerp(this.angle,tgtAngle,30);
		 	  	  if(Math.abs(this.angle - tgtAngle) < 20)
		 	  	  {
		 	  	  	this.pointed=true;
		 	  	  	this.switchAnimation('throw');
		 	  	  	this.tgtVec=this.tgt.position.copy().sub(this.position).normalized();
		 	  	  }
		 	  	}
		 	  else if(this.animation=='throw' && parseInt(this.animationFrame)==8 && !this.spearThrown)
		 	  	 {
		 	  	 	// let dirx=this.tgt.position.copy().sub(this.position).normalized();
		 	  	 	document.querySelector('#whoosh').play();
		 	  	 	new Spear(this.position.x,this.position.y,200*xscale,50*yscale,
		 	  	 		   	  this.tgtVec,
		 	  	 			  [gameManager.visible_sprites,gameManager.active_sprites],
		 	  	 			  this);
		 	  	 	this.spearThrown=true;
		 	  	 }
		 	  else if(this.animation=='throw' && parseInt(this.animationFrame)==12)		 	  
		 	  	{	 	  		
	 	  		this.lastAttackTime=gameManager.runningClock;
	 	  		this.state='agro';
	 	  		this.pointed=false;
	 	  		this.spearThrown=false;
	 	  		this.switchAnimation('idle');
		 	  	}
		 	  	//implement wait for sometime to correct angle
		 	}
		 hitBoxMadeContact(hitboxdesc)
		 	{
		 	 // console.log(hitboxdesc+' reports contact');
		 	 this.hitPlayer=true;
		 	}

		 dropBallsOnIntervals()
		 	{
		 	 this.ballTimer+=deltaTime;
		 	 if(this.ballTimer < this.ballGapMax) return false;
		 	 this.ballTimer=0;
		 	 new ThornyBall(this.position.x,
 						   this.position.y,
 						   30*xscale,
 						   30*yscale,
 						   this,60*xscale*-1*this.sx,0,
 						   [gameManager.visible_sprites,gameManager.active_sprites],0,800
		 				          ); 
		 	}
		 ballShower()
		 	{		 	  
	 	  	 if(!this.rushVarsSet)
	 	  	 	{
	 	  	 	 this.angle=0;
	 	  	 	 this.rushVarsSet=true;
	 	  	 	 this.maxVelocity.x=this.showervx;
	 	  	 	 this.switchAnimation('charge');
	 	  	 	}
	 	  	 
	 	  	 this.rushClock+=deltaTime;
	 	  	 if(this.rushClock < this.ballHoriTime*0.8)
	 	  	 	{
	 	  	 	this.acceleration.add(this.rushForceHori.copy().mult(this.sx*-1));
	 	  	 	this.dropBallsOnIntervals();
	 	  	 	}
	 	  	 else
	 	 	 	{
	 	 	 	this.velocity.x=Lerp(this.velocity.x,0,10);
	 	 	 	if(this.animation=='charge')
	 	 	 	 	{
	 	 	 	 	 this.animInQueue='idle';
	 	 	 	 	 this.switchAnimation('recover');
	 	 	 	 	}
	 	 	 	}
	 	  	 if(this.rushClock > this.ballHoriTime)
	 	 	 	{
	 	 	 	 this.rushClock=0; 	 	 	 	
	 	 	 	 this.rushVarsSet=false;
	 	 	 	 this.maxVelocity.x=this.normalvx;
	 	 	 	 this.state='agro';
	 	 	 	 this.lastAttackTime=gameManager.runningClock;
	 	 	 	}		 	  	
		 	}
		
		 rush()
		 	{
		 	 if(!this.phase1Rush)
		 	 	{		 	 	
		 	 	if(!this.movementHalted)
			 	 	{			 	 	
		 	 		if(!this.rushVarsSet)
		 	 			{
		 	 			 this.maxVelocity.x=this.rushvx;
		 	 			 this.rushVarsSet=true;
		 	 			 this.velocity.set(0,0);
		 	 			}
		 	 		this.acceleration.add(this.rushForce);
		 	 		// let gDetected=RaycastAll(this.position.copy(),this.probeDir,this.rushProbeDist,[gameManager.collission_sprites],[this.hit_box]);

		 	 		let gDetected=false;
		 	 		let playerHit=false;
		 	 		for (let sp of gameManager.collission_sprites)
		 	 			{
		 	 			if(sp==this.hit_box) continue;
		 	 			if(Raycast(this.position.copy(),this.probeDir,this.rushProbeDist,sp))
		 	 				{	
		 	 				gDetected=true;
		 	 				if(sp.sprite_type=='playerhitbox')
		 	 					playerHit=true;
		 	 			    break;
		 	 				}
		 	 			}		 	 		
		 	 		if(gDetected)
		 	 			{		 	 	
		 	 			 let playerPos= this.tgt.position.x-this.position.x;		 	 			 			
		 	 			 let playerAbsent= playerPos > 0 && this.sx==1 || playerPos < 0 && this.sx==-1;
		 	 			 if(playerHit || playerAbsent)
			 	 			 {
			 	 			 if(playerAbsent)
			 	 			 	console.log('cancelling: player is absent:1863');
			 	 			 this.maxVelocity.x=this.normalvx;
			 	 			 this.rushVarsSet=false;
			 	 			 this.velocity.set(0,0);
			 	 			 this.state='riseup';
			 	 			 }
			 	 		 else if(Math.random()<0.6)
			 	 		 	{

			 	 		 	 this.movementHalted=true;
			 	 		 	}	
			 	 		 else
			 	 		 	{			 	 		 	  
			 	 		 	 this.maxVelocity.x=this.normalvx;
			 	 			 this.rushVarsSet=false;
			 	 			 this.velocity.set(0,0);
			 	 			 this.state='quickThrow';
			 	 		 	}	 	 			 
		 	 			 
		 	 			}
			 	 	}
			 	 else
			 	 	{	
			 	 	 if(!this.spearPointSpawned)
			 	 	 	{
			 	 	 	this.spearPointSpawned=true;			 	 	 
			 	 	 	//console.log('lance point spawned');
			 	 	 	new DamageHitBox(this.position.x,this.position.y,30*xscale,30*yscale,
			 	 	 					 [gameManager.active_sprites,gameManager.hitbox_sprites],
			 	 	 					 'enemy_hitbox',this,-100*xscale,30*yscale,10,-this.sx*10,4000
			 	 	 					);
			 	 	 	}
			 	 	 if(this.animation!='anticipate' && this.animation!='charge')
			 	 	 	{
			 	 	 	 this.animInQueue='charge';
			 	 	 	 this.switchAnimation('anticipate');
			 	 	 	}		 	 	 
			 	 	 this.velocity.y=Lerp(this.velocity.y,0,10);
			 	 	 this.rushVarsSet=false;
			 	 	 this.rushClock+= deltaTime;
			 	 	 if(this.rushClock > this.rushHaltTime)
			 	 	 	{	
			 	 	 	 this.rushClock=0;
			 	 	 	 this.phase1Rush=true;
			 	 	 	 this.movementHalted=false;
			 	 	 	 
			 	 	 	}
			 	 	}
		 	 	}
		 	 else if(!this.phase2Rush)
		 	 	{
		 	 	 this.rushClock+=deltaTime;
		 	 	 if(this.hitPlayer)
		 	 	 	{
		 	 	 	 this.hitPlayer=false;
		 	 	 	 this.rushClock=this.rushHoriTime*0.82;
		 	 	 	}
		 	 	 if(this.rushClock > this.rushHoriTime*0.8)
		 	 	 	{
		 	 	 	this.velocity.x=Lerp(this.velocity.x,0,10);
		 	 	 	}
		 	 	 else
		 	 	 	{
		 	 	 	 this.acceleration.add(this.rushForceHori.copy().mult(this.sx*-1));
		 	 	 	}
		 	 	 if(this.rushClock > this.rushHoriTime)
		 	 	 	{
		 	 	 	 this.rushClock=0;		 	 	 	 
		 	 	 	 this.phase2Rush=true;
		 	 	 	 this.restClock=gameManager.runningClock;
		 	 	 	 if(this.animation=='charge')
		 	 	 	 	{
		 	 	 	 	 this.animInQueue='idle';
		 	 	 	 	 this.switchAnimation('recover');
		 	 	 	 	}
		 	 	 	}
		 	 	}
		 	 else if(gameManager.runningClock - this.restClock > this.restTime)
		 	 	{		 	 	  	 	 	  
		 	 	  this.rushClock+=deltaTime; 	  	
		 	 	  if(this.rushClock < 0.8*this.rushAscentTime && this.tgt.position.y - this.position.y < 200*yscale)
		 	 	  {
		 	 	  	this.acceleration.add(this.rushForce.copy().mult(-1));
		 	 	  }
		 	 	  else
		 	 	  	{
		 	 	  	this.velocity.y=Lerp(this.velocity.y,0,10);		 	 	  	
		 	 	  	}
		 	 	  if(this.rushClock > this.rushAscentTime)
		 	 	  	{
		 	 	  	 this.rushClock=0;
		 	 	  	 this.phase2Rush=false;
		 	 	  	 this.phase1Rush=false;
		 	 	  	 this.lastAttackTime=gameManager.runningClock;
	 	  			 this.state='agro';	 	  			 
	 	  			 this.maxVelocity.x=this.normalvx;
	 	  			 this.spearPointSpawned=false;
	 	  			 this.switchAnimation('idle');
		 	 	  	}
		 	 	}
		 	}
         
		 riseup()
		 	{
             if(!this.riseup_start_time)
                this.riseup_start_time=gameManager.runningClock;

             let cant_keep_rising= gameManager.runningClock- this.riseup_start_time > 3000;
		 	 if(this.tgt.position.y - this.position.y < 200*yscale && !cant_keep_rising)
		 	 	 this.acceleration.add(this.rushForce.copy().mult(-1));
		 	 else
		 	 	{
		 	 	 this.velocity.y=0;
		 	 	 this.state='agro';
                 this.riseup_start_time=0;
		 	 	}
		 	}
		 
		 move()
		 	{		 		 
		 	 this.velocity.add(this.acceleration);
		 	 this.acceleration.set(0,0);		 	
		 	 this.applyVelocity();
		 	 this.applyVelocityRestrictions();
		 	 this.update_and_display_hitbox();
		 	 // this.spawnHitBoxOnSlashHusk();
		 	 // this.checkTarget();
		 	 // this.manageInvincibility();		 	 

		 	}
		 applyVelocity()
		 	{		 	 	 	 
		 	 this.hit_box.position.x+=this.velocity.x;		 	
		 	 for(let x of gameManager.collission_sprites)
		 	 	{
		 	 	 if(!x.onScreen) continue;
		 	 	 if(x==this.hit_box) continue;
		 	 	 
		 	 	 if(b_collision(this.hit_box,x)) 
		 	 	 	{
		 	 	 	
		 	 	 	 if(this.velocity.x > 0)
		 	 	 	 	this.hit_box.position.x=x.position.x-x.width/2-this.hit_box.width/2-2;
		 	 	 	 else 
		 	 	 	 	this.hit_box.position.x=x.position.x+x.width/2+this.hit_box.width/2+2;
		 	 	 	}		 	 	 
		 	 	}

		 	 this.hit_box.position.y+=this.velocity.y;
		 	 for(let x of gameManager.collission_sprites)
		 	 	{
		 	 	 if(!x.onScreen) continue;
		 	 	 if(x==this.hit_box) continue;
		 	 	 if(b_collision(this.hit_box,x)) 
		 	 	 	{
		 	 	 	
		 	 	 	if(this.velocity.y > 0)
		 	 	 		this.hit_box.position.y=x.position.y-x.height/2-this.hit_box.height/2-2;
		 	 	 	else
		 	 	 		this.hit_box.position.y=x.position.y+x.height/2+this.hit_box.height/2+2;	
		 	 	 	}
		 	 	}
		 	}
		 applyVelocityRestrictions()
		 	{
		 	 let xdir=this.velocity.x/Math.abs(this.velocity.x);
		 	 let ydir=this.velocity.y/Math.abs(this.velocity.y);
		 	 if(Math.abs(this.velocity.y) > this.maxVelocity.y)
		 	 	this.velocity.y=ydir*this.maxVelocity.y;
		 	 if(Math.abs(this.velocity.x) > this.maxVelocity.x)
		 	 	this.velocity.x=xdir*this.maxVelocity.x;
		 	}
		 update_and_display_hitbox()
		 	{
	 		// this.hit_box.updatePosition(this.position.copy().add(this.hit_box_offset));
	 		this.position.setVec(this.hit_box.position.copy().add(this.image_offset));
		 	}
		  update()
		  	{
		 	  this.runAnimation();
		 	  this.stateMachine();
		 	  this.update_and_display_hitbox();
		 	  this.move();
		 	  this.updateHealthBarPos();
		 	  this.manageInvincibility();
		 	  w2screen(this.state,this.position.x-gameManager.camera.position.x,this.position.y-50*yscale-gameManager.camera.position.y);
		  	}
		  display()
		  	{
		 	 if(!this.onScreen) return false;
		 	 ctx.save();
		 	 ctx.translate(this.position.x-gameManager.camera.position.x, 
		 	 	 		   this.position.y-gameManager.camera.position.y);
		 	 ctx.rotate(d2r(this.angle));
		 	 ctx.scale(this.sx,this.sy);
		 	 if(this.flickerControl())
		 	 ctx.drawImage(this.animations[this.animation]['imgsheet'],
		 	 				this.startx,this.starty,this.imgWidth,this.imgHeight,
		 	 			   -this.width/2,
		 	 			   -this.height/2,
		 	 			   this.width*this.animations[this.animation]['width_extend'],
		 	 			   this.height*this.animations[this.animation]['height_extend']
		 	 			  );
		 	 // context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height);
		 	 ctx.restore();
		  	}
		}

    //false knight starts
    class FalseKnight
    	{
    	constructor(x,y,wid,hei,spriteGroups,spriteId='falseknight',spawnedBoss=false)
    		{
    		 this.spawnedBoss=spawnedBoss;
    		 this.fkMusicStarted=false;
    		 this.position= new CreateVector(x,y);
    		 this.width = wid;
    		 this.height = hei;
    		 let folderPath='sprites/FalseKnight';
    		 this.onScreen=!spawnedBoss;             
    		 this.angle=0;
    		 this.sx=1;
    		 this.sy=1;
    		 this.startx=0;
			 this.starty=0;
			 this.imgWidth=0;
			 this.imgHeight=0;
			 this.spriteId=spriteId;
			 this.acceleration=new CreateVector(0,0);
			 this.velocity=new CreateVector(0,0);
			 this.maxHorizontalVelocity=3*xscale;
			 this.maxVelocity=new CreateVector(this.maxHorizontalVelocity,12*yscale);
			 this.horiForce=new CreateVector(2*xscale,0);	 
			 this.fkJumpForce=new CreateVector(0,-250*yscale);
			 this.gravityScale=2*yscale;			 	
			 this.expVal=200; 
			 this.attackStarted=false;
			 this.isActive=false;
			 if(!spawnedBoss) this.isActive=true;
			 this.animations={
						 	'attack':{'imgsheet':LoadImagex(folderPath,'attack.png'),
						  		    'width':2118,
						  		    'height':590,			  		    
						  		    'rows':1,
						  		    'cols':3,
						  		    'maxFrames':3,
						  		    'width_extend':1.25,
						  		    'height_extend':1.25,
						  		    'anim_speed':0.15
						  		     },
				'attack_anticipate':{'imgsheet':LoadImagex(folderPath,'attack_anticipate.png'),
						  		    'width':2881,
						  		    'height':795,			  		    
						  		    'rows':2,
						  		    'cols':5,
						  		    'maxFrames':6,
						  		    'width_extend':1,
						  		    'height_extend':1,
						  		    'anim_speed':0.2
						  		     },
				    'attack_recover':{'imgsheet':LoadImagex(folderPath,'attack_recover.png'),
						  		    'width':3300,
						  		    'height':564,			  		    
						  		    'rows':1,
						  		    'cols':5,
						  		    'maxFrames':5,
						  		    'width_extend':1,
						  		    'height_extend':1,
						  		    'anim_speed':0.2
						  		     },
				    'idle':{'imgsheet':LoadImagex(folderPath,'idle.png'),
						  		    'width':3117,
						  		    'height':396,			  		    
						  		    'rows':1,
						  		    'cols':5,
						  		    'maxFrames':5,
						  		    'width_extend':1,
						  		    'height_extend':1,
						  		    'anim_speed':0.2
						  		     },
				              'jump':{'imgsheet':LoadImagex(folderPath,'jump.png'),
						  		    'width':2414,
						  		    'height':339,			  		    
						  		    'rows':1,
						  		    'cols':4,
						  		    'maxFrames':4,
						  		    'width_extend':1,
						  		    'height_extend':1,
						  		    'anim_speed':0.2
						  		     },
				   'jump_anticipate':{'imgsheet':LoadImagex(folderPath,'jump_anticipate.png'),
						  		    'width':1830,
						  		    'height':381,			  		    
						  		    'rows':1,
						  		    'cols':3,
						  		    'maxFrames':3,
						  		    'width_extend':1,
						  		    'height_extend':1,
						  		    'anim_speed':0.2
						  		     },
				   'jump_attack_1':{'imgsheet':LoadImagex(folderPath,'jump_attack_1.png'),
						  		    'width':1689,
						  		    'height':618,			  		    
						  		    'rows':1,
						  		    'cols':2,
						  		    'maxFrames':2,
						  		    'width_extend':1.25,
						  		    'height_extend':1.25,
						  		    'anim_speed':0.1
						  		     },
				     'jump_attack_2':{'imgsheet':LoadImagex(folderPath,'jump_attack_2.png'),
						  		    'width':861,
						  		    'height':589,			  		    
						  		    'rows':1,
						  		    'cols':2,
						  		    'maxFrames':2,
						  		    'width_extend':1,
						  		    'height_extend':1,
						  		    'anim_speed':0.2
						  		     },
				     'jump_attack_3':{'imgsheet':LoadImagex(folderPath,'jump_attack_3.png'),
						  		    'width':1236,
						  		    'height':399,			  		    
						  		    'rows':1,
						  		    'cols':2,
						  		    'maxFrames':2,
						  		    'width_extend':1,
						  		    'height_extend':1,
						  		    'anim_speed':0.2
						  		     },
				     'run':{'imgsheet':LoadImagex(folderPath,'run.png'),
						  		    'width':3120,
						  		    'height':483,			  		    
						  		    'rows':1,
						  		    'cols':5,
						  		    'maxFrames':5,
						  		    'width_extend':1,
						  		    'height_extend':1,
						  		    'anim_speed':0.2
						  		     },
					'stun_fall':{'imgsheet':LoadImagex(folderPath,'stun_fall.png'),
						  		    'width':3063,
						  		    'height':1035,			  		    
						  		    'rows':2,
						  		    'cols':4,
						  		    'maxFrames':5,
						  		    'width_extend':1,
						  		    'height_extend':1,
						  		    'anim_speed':0.2
						  		     },
					'stun_fall_end':{'imgsheet':LoadImagex(folderPath,'stun_fall_end.png'),
						  		    'width':1678,
						  		    'height':460,			  		    
						  		    'rows':1,
						  		    'cols':4,
						  		    'maxFrames':4,
						  		    'width_extend':1,
						  		    'height_extend':1,
						  		    'anim_speed':0.2
						  		     },

			  		         };			  		
			  	this.animation='idle';
			  	this.animInQueue=null;
			  	this.animationFrame=0;
			  	this.sprite_type='false_knight';
			  	this.state=spawnedBoss?'fkagro':'fkidle';
			  	this.maxHealth=100;
			  	this.health=this.maxHealth;
			  	this.spriteGroups=spriteGroups;
			 	for(let grp of spriteGroups)
			 		grp.push(this);
			    this.hit_box=new HitBox(x,y,this.width*0.4,this.height*0.8,[
                                                        gameManager.collission_sprites
                                                        // gameManager.active_sprites
                                                        ],this,'falseknighthitbox');
			 this.image_offset=new CreateVector(-30*xscale,-15*yscale);
			 this.image_offset_fixed=this.image_offset.copy();
			 this.fkHealthBar= new UIBar(0,0,100,15,this.health,this.maxHealth,'#222222','#FF0000',[gameManager.visible_sprites],false,'fkhealth');
			 this.fkHealthBar.onScreen=false;
			 this.uiBarTimer=0;
			 this.uiBarMaxTime=2000;
			 this.healthBarOffset=new CreateVector(-30*xscale,-120*yscale);
			 this.hitBoxSpawned=false;
			 if(gameManager.player)
			 	this.tgt= gameManager.player;	

			 this.invincibleState=false;
		 	 this.invin_count=0;
		 	 this.max_invin_time=500;
		 	 this.flickerCount=0;
			 this.maxFlickerTime=100;

			 this.gravityScale=2*yscale;
			 this.fkLastAttackTime=0;
    		 this.fkMinAttackGap=800;
    		 this.fkPlayerFarDistance=280*xscale;
    		 this.fkJumpInDistance=400*xscale;    		

    		 this.closeAttacks=['fkattack','fkattack','fkslam'];
    	     this.longAttacks =['runup'];    	     
    	     this.randomAttacks=['fkjumpattack'];
    	     this.jumpForceApplied=false;
    	     this.attackClock=0;
    	     this.freeToJump=true;

    	     this.dodgeStarted=false;
    		 this.dodgeStartTime=0;
    		 this.dodgeSpeed=10*xscale;
    		 this.maxDodgeTime=500;
    		 this.dodgeRight=1; 
             this.raycastLength=400*xscale;   	     
    		} 
         lookForBFightTrigger()
            {
              for(let go of gameManager.active_sprites)
                {
                 if(go.spriteId && go.spriteId=="BossFightTriggGO")
                    go.triggerOnRequest(this);
                }  
            }
    	 removeBars()
    	 	{
    	 	 for(let go of gameManager.active_sprites)
    	 	 	{
    	 	 	 if(go.spriteId && go.spriteId=="BossFightTriggGO")
    	 	 	 	go.bossHasDiedRemoveBars();
    	 	 	}
    	 	}
         PlayerDetected(n,dist=this.raycastLength)
            {
              if(!this.tgt || !this.tgt.isActive) return false;
              let offsets=[-40*yscale,0,40*yscale];
              for(let offset of offsets)
                {
                let yoffset=new CreateVector(0,offset);
                if(Raycast(this.position.copy().add(yoffset),new CreateVector(n,0),dist,this.tgt))
                    return true;
                }
              return false;
            }
		 takeDamage(dmg,dir=0)
		 	{
		 	//this.acceleration.add(new CreateVector(dir,0));
		 	if(this.invincibleState) return false;	
		 	this.invincibleState=true;	
            document.querySelector('#retroJump').play();
	 		this.health-=dmg;
	 		this.fkHealthBar.updateValue(this.health);
	 		this.fkHealthBar.onScreen=true;
	 		if(this.health <= 5)
	 			{
	 			capraMusic.src="";
	 			fogGateSound.play();
	 			this.removeBars();
	 			this.tgt.giveExp(this.expVal);
	 			SpawnClouds(this.position);
	 			destroySelf(this);
	 			destroySelf(this.hit_box);
	 			destroySelf(this.fkHealthBar);
                gameManager.listOfDestroyedSprites.push(this.spriteId);	 			
	 			}	
		 	}   
		updateHealthBarPos()
			{
				if(this.fkHealthBar.onScreen)
					{	
					this.uiBarTimer+=deltaTime;
					if(this.uiBarTimer > this.uiBarMaxTime)
						{
					 	this.uiBarTimer=0;
					 	this.fkHealthBar.onScreen=false;
						}
					}
				this.fkHealthBar.position.setVec(this.position.copy().add(this.healthBarOffset));
			}
		manageInvincibility()
			{
			if(!this.invincibleState) return false;
			this.invin_count+= deltaTime;
			if(this.invin_count > this.max_invin_time)
				{
				 this.invin_count=0;
				 this.invincibleState=false;
				} 
			}		
		flickerControl()
			{
			  if(!this.invincibleState) return true;
			  this.flickerCount+=deltaTime;
			  if(this.flickerCount > this.maxFlickerTime)
			  	{
			  	 this.flickerCount=0;
			  	 return true;
			  	}
			  return false;
			}
		 applyGravity()
		 	{
		 	 this.acceleration.y+=this.gravityScale;
		 	}
		 applyVelocity()
		 	{		 	 	 	 
		 	 this.hit_box.position.x+=this.velocity.x;		 	
		 	 for(let x of gameManager.collission_sprites)
		 	 	{
		 	 	 if(!x.onScreen) continue;
		 	 	 if(x==this.hit_box) continue;
		 	 	 
		 	 	 if(b_collision(this.hit_box,x)) 
		 	 	 	{		 	 	 	
		 	 	 	 if(this.velocity.x > 0)
		 	 	 	 	this.hit_box.position.x=x.position.x-x.width/2-this.hit_box.width/2-2;
		 	 	 	 else 
		 	 	 	 	this.hit_box.position.x=x.position.x+x.width/2+this.hit_box.width/2+2;
		 	 	 	}
		 	 	 		 	 	
		 	 	}

		 	 this.hit_box.position.y+=this.velocity.y;
		 	 for(let x of gameManager.collission_sprites)
		 	 	{
		 	 	 if(!x.onScreen) continue;
		 	 	 if(x==this.hit_box) continue;
		 	 	 if(b_collision(this.hit_box,x)) 
		 	 	 	{
		 	 	 	
		 	 	 	if(this.velocity.y > 0)
		 	 	 		this.hit_box.position.y=x.position.y-x.height/2-this.hit_box.height/2-2;
		 	 	 	else
		 	 	 		this.hit_box.position.y=x.position.y+x.height/2+this.hit_box.height/2+2;	
		 	 	 	}
		 	 	}
		 	}
		 applyVelocityRestrictions()
		 	{
		 	 let xdir=this.velocity.x/Math.abs(this.velocity.x);
		 	 let ydir=this.velocity.y/Math.abs(this.velocity.y);
		 	 if(Math.abs(this.velocity.y) > this.maxVelocity.y)
		 	 	this.velocity.y=ydir*this.maxVelocity.y;
		 	 if(Math.abs(this.velocity.x) > this.maxVelocity.x)
		 	 	this.velocity.x=xdir*this.maxVelocity.x;
		 	}
		update_and_display_hitbox()
		 	{
	 		// this.hit_box.updatePosition(this.position);
	 		this.position.setVec(this.hit_box.position.copy().add(this.image_offset));
		 	}
		 move()
		 	{		
		 	 this.applyGravity(); 	 
		 	 this.velocity.add(this.acceleration);
		 	 this.acceleration.set(0,0);		 	
		 	 this.applyVelocity();
		 	 this.applyVelocityRestrictions();
		 	 this.update_and_display_hitbox();
		 	 this.spawnHitBoxOnHit_fknight();
		 	}
    	update()
    		{
    		 if(!this.isActive)
    		 	return false;
    		
    		 this.stateMachine();    		 
    		 this.move(); 
    		 this.updateHealthBarPos();  
    		 this.manageInvincibility(); 		 
    		}
    	display()
		 	{		 	 
		 	 if(!this.onScreen) return false;             
		 	 this.runAnimation();
		 	 ctx.save();
		 	 ctx.translate(this.position.x-gameManager.camera.position.x, 
		 	 	 		   this.position.y-gameManager.camera.position.y);
		 	 ctx.rotate(d2r(this.angle));
		 	 ctx.scale(this.sx,this.sy);
		 	 if(this.flickerControl())
		 	 ctx.drawImage(this.animations[this.animation]['imgsheet'],
		 	 				this.startx,this.starty,this.imgWidth,this.imgHeight,
		 	 			   -this.width/2,
		 	 			   -this.height/2,
		 	 			   this.width*this.animations[this.animation]['width_extend'],
		 	 			   this.height*this.animations[this.animation]['height_extend']
		 	 			  );
		 	 // context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height);
		 	 ctx.restore();
		 	 w2screen(this.state,this.position.x-gameManager.camera.position.x,this.position.y-50*yscale-gameManager.camera.position.y);
		 	}
    	stateMachine()
    		{
    		 switch(this.state)
    		 	{
    		 	case 'fkidle':
    		 	  this.fkidle();
    		 	  break;
    		 	case 'fkagro':
    		 	  // console.log('agro');
    		 	  this.fkagro();
    		 	  break;
    		 	case 'runup':
    		 	  // console.log('runup');
    		 	  this.runup();
    		 	  break;
    		 	case 'fkattack':
    		 	  // console.log('attack');
    		 	  this.fkattack();
    		 	  break;
    		 	case 'fkjumpattack':
    		 	  // console.log('jump');
    		 	  this.fkjumpattack();
    		 	  break;
    		 	 case 'fkdodgeback':
    		 	  this.fkdodgeback();
    		 	  break;
    		 	 case 'fkslam':
    		 	  this.fkslam();
    		 	  break;
    		 	 default:
    		 	  console.log('warning: unknown state');
    		 	  break;
    		 	}
    		}
    	fkidle()
    		{
    		 if(this.PlayerDetected(1) || this.PlayerDetected(-1))
                {
                this.lookForBFightTrigger();
                this.state="fkagro";
                }
    		} 
    	fkslam()
    		{
    		 if(!this.jumpForceApplied)
    		 	{
    		 	 this.velocity.x=0;
    		 	 this.animInQueue='stun_fall';
    		 	 this.switchAnimation('jump_anticipate');
    		 	 this.jumpForceApplied=true;
    		 	 this.acceleration.add(this.fkJumpForce.copy().mult(1.8));
    		 	 this.attackClock=gameManager.runningClock; 
    		 	 
    		 	 new DamageHitBox(this.position.x,this.position.y,
    		 	 	              400*xscale,30*yscale,
			 	 	 			  [gameManager.active_sprites,gameManager.hitbox_sprites],
			 	 	 			 'enemy_hitbox',this,0*xscale,90*yscale,10,-this.sx*0,900
			 	 	 			 );   		 	 
    		 	}
    		 else if(this.animation=='stun_fall')
    		 	{
 					this.animInQueue='stun_fall_end';
    		 	}
    		 else if(this.animation=='stun_fall_end')
    		 	{
    		 		this.animInQueue='idle';
    		 	}
    		
    		 if(gameManager.runningClock - this.attackClock > 1500)
    		 	{
    		 	 this.fkLastAttackTime=gameManager.runningClock;
    		 	 this.state='fkagro';
    		 	 this.jumpForceApplied=false;    		 	 		 	 
    		 	}	
    		} 
    	
    	fkdodgeback()
    		{
    		 if(!this.dodgeStarted)
    		   {
    		   this.dodgeStarted=true;	
    		   this.dodgeStartTime=gameManager.runningClock;
    		   this.velocity.x=this.dodgeRight*this.dodgeSpeed;
    		   this.maxVelocity.x=this.dodgeSpeed;
    		   this.switchAnimation('run');
    		   }
    		  else if(gameManager.runningClock - this.dodgeStartTime > this.maxDodgeTime)
    		  {
    		  	this.dodgeStartTime=0;
    		  	this.velocity.x=0;
    		  	this.maxVelocity.x=this.maxHorizontalVelocity;
    		  	this.fkLastAttackTime=gameManager.runningClock;
    		  	this.state='fkagro';
    		  	this.dodgeStarted=false;
    		  	this.switchAnimation('idle');
    		  	this.dodgeRight*=-1;
    		  }
    		}
    	fkjumpattack()
    		{
    		 if(!this.jumpForceApplied)
    		 	{
    		 	 this.velocity.x=0;
    		 	 this.animInQueue='jump_attack_1';
    		 	 this.switchAnimation('jump_anticipate');
    		 	 this.jumpForceApplied=true;
    		 	 this.acceleration.add(this.fkJumpForce);
    		 	 this.attackClock=gameManager.runningClock;
    		 	 this.maxVelocity.x=10*xscale;
    		 	}
    		 else if(this.animation=='jump_attack_1')
    		 	{
 					this.animInQueue='attack_recover';
    		 	}
    		 else if(this.animation=='attack_recover')
    		 	{
    		 		this.animInQueue='idle';
    		 	}
    		 if(gameManager.runningClock - this.attackClock < 500)
    		 	{
    		 	this.velocity.x=Lerp(this.velocity.x,10*xscale*this.sx,16);
    		 	}
    		 else
    		 	{
    		 	this.velocity.x=Lerp(this.velocity.x,0,16);
    		 	}
    		 if(gameManager.runningClock - this.attackClock > 1500)
    		 	{
    		 	 this.fkLastAttackTime=gameManager.runningClock;
    		 	 this.state='fkagro';
    		 	 this.jumpForceApplied=false;  
    		 	 this.maxVelocity.x=3*xscale; 
    		 	 this.hitBoxSpawned=false; 		 	 
    		 	}

    		}
    	runup()
    		{
    		 this.switchAnimation("run");
    		 let playerSep=this.tgt.position.x - this.position.x;    		 
    		 if(Math.abs(playerSep) > this.fkPlayerFarDistance*0.7)
    		 	this.acceleration.add(this.horiForce.copy().mult(this.sx*2));    		 
    		 else
    		 	{
    		 	this.velocity.x=0;
    		 	this.state="fkagro"; 
    		 	this.switchAnimation('idle');    		 	
    		 	}
    		 if(Math.abs(playerSep) < this.fkJumpInDistance && this.freeToJump )
    		 	{    		 
    		 	 this.freeToJump=false;	
    		 	 if(Math.random()<0.9)
    		 	 	{
    		 	 	this.velocity.x=0;
    		 	 	this.state="fkjumpattack";   
    		 	 	} 		 	
    		 	}
    		 for(let sp of gameManager.markedSpots)
    		 	{
    		 	  if(sp.sprite_type=="fkjumpup" &&  b_collision(this.hit_box,sp))
    		 	  	{
    		 	  	this.velocity.x=0;
    		 	 	this.state="fkjumpattack"; 
    		 	  	}
    		 	}
    		 
    		}
 	
    	fkagro()
    		{
    		 if(!this.tgt.isActive)
    		 	return false;
    		  if(!this.fkMusicStarted)
    		 	{
    		  	this.fkMusicStarted=true;
    		  	capraMusic.play();	
    		 	}
    		 let playerSep=this.tgt.position.x - this.position.x;
    		 this.sx=Math.sign(playerSep);
    		 if(Math.abs(playerSep) > this.fkJumpInDistance)
    		 	{
    		 	 if(!this.freeToJump) 
    		    	{
    		    	this.freeToJump=true;    		    		
    		    	}
    			 }
    		 if(Math.abs(playerSep) < 0.5*this.fkPlayerFarDistance &&
    		 	Math.abs(this.position.y-this.tgt.position.y) > this.height*0.5
    		 	)
    		 	{
    		 	this.state="fkdodgeback";
    		    return;
    			}

    		 if(Math.abs(playerSep) > this.fkPlayerFarDistance) 
    		 	{   		 	
    		    this.state=this.longAttacks[Math.floor(Math.random()*this.longAttacks.length)];    		   
    			}
    		 if(gameManager.runningClock - this.fkLastAttackTime > this.fkMinAttackGap)    	
    		    {    		    
    		 	this.state=this.closeAttacks[Math.floor(Math.random()*this.closeAttacks.length)];   
    		 	}		 
    		}
    	fkattack()
    		{
    		 if(!this.attackStarted && this.animation!="attack" && this.animation!="attack_anticipate" && this.animation!="attack_recover")
    		 	{
    		 	 this.switchAnimation("attack_anticipate");
    		 	 this.animInQueue="attack";
    		 	 this.attackStarted=true;
    		 	}
    		 else if(this.animation=="attack" && this.animInQueue!="attack_recover")
    		 	{
    		 	 this.animInQueue="attack_recover";
    		 	}
    		 else if(this.animation=="attack_recover" && this.animInQueue!="idle")
    		 	{
    		 	 this.animInQueue="idle";    		 	 
    		 	}
    		 if(this.animation=="idle" && this.attackStarted)
    		 	{
    		 	 this.state="fkagro";
    		 	 this.attackStarted=false;
    		 	 this.hitBoxSpawned=false;
    		 	 this.fkLastAttackTime=gameManager.runningClock;
    		 	}
    		 if(this.animation=="attack" )
    		 	{
    		 	 if(this.image_offset.y!=-30*yscale) this.image_offset.y=-60*yscale;
    		 	}
    		 else if(this.image_offset.y!=this.image_offset_fixed.y)
    		 	{
    		 	 this.image_offset.y=this.image_offset_fixed.y;
    		 	}

    		}
    	spawnHitBoxOnHit_fknight()
    		{
    		 let hbWidthRatio=0.2;
    		 let hbHeightRatio=0.9;    		 
    		 if(this.animation=="attack" && parseInt(this.animationFrame)==2 && !this.hitBoxSpawned)
    		 	{    
    		 	hbWidthRatio=0.4;
    		 	this.hitBoxSpawned=true;		 	
	 			new DamageHitBox(this.position.x,
								 this.position.y,
								 this.width*hbWidthRatio,
								 this.height*hbHeightRatio,
								 [gameManager.active_sprites,gameManager.hitbox_sprites,gameManager.visible_sprites],
								 'enemy_hitbox',
								 this,
								 150*xscale,50*yscale,10,this.sx*1.5,50); //xoffset,yoffset,dmg=10,dmghitback=0,life=50
    		 	}
    		else if(this.animation=="jump_attack_1" && parseInt(this.animationFrame)==1 && !this.hitBoxSpawned)
    		 	{  
    		 	hbWidthRatio=0.8;  
    		 	this.hitBoxSpawned=true;		 	
	 			new DamageHitBox(this.position.x,
								 this.position.y,
								 this.width*hbWidthRatio,
								 this.height*hbHeightRatio,
								 [gameManager.active_sprites,gameManager.hitbox_sprites],
								 'enemy_hitbox',
								 this,
								 120*xscale,50*yscale,10,this.sx*1.5,50); //xoffset,yoffset,dmg=10,dmghitback=0,life=50
    		 	}


    		}
    	runAnimation()
    		{
			  this.animationFrame+=this.animations[this.animation]['anim_speed'];
			  if(this.animationFrame >= this.animations[this.animation]['maxFrames'])
			  	{
		  		this.animationFrame=0;
		  		if(this.animInQueue) 
		  			{
		  			this.animation=this.animInQueue;
		  			//console.log('back to '+this.animation);
		  			this.animInQueue=null;
		  			}
			  	}
			  let rowIndex=parseInt(parseInt(this.animationFrame)/this.animations[this.animation]['cols']);
			  let colIndex=parseInt(this.animationFrame)%this.animations[this.animation]['cols'];
			  this.startx=colIndex * this.animations[this.animation]['width']/this.animations[this.animation]['cols'];
			  this.starty=rowIndex * this.animations[this.animation]['height']/this.animations[this.animation]['rows'];
			  this.imgWidth = this.animations[this.animation]['width']/this.animations[this.animation]['cols'];
			  this.imgHeight = this.animations[this.animation]['height']/this.animations[this.animation]['rows'];
			}
		switchAnimation(animx)
			{
			 if(this.animation != animx)
			 	{
			 	this.animationFrame=0;
			 	this.animation=animx;			 	
			 	}
			}

    	}
    //false knight ends
    //pickaxe starts (inherits from thorny ball)
    class PickAxe extends ThornyBall
    	{
    	 constructor(x,y,wid,hei,parentx,offsetx,offsety,spriteGroups,horiVel=14)
    	 	{
	 		super(x,y,wid,hei,parentx,offsetx,offsety,spriteGroups,horiVel);
	 		this.imagex=PICKAXEIMG;
	 		this.gravityScale=0.4*yscale;
		 	this.maxVelocity=new CreateVector(horiVel*xscale,1*yscale);
		 	this.rotSpeed=10;
		 	this.lifeTime=3000;
    	 	}
    	 checkCollisions()
    	 	{
    	 	 
    	 	 if(this.collidedObj!='none')	
    	 	 	{
	    	 	 SpawnClouds(this.position);
	 	 	 	 destroySelf(this.hit_box);
		 	  	 destroySelf(this);
		 	  	 // console.log('collision with '+this.collidedObj);
	 	 	 	 if(this.collidedObj=='playerhitbox')	    	 	 	 	 			 	  	 	 
		 	  	 	 gameManager.player.takeDamage(10,this.parentx.sx);
		 	  	 this.collidedObj='none';
		 	  	 }
    	 	 /*
    	 	 for(let x of gameManager.collission_sprites) 
    	 	 	{
    	 	 	 if(x==this.hit_box || x==this.parentx.hit_box) continue;
    	 	 	 if(b_collision(this.hit_box,x))
    	 	 	 	{
    	 	 	 	 SpawnClouds(this.position);
    	 	 	 	 destroySelf(this.hit_box);
			 	  	 destroySelf(this);
			 	  	 console.log('collision with '+x.sprite_type);
    	 	 	 	 if(x.sprite_type=='playerhitbox')	    	 	 	 	 			 	  	 	 
			 	  	 	 gameManager.player.takeDamage(10,this.parentx.sx);	    	 	 	 	   	 	 	 	
    	 	 	 	}
    	 	 	}
    	 	 	*/
    	 	}    	 
    	}
    //pickaxe ends
    //husk miner starts    
    class HuskMiner
    	{
    	constructor(x,y,wid,hei,spriteGroups,spriteId,hasCutScene)	
    		{
    		 this.isActive=false;
    		 this.position= new CreateVector(x,y);
    		 this.huskMusicStarted= false;
    		 this.tree_left=null;
    		 this.tree_right=null;
    		 this.isBoss= spriteId.split('_')[0]=='boss';
    		 this.hasCutScene=hasCutScene;
    		 if(this.isBoss && this.hasCutScene)
    		 this.tree_right= new BarrierTree(100*xscale+this.position.x,
    	 	   				   this.position.y+0*yscale,
    	 	   				   230*xscale,355*yscale,
    	 	   				   [gameManager.visible_sprites]
    	 	   				  );
    		 this.width= wid;
    		 this.height=hei;
    		 let folderPath= "sprites/huskMiner";
    		 this.onScreen=true;
    		 this.angle=0;
    		 this.sx=1;
    		 this.sy=1;
    		 this.startx=0;
			 this.starty=0;
			 this.imgWidth=0;
			 this.imgHeight=0;
			 this.spriteId=spriteId;
			 this.acceleration=new CreateVector(0,0);
			 this.velocity=new CreateVector(0,0);
			 this.maxVelocity=new CreateVector(3*xscale,12*yscale);		
			 this.horiForce=new CreateVector(1*xscale,0);
			 this.gravityScale=2*yscale;
			 this.expVal=100;
			 this.axesThrown= 0;
			 this.maxAxes= 1;
			 this.animations= {
			 				   'idle':{'imgsheet':LoadImagex(folderPath,'idle.png'),
						  		       'width':1170,
						  		       'height':174,			  		    
						  		       'rows':1,
						  		       'cols':9,
						  		       'maxFrames':9,
						  		       'width_extend':1,
						  		       'height_extend':1,
						  		       'anim_speed':0.15
						  		      },
			 				   'startle':{'imgsheet':LoadImagex(folderPath,'startle.png'),
						  		       'width':976,
						  		       'height':178,			  		    
						  		       'rows':1,
						  		       'cols':5,
						  		       'maxFrames':5,
						  		       'width_extend':1,
						  		       'height_extend':1,
						  		       'anim_speed':0.4
						  		         },
			 				   'run':{'imgsheet':LoadImagex(folderPath,'run.png'),
						  		       'width':1210,
						  		       'height':175,			  		    
						  		       'rows':1,
						  		       'cols':8,
						  		       'maxFrames':8,
						  		       'width_extend':1,
						  		       'height_extend':1,
						  		       'anim_speed':0.5
						  		     },
			 				   'throwAnticipate':{'imgsheet':LoadImagex(folderPath,'throwAnticipate.png'),
						  		       'width':804,
						  		       'height':179,			  		    
						  		       'rows':1,
						  		       'cols':5,
						  		       'maxFrames':5,
						  		       'width_extend':1,
						  		       'height_extend':1,
						  		       'anim_speed':0.1
						  		                  },
			 				   'Throw':{'imgsheet':LoadImagex(folderPath,'Throw.png'),
						  		       'width':409,
						  		       'height':171,			  		    
						  		       'rows':1,
						  		       'cols':3,
						  		       'maxFrames':3,
						  		       'width_extend':1,
						  		       'height_extend':1,
						  		       'anim_speed':0.1
						  		        },
			 				   'slash':{'imgsheet':LoadImagex(folderPath,'Slash.png'),
						  		       'width':387,
						  		       'height':176,			  		    
						  		       'rows':1,
						  		       'cols':1,
						  		       'maxFrames':1,
						  		       'width_extend':1,
						  		       'height_extend':1,
						  		       'anim_speed':0.4
						  		        },
			 				   'slashRecover':{'imgsheet':LoadImagex(folderPath,'slashRecover.png'),
						  		       'width':352,
						  		       'height':170,			  		    
						  		       'rows':1,
						  		       'cols':2,
						  		       'maxFrames':2,
						  		       'width_extend':1,
						  		       'height_extend':1,
						  		       'anim_speed':0.1
						  		        },
			 				   'mining':{'imgsheet':LoadImagex(folderPath,'mining.png'),
						  		       'width':1389,
						  		       'height':391,			  		    
						  		       'rows':2,
						  		       'cols':6,
						  		       'maxFrames':11,
						  		       'width_extend':1.3,
						  		       'height_extend':1.3,
						  		       'anim_speed':0.25
						  		        },
			 				  };
			 this.animation= 'idle';
			 this.animInQueue= null;
			 this.animationFrame= 0;
			 this.sprite_type= 'husk_miner';
			 if(this.hasCutScene) this.state= 'miner_idle';
			 else this.state='miner_agro';
			 this.maxHealth= 100;
			 this.health= 100;
			 this.spriteGroups= spriteGroups;
			 for(let grp of spriteGroups)
			 	grp.push(this);
			 this.hit_box=new HitBox(x,y,this.width*0.4,this.height*0.8,[
                                                        gameManager.collission_sprites,
                                                        // gameManager.visible_sprites
                                                        ],this,'huskminerhitbox');
			 this.image_offset=new CreateVector(-1*xscale,-15*yscale);
			 this.image_offset_fixed=this.image_offset.copy();
 			 this.minerHealthBar= new UIBar(0,0,100,15,this.health,this.maxHealth,
 			 								'#222222','#FF0000',[gameManager.visible_sprites],
 			 								false,'huskminerhealth');
			 this.minerHealthBar.onScreen=true;
			 this.minerAttackStarted=false;
			 this.uiBarTimer=0;
			 this.uiBarMaxTime=2000;
			 this.healthBarOffset=new CreateVector(-30*xscale,-120*yscale);
			 this.minerHitBoxSpawned=false;
			 if(gameManager.player)
			 	this.tgt= gameManager.player;	

			 this.invincibleState=false;
		 	 this.invin_count=0;
		 	 this.max_invin_time=500;
		 	 this.flickerCount=0;
			 this.maxFlickerTime=100;
			 
			 this.minerLastAttackTime=0;
    		 this.minerMinAttackGap=1200;
    		 this.minerPlayerFarDistance=180*xscale; 
    		 this.minerAgroDistance= 330 * xscale;   
    		 this.miningStarted = false;
    		 		     		

    		 this.closeAttacks=['miner_slash'];
    	     this.longAttacks =['miner_throw','miner_runup','miner_runup','miner_ballshower'];
    	     //this.longAttacks= ['miner_ballshower','miner_ballshower','miner_runup'];
    	     this.randomAttacks=[];

    	     this.hm_ritualStartTime=0;
    	 	 this.hm_ritualGapTime=0;
    	 	 this.hm_maxRitualGap=1000;
    	 	 this.hm_maxRitualTime=3000;
    		}

    	removeBars()
    	 	{
    	 	 for(let go of gameManager.active_sprites)
    	 	 	{
    	 	 	 if(go.spriteId && go.spriteId=="BossFightTriggGO")
    	 	 	 	go.bossHasDiedRemoveBars();
    	 	 	}
    	 	}
        destroyProp()
            {
                this.tree_right.burn();
            }
		updateHealthBarPos()
			{
			if(this.minerHealthBar.onScreen)
				{	
				this.uiBarTimer+=deltaTime;
				if(this.uiBarTimer > this.uiBarMaxTime)
					{
				 	this.uiBarTimer=0;
				 	this.minerHealthBar.onScreen=false;
					}
				}
			this.minerHealthBar.position.setVec(this.position.copy().add(this.healthBarOffset));
			}
		manageInvincibility()
			{
			if(!this.invincibleState) return false;
			this.invin_count+= deltaTime;
			if(this.invin_count > this.max_invin_time)
				{
				 this.invin_count=0;
				 this.invincibleState=false;
				} 
			}		
		flickerControl()
			{
			  if(!this.invincibleState) return true;
			  this.flickerCount+=deltaTime;
			  if(this.flickerCount > this.maxFlickerTime)
			  	{
			  	 this.flickerCount=0;
			  	 return true;
			  	}
			  return false;
			}
		applyGravity()
		 	{
		 	 this.acceleration.y+=this.gravityScale;
		 	}
		 applyVelocity()
		 	{		 	 	 	 
		 	 this.hit_box.position.x+=this.velocity.x;		 	
		 	 for(let x of gameManager.collission_sprites)
		 	 	{
		 	 	 if(!x.onScreen) continue;
		 	 	 if(x==this.hit_box) continue;
		 	 	 
		 	 	 if(b_collision(this.hit_box,x)) 
		 	 	 	{		 	 	 	
		 	 	 	 if(this.velocity.x > 0)
		 	 	 	 	this.hit_box.position.x=x.position.x-x.width/2-this.hit_box.width/2-2;
		 	 	 	 else 
		 	 	 	 	this.hit_box.position.x=x.position.x+x.width/2+this.hit_box.width/2+2;
		 	 	 	}
		 	 	 		 	 	
		 	 	}

		 	 this.hit_box.position.y+=this.velocity.y;
		 	 for(let x of gameManager.collission_sprites)
		 	 	{
		 	 	 if(!x.onScreen) continue;
		 	 	 if(x==this.hit_box) continue;
		 	 	 if(b_collision(this.hit_box,x)) 
		 	 	 	{
		 	 	 	
		 	 	 	if(this.velocity.y > 0)
		 	 	 		this.hit_box.position.y=x.position.y-x.height/2-this.hit_box.height/2-2;
		 	 	 	else
		 	 	 		this.hit_box.position.y=x.position.y+x.height/2+this.hit_box.height/2+2;	
		 	 	 	}
		 	 	}
		 	}
		 applyVelocityRestrictions()
		 	{
		 	 let xdir=this.velocity.x/Math.abs(this.velocity.x);
		 	 let ydir=this.velocity.y/Math.abs(this.velocity.y);
		 	 if(Math.abs(this.velocity.y) > this.maxVelocity.y)
		 	 	this.velocity.y=ydir*this.maxVelocity.y;
		 	 if(Math.abs(this.velocity.x) > this.maxVelocity.x)
		 	 	this.velocity.x=xdir*this.maxVelocity.x;
		 	}
		update_and_display_hitbox()
		 	{
	 		// this.hit_box.updatePosition(this.position);
	 		this.position.setVec(this.hit_box.position.copy().add(this.image_offset));
		 	}
		 move()
		 	{		
		 	 this.applyGravity(); 	 
		 	 this.velocity.add(this.acceleration);
		 	 this.acceleration.set(0,0);		 	
		 	 this.applyVelocity();
		 	 this.applyVelocityRestrictions();
		 	 this.update_and_display_hitbox();
		 	 this.spawnHitBoxOnHit_huskMiner();
		 	}
		 hmThrow()
		 	{
		 	 this.velocity.x=Lerp(this.velocity.x,0,2*xscale);
		 	 this.hmSlash();
		 	}
		 spawnHitBoxOnHit_huskMiner()
		 	{
		 	 let hbWidthRatio=0.8;//these can be modified to increase/ decrease the hitbox range
    		 let hbHeightRatio=0.3;
		 	 if(this.animation == 'slash' && 
		 	 	parseInt(this.animationFrame)==0 &&
		 	 	!this.minerHitBoxSpawned
		 	 	)
		 	 	{
		 	 	 this.minerHitBoxSpawned= true;
		 	 	 if(this.state=='miner_slash')
	 	 		 new DamageHitBox(this.position.x,
				 				  this.position.y,
				 				  this.width*hbWidthRatio,
				 				  this.height*hbHeightRatio,
				 				  [gameManager.active_sprites,
				 				   gameManager.hitbox_sprites,
				 				   ],
				     			  'enemy_hitbox',
				 				  this,
				 				  130*xscale,50*yscale,10,this.sx*1.5,50);
	 	 		else if(this.state=='miner_throw' && this.axesThrown < this.maxAxes)
	 	 			{	 	 			 
	 	 			 new PickAxe(this.position.x,
		 						   this.position.y,
		 						   150*xscale,
		 						   150*yscale,
		 						   this,70*xscale,0,
		 						   [gameManager.visible_sprites,gameManager.active_sprites]
		 				          );
	 	 		     this.axesThrown+=1;
	 	 			}
		 	 	}
		 	} 	
    	 stateMachine()
    	 	{
    	 	 switch(this.state)
    	 	 	{
    	 	 	case 'miner_idle':	
    	 	 		this.hmidle();
    	 	 		break;
    	 	 	case 'miner_agro':
    	 	 		this.hmAgro();
    	 	 		break;
    	 	 	case 'miner_slash':
    	 	 		this.hmSlash();
    	 	 		break;
    	 	 	case 'miner_runup':
    	 	 	 	this.hmRunUp();
    	 	 	 	break;
    	 	 	 case 'miner_throw':
    	 	 	 	this.hmThrow();
    	 	 	 	break;
    	 	 	 case 'miner_ballshower':
    	 	 	  	this.hmBallShower();
    	 	 	  	break;
    	 	 	}
    	 	}
    	 Spawnbarriers()
    	 	{
    	 	 if(this.isBoss)
    	 	 this.tree_left= new BarrierTree(-1400*xscale+this.position.x,
    	 	   				   -15*yscale+this.position.y,
    	 	   				   230*xscale,355*yscale,
    	 	   				   [gameManager.visible_sprites]
    	 	   				  );    	 	   
    	 	}
    	 Burnbarriers()
    	 	{
    	 	if(!this.tree_left) return;
	 		this.tree_left.burn();
	 		this.tree_right.burn();
	 		destroySelf(this);
    	 	}
    	 hmidle()
    	 	{

    	 	 if(!this.miningStarted)
    	 	 {
    	 	 this.switchAnimation('mining');
    	 	 this.miningStarted=true;
    	 	 }
    	 	 // return false;
    	 	 if(!this.tgt.isActive)
    	 	 	return false; 
    	 	 let playerSep=this.tgt.position.x - this.position.x;

    	 	 if(this.animation=='idle')
    	 	 	{
    	 	 	this.state='miner_agro';    	
    	 	 	this.miningStarted= false; 	
    	 	 	this.Spawnbarriers(); 
                this.destroyProp();	
    	 	 	}
    	 	 else if(this.animation!='startle' && 
                        (this.PlayerDetected(1)||this.PlayerDetected(-1)))
    	 	 	{    	 	 	 
    	 	 	 this.switchAnimation('startle');
    	 	 	 this.animInQueue='idle';
    	 	 	 if(!this.huskMusicStarted)
	    	 	 	{
	    	 	 	 this.huskMusicStarted= true;
                     this.lookForBFightTrigger();
                     pauseMusic();
	    	 	 	 capraMusic.src="./sounds/Capra.mp3";
	    	 	 	 capraMusic.play();
	    	 	 	}
    	 	 	}
    	 	 return false;
    	 	} 
         PlayerDetected(n,dist=this.minerAgroDistance)
            {
              if(!this.tgt || !this.tgt.isActive) return false;
              let offsets=[-70*yscale,-40*yscale,0,40*yscale,70*yscale];
              for(let offset of offsets)
                {
                let yoffset=new CreateVector(0,offset);
                if(Raycast(this.position.copy().add(yoffset),new CreateVector(n,0),dist,this.tgt))
                    return true;
                }
              return false;
            }
        lookForBFightTrigger()
            {
              for(let go of gameManager.active_sprites)
                {
                 if(go.spriteId && go.spriteId=="BossFightTriggGO")
                    go.triggerOnRequest(this);
                }  
            }  
    	 
    	 hmBallShower()
    	 	{
    	 	 if(this.hm_ritualStartTime==0)
    	 	 	{
				this.switchAnimation('mining');
				this.hm_ritualGapTime=gameManager.runningClock;
				this.hm_ritualStartTime=gameManager.runningClock;
				this.image_offset.y-=55*yscale;
    	 	 	}
    	 	 if(gameManager.runningClock - this.hm_ritualGapTime > this.hm_maxRitualGap)
    	 	 	{
    	 	 	 this.sx*=-1;
    	 	 	 this.hm_ritualGapTime=gameManager.runningClock;
    	 	 	 new ThornyBall(this.tgt.position.x,
 						   this.tgt.position.y-400*yscale,
 						   30*xscale,
 						   30*yscale,
 						   null,0,0,
 						   [gameManager.visible_sprites,gameManager.active_sprites],
 						   0,800
		 				         );
    	 	 	}
    	 	 
    	 	 if(gameManager.runningClock - this.hm_ritualStartTime > this.hm_maxRitualTime)
    	 	 	{
    	 	 	 this.switchAnimation('idle');
    	 	 	 this.state='miner_agro';
    	 	 	 this.hm_ritualGapTime=0;
				 this.hm_ritualStartTime=0;
				 this.image_offset.y=this.image_offset_fixed.y;
    	 	 	}
    	 	 
    	 	} 	
    	 hmAgro()
    	 	{
    	 	 if(!this.tgt.isActive)
    	 	 	return false;  
    	 	 if(!this.huskMusicStarted)
	    	 	 	{
	    	 	 	 this.huskMusicStarted= true;
	    	 	 	 pauseMusic();
	    	 	 	 capraMusic.src="./sounds/Capra.mp3";
	    	 	 	 capraMusic.play();
	    	 	 	}
    	 	 let playerSep=this.tgt.position.x - this.position.x;
    	 	 this.sx=Math.sign(playerSep);    	 	 
    	 	 if(Math.abs(playerSep) < this.minerPlayerFarDistance)
    	 	 	{
    	 	 	 if(gameManager.runningClock - this.minerLastAttackTime > this.minerMinAttackGap)
    	 	 	 	this.state= this.closeAttacks[Math.floor(Math.random()*this.closeAttacks.length)];
    	 	 	}
    	 	 else
    	 	 	this.state= this.longAttacks[Math.floor(Math.random()*this.longAttacks.length)];
    	 	}
    	 hmRunUp()
    	 	{
    	 	 this.switchAnimation('run');
    	 	 let playerSep=this.tgt.position.x - this.position.x;
    	 	 if(Math.abs(playerSep) > this.minerPlayerFarDistance)
    		 	this.acceleration.add(this.horiForce.copy().mult(this.sx*2)); 
    		 else
    		 	{
    		 	 this.velocity.x= 0;
    		 	 this.state= 'miner_slash';
    		 	 // this.switchAnimation('idle');
    		 	}
    	 	}
    	
    	 hmSlash()
    	 	{
    	 	 if(!this.minerAttackStarted && this.animation!='throwAnticipate' &&
    	 	 	 this.animation!='slash' && this.animation!='slashRecover'
    	 	 	)
    	 	 	{
    	 	 	 this.minerAttackStarted=true;
    	 	 	 this.switchAnimation('throwAnticipate');
    	 	 	 this.animInQueue='slash';	
    	 	 	}
    	 	 else if(this.animation=='slash' && this.animInQueue!='slashRecover')
    	 	 	{
    	 	 	 this.animInQueue='slashRecover';	
    	 	 	}
    	 	 else if(this.animation=='slashRecover' && this.animInQueue!='idle')
    	 	 	{
    	 	 	 this.animInQueue='idle';
    	 	 	}
    	 	 if(this.animation=='idle' && this.minerAttackStarted)
    	 	 	 {
    	 	 	 	this.state='miner_agro';
    	 	 	 	this.minerAttackStarted= false;
    	 	 	 	this.minerLastAttackTime= gameManager.runningClock;
    	 	 	 	this.minerHitBoxSpawned= false; 
    	 	 	 	this.axesThrown=0;
    	 	 	 }

    	 	}
    	 update()
    	 	{ 
             // return false;
    	 	 this.updateHealthBarPos();
    	 	 if(!this.hasCutScene && !this.isActive) return false;   	 	 
 			 this.move();    		   
    		 this.manageInvincibility();
    	 	 this.stateMachine();
    	 	}
    	 display()
    	 	{
		 	 if(!this.onScreen) return false;
		 	 this.runAnimation();
		 	 // console.log('here at 2976');
		 	 ctx.save();
		 	 ctx.translate(this.position.x-gameManager.camera.position.x, 
		 	 	 		   this.position.y-gameManager.camera.position.y);
		 	 ctx.rotate(d2r(this.angle));
		 	 ctx.scale(this.sx,this.sy);
		 	 if(this.flickerControl())
		 	 ctx.drawImage(this.animations[this.animation]['imgsheet'],
		 	 				this.startx,this.starty,this.imgWidth,this.imgHeight,
		 	 			   -this.width/2,
		 	 			   -this.height/2,
		 	 			   this.width*this.animations[this.animation]['width_extend'],
		 	 			   this.height*this.animations[this.animation]['height_extend']
		 	 			  );
		 	 // context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height);
		 	 ctx.restore();
		 	 w2screen(this.state,this.position.x-gameManager.camera.position.x,this.position.y-50*yscale-gameManager.camera.position.y);
    	 	}
    	runAnimation()
    		{
			  this.animationFrame+=this.animations[this.animation]['anim_speed'];
			  if(this.animationFrame >= this.animations[this.animation]['maxFrames'])
			  	{
		  		this.animationFrame=0;
		  		if(this.animInQueue) 
		  			{
		  			this.animation=this.animInQueue;
		  			//console.log('back to '+this.animation);
		  			this.animInQueue=null;
		  			}
			  	}
			  let rowIndex=parseInt(parseInt(this.animationFrame)/this.animations[this.animation]['cols']);
			  let colIndex=parseInt(this.animationFrame)%this.animations[this.animation]['cols'];
			  this.startx=colIndex * this.animations[this.animation]['width']/this.animations[this.animation]['cols'];
			  this.starty=rowIndex * this.animations[this.animation]['height']/this.animations[this.animation]['rows'];
			  this.imgWidth = this.animations[this.animation]['width']/this.animations[this.animation]['cols'];
			  this.imgHeight = this.animations[this.animation]['height']/this.animations[this.animation]['rows'];
			}
		switchAnimation(animx)
			{
			 if(this.animation != animx)
			 	{
			 	this.animationFrame=0;
			 	this.animation=animx;			 	
			 	}
			}

		 takeDamage(dmg,dir=0)
		 	{
		 	//this.acceleration.add(new CreateVector(dir,0));
            document.querySelector('#retroJump').play();
		 	if(this.invincibleState) return false;	
		 	this.invincibleState=true;	
	 		this.health-=dmg;
	 		this.minerHealthBar.updateValue(this.health);
	 		this.minerHealthBar.onScreen=true;
	 		if(this.health <= 5)
	 			{
	 			// capraMusic.src="";
	 			pauseBossMusic();
	 			pauseMusic();
	 			startMusic();
	 			fogGateSound.play();
	 			this.Burnbarriers();
	 			this.removeBars();
	 			this.tgt.giveExp(this.expVal);
	 			SpawnClouds(this.position);
	 			destroySelf(this);
	 			destroySelf(this.hit_box);
	 			destroySelf(this.minerHealthBar);
                gameManager.listOfDestroyedSprites.push(this.spriteId);	 			
	 			}	
		 	} 

    	}

    //messagebox starts
    class MessageBox 
        {
           constructor(parentgo,dialogue,promptMessage="press down arrow")
            {
                this.position=new CreateVector(parentgo.position.x+20*xscale,
                                               parentgo.position.y-70*yscale
                                               );                
                this.sprite_type="messagebox";
                this.dialogue=dialogue;
                this.width=240*xscale;
                this.height=120*yscale;
                this.di=0;
                this.coolDownTimer=0;
                this.dialogueStarted=false;
                this.promptMessage=promptMessage;
            } 
            displayPrompt(){
                w2screen(this.promptMessage,
                         this.position.x-gameManager.camera.position.x-110*xscale,
                         this.position.y-gameManager.camera.position.y-80*yscale,
                        );
            }
            displayDialogue(){
                for(let i=0;i<this.dialogue[this.di].length;i++)
                w2screen(this.dialogue[this.di][i],
                         this.position.x-gameManager.camera.position.x-110*xscale,
                         this.position.y-gameManager.camera.position.y+i*30*yscale,
                         '#FFFFFF',20
                         );
            }
            runCoolDown(){
                if(this.coolDownTimer==0) return;
                this.coolDownTimer+=deltaTime;
                // console.log(this.coolDownTimer);
                if(this.coolDownTimer > 1000){
                    this.coolDownTimer=0;                            
                }
            }
            listenForKeys()
             {
                if(this.coolDownTimer==0 && downArrow){
                    this.coolDownTimer=1;
                    if(!this.dialogueStarted){
                        this.dialogueStarted=true;
                        return;
                    }

                    this.di+=1;                    
                    if(this.di >= this.dialogue.length)
                        this.di=0;
                }
             }
             disable()
                {
                    this.dialogueStarted=false;
                    this.di=0;
                    this.coolDownTimer=0;
                    // console.log('disabled');
                }
            update()
             {
                this.runCoolDown();
                this.listenForKeys();
                return false;
             }
            display()
             {    
             if(!this.dialogueStarted)
                {
                 this.displayPrompt();
                 return;
                }         
             ctx.save();
             ctx.translate(this.position.x- gameManager.camera.position.x,
                           this.position.y- gameManager.camera.position.y);
             ctx.fillStyle="#604020";
             ctx.strokeStyle="#604020";
             ctx.beginPath();
             ctx.rect(-this.width/2,-this.height/2,this.width,this.height);          
             ctx.stroke();
             ctx.fill();
             
             ctx.restore();
             this.displayDialogue();
             }
        }
    //messagebox ends
    //husk miner ends
 
   
	class Husk
		{
		constructor(x,y,wid,hei,spriteGroups,dialogue,spriteId='husk0')
			{
			 this.position= new CreateVector(x,y);
             this.dialogue=dialogue;
             this.npc=dialogue.length!=0;
             this.messagebox=false;
             if(this.npc)
                this.messageBox=new MessageBox(this,this.dialogue);
			 this.permPosition= this.position.copy();
			 this.width = wid * xscale;
			 this.height= hei * yscale;
			 let folderPath='sprites/husk/';
			 this.onScreen= true;
			 this.isActive=true;
			 this.angle=0;
			 this.sx=1;
			 this.sy=1;
			 this.startx=0;
			 this.starty=0;
			 this.imgWidth=0;
			 this.imgHeight=0;
			 this.spriteId=spriteId;

			 this.acceleration=new CreateVector(0,0);
			 this.velocity=new CreateVector(0,0);
			 this.huskMaxHoriVelocity= 6;
			 this.maxVelocity=new CreateVector(6*xscale,12*yscale);		
			 this.horiForce=new CreateVector(1*xscale,0);	 
			 this.gravityScale=2*yscale;	
			 this.longRangeAttacks=['throw','rush'];	
			 this.expVal=200; 
			 this.soundPlayed=false;

			 this.animations={
			 	'walking':{'imgsheet':LoadImagex(folderPath,'WalkingSheet.png'),
			  		    'width':1906,
			  		    'height':678,			  		    
			  		    'rows':2,
			  		    'cols':6,
			  		    'maxFrames':8,
			  		    'width_extend':1,
			  		    'height_extend':1,
			  		    'anim_speed':0.2},
			 	'idle':{'imgsheet':LoadImagex(folderPath,'IdleSheet.png'),
			  		    'width':1584,
			  		    'height':348,			  		    
			  		    'rows':1,
			  		    'cols':5,
			  		    'maxFrames':5,
			  		    'width_extend':1,
			  		    'height_extend':1,'anim_speed':0.2},
			 	'attack0':{'imgsheet':LoadImagex(folderPath,'AttackAnticipate.png'),
			  		    'width':1950,
			  		    'height':464,			  		    
			  		    'rows':1,
			  		    'cols':5,
			  		    'maxFrames':5,
			  		    'width_extend':1,
			  		    'height_extend':1,'anim_speed':0.2},
			 	'attack1':{'imgsheet':LoadImagex(folderPath,'Attack.png'),
			  		    'width':1337,
			  		    'height':425,			  		    
			  		    'rows':1,
			  		    'cols':2,
			  		    'maxFrames':2,
			  		    'width_extend':1,
			  		    'height_extend':1,'anim_speed':0.2},
			 	'attack2':{'imgsheet':LoadImagex(folderPath,'AttackRecover.png'),
			  		    'width':1218,
			  		    'height':340,			  		    
			  		    'rows':1,
			  		    'cols':3,
			  		    'maxFrames':3,
			  		    'width_extend':1,
			  		    'height_extend':1,'anim_speed':0.2},
			 	'startle':{'imgsheet':LoadImagex(folderPath,'StartleSheet.png'),
			  		    'width':1464,
			  		    'height':357,			  		    
			  		    'rows':1,
			  		    'cols':4,
			  		    'maxFrames':4,
			  		    'width_extend':1,
			  		    'height_extend':1,'anim_speed':0.05}

			 };
			 this.animation='idle';
			 this.animInQueue=null;
			 this.animationFrame=0;			 
			 this.sprite_type='husk_sentry';
			 this.state=this.npc?'friendly':'idle';
			 this.raycastLength=320*xscale;
			 this.attackProxim=75*xscale;
			 this.playerOutDistance=500*xscale;
			 this.startled=false;
			 this.lastAttackTime=0;
			 this.maxAttackGap=500;
			 this.maxHealth=100;
			 this.health=this.maxHealth;
			 this.spriteGroups=spriteGroups;
			 for(let grp of spriteGroups)
			 	grp.push(this);
			 this.hit_box=new HitBox(x,y,this.width*0.5,this.height*0.5,[
			 	                                                        gameManager.collission_sprites
			 	                                                        // gameManager.active_sprites
			 	                                                        ],this,'huskhitbox');
			 this.image_offset=new CreateVector(0,-45*xscale);
			 this.huskHealthBar= new UIBar(0,0,100,15,this.health,this.maxHealth,'#222222','#FF0000',[gameManager.visible_sprites],false,'huskhealth');
			 this.huskHealthBar.onScreen=false;
			 this.uiBarTimer=0;
			 this.uiBarMaxTime=2000;
			 this.healthBarOffset=new CreateVector(-30*xscale,-150*yscale);
			 this.hitBoxSpawned=false;
			 if(gameManager.player)
			 	this.tgt= gameManager.player;	

			 this.invincibleState=false;
		 	 this.invin_count=0;
		 	 this.max_invin_time=500;
		 	 this.flickerCount=0;
			 this.maxFlickerTime=100;

			 this.longAttackCount=0;
			 this.maxLongAttackCount=1500;		
			 this.meleeOver=false;
			 this.waitTimerMeleeEnd=0;
			 this.maxWaitTimeAfterMelee=500; 

			 this.initSetupDone=false;
		 	 this.maxRushTime=1500;
		 	 this.retreatDirSet=false;
             this.foundTime=0;
             this.playerInView=false;
			}

		manageInvincibility()
			{
			if(!this.invincibleState) return false;
			this.invin_count+= deltaTime;
			if(this.invin_count > this.max_invin_time)
				{
				 this.invin_count=0;
				 this.invincibleState=false;
				} 
			}

		flickerControl()
			{
			  if(!this.invincibleState) return true;
			  this.flickerCount+=deltaTime;
			  if(this.flickerCount > this.maxFlickerTime)
			  	{
			  	 this.flickerCount=0;
			  	 return true;
			  	}
			  return false;
			}
		updateHealthBarPos()
			{
				if(this.huskHealthBar.onScreen)
					{	
					this.uiBarTimer+=deltaTime;
					if(this.uiBarTimer > this.uiBarMaxTime)
					{
					 this.uiBarTimer=0;
					 this.huskHealthBar.onScreen=false;
					}
					}
				this.huskHealthBar.position.setVec(this.position.copy().add(this.healthBarOffset));
			}
		switchAnimation(animx)
			{
			 if(this.animation != animx)
			 	{
			 	this.animationFrame=0;
			 	this.animation=animx;			 	
			 	}
			}

		 update_and_display_hitbox()
		 	{
	 		// this.hit_box.updatePosition(this.position.copy().add(this.hit_box_offset));
	 		this.position.setVec(this.hit_box.position.copy().add(this.image_offset));
		 	}
		 takeDamage(dmg,dir=0)
		 	{
		 	//this.acceleration.add(new CreateVector(dir,0));
            if(this.state=="friendly") this.state="idle";
		 	if(this.invincibleState) return false;	
		 	this.invincibleState=true;	
	 		this.health-=dmg;
            document.querySelector('#retroJump').play();
	 		this.huskHealthBar.updateValue(this.health);
	 		this.huskHealthBar.onScreen=true;
	 		if(this.health<=0)
	 			{
	 			if(this.tgt)
	 				{
	 				this.tgt.giveExp(this.expVal);
	 				this.tgt.inEnemyRadar=false;
	 				}
	 			SpawnClouds(this.position);
	 			destroySelf(this);
	 			destroySelf(this.hit_box);
	 			destroySelf(this.huskHealthBar);
	 			gameManager.listOfDestroyedSprites.push(this.spriteId);
	 			this.isActive=false;
	 			}	
		 	}

		fallDamage()
			{
			  if(Math.abs(this.position.y-gameManager.bottomY > canvas.height*2))
			  	{

	 			// SpawnClouds(this.position);
	 			// destroySelf(this);
	 			// this.isActive=false;
	 			this.takeDamage(this.health*2);
	 			console.log(this.sprite_type+' reports fall damage!!!');
	 			}	
			}

		huskJump()
			{
			 let jumpForce= new CreateVector(this.sx* 10*xscale,-250*yscale);
			 if(!this.jumpForceApplied_husk)
			 	{
			 	this.jumpForceApplied_husk= true;
			 	this.acceleration.add(jumpForce);
			 	this.animInQueue='idle';
			 	this.switchAnimation('startle');
			 	this.startTimeHusk= gameManager.runningClock;	
			 	}
			 else if(gameManager.runningClock - this.startTimeHusk > 1000)
			 	{
			 		this.state='agro';
			 		this.velocity.x=0;
			 		this.jumpForceApplied_husk=false;
			 	}	

			}
		checkJumpPos()
			{
			 for(let sp of gameManager.markedSpots)
    		 	{
    		 	  if(sp.sprite_type=="fkjumpup" &&  b_collision(this.hit_box,sp))
    		 	  	{
    		 	  	this.velocity.x=0;
    		 	 	this.state='huskJump';

    		 	  	}
    		 	}
			}

		stateMachine()
			{
              switch(this.state)
               {
               	case 'idle':
               		this.IdleBehav();
               		break;
                case 'friendly':
                    this.FriendlyBehav();
                    break;
               	case 'agro':
               		this.AgroBehav();
               		break;
               	case 'attack':
               		this.Melee();
               		break;
               	case 'throw':
               		this.Throw();
               		break;
               	case 'rush':
               	    this.Rush();
               	    break;
               	case 'retreat':
               		this.RetreatBehav();
               		break;
               	case 'huskJump':
               		this.huskJump();
               		break;
               	default:
               		break;
               }
			} 
		 spawnHitBoxOnSlashHusk()
		 	{		 	
	 		if(this.animation=="attack2" && parseInt(this.animationFrame)==1 && !this.hitBoxSpawned)
	 			{
	 			this.hitBoxSpawned=true;
	 			let hbWidthRatio=0.6;
	 			let hbHeightRatio=1;
	 			if(this.state=="rush")
	 				{
	 				 hbWidthRatio=1;
	 				 hbHeightRatio=1;	 				 
	 				}
	 			if(this.state=="attack" || this.state=="rush")
		 			new DamageHitBox(this.position.x,
		 							 this.position.y,
		 							 this.width*hbWidthRatio,
		 							 this.height*hbHeightRatio,
		 							 [gameManager.active_sprites,gameManager.hitbox_sprites],
		 							 'enemy_hitbox',
		 							 this,
		 							 70,0,90,this.sx*1.5);//changed	
		 		else if(this.state=='throw')
		 			{		 			
		 			new ThornyBall(this.position.x,
		 						   this.position.y,
		 						   30*xscale,
		 						   30*yscale,
		 						   this,70*xscale,0,
		 						   [gameManager.visible_sprites,gameManager.active_sprites]
		 				          );
		 			}

	 			}
	 		else if(this.animation!="attack2" && this.hitBoxSpawned)
	 			this.hitBoxSpawned=false;
		 	}

		SpawnAttackSequence()
			{
			if(this.animation!='attack0' && this.animation!='attack1' && this.animation!='attack2' && !this.meleeOver)
			 	{
			 	 this.animInQueue='attack1';
			 	 this.switchAnimation('attack0');
			 	 return true;
			 	}
			 else if(this.animation=="attack1" && this.animInQueue!="attack2")
			 	{
			 	this.animInQueue="attack2";		
			 	return true;	 		
			 	}
			 else if(this.animation=="attack2")
			 	{
			 	if(this.animationFrame>= this.animations["attack2"]["maxFrames"]-1)
			 		{
			 		this.switchAnimation('idle');
			 		this.meleeOver=true;
			 		return false;
			 		}
			 	return true;
			 	}
			 return true;
			}

		Rush()
			{
			 //constructor(x,y,wid,hei,spriteGroups,hitboxName="unknown hitbox",parentx,xoffset,yoffset,dmg=10,dmghitback=0)
			 if(!this.soundPlayed)
			 	{
			 	 document.querySelector('#whoosh').play();
			 	 this.soundPlayed=true;
			 	}
			 this.SpawnAttackSequence();
			 if(this.meleeOver)
			 	{
			 	 this.performPostRushRitual();
			 	 return true;
			 	}
			 
			 if(!this.initSetupDone)
			 	{
			 	 this.initSetupDone=true;
			 	 this.maxVelocity.x=30*xscale;			 	 
			 	}
			 this.acceleration.add(this.horiForce.copy().mult(this.sx*5));

			 this.waitTimerMeleeEnd+=deltaTime;
			 if(this.waitTimerMeleeEnd > this.maxRushTime || this.PlayerDetected(this.sx,30*xscale) )
			 	{			 	 
			 	this.velocity.x=0;
			 	this.waitTimerMeleeEnd=0;	
			 	this.meleeOver=true;		 	
			 	}			 
			}
		performPostRushRitual()
			{
			 this.velocity.x=0;	
			 if(this.animation.substring(0,this.animation.length-1)!="attack")
			 	{
			 	
			 	this.switchAnimation('idle');			 	
			    }
			 this.waitTimerMeleeEnd+=deltaTime;
			 if(this.waitTimerMeleeEnd > this.maxWaitTimeAfterMelee)
			 	{
			 	 this.RecoverFromRush();
			 	}
			}
		RecoverFromRush()
			{
			 this.maxVelocity.x=this.huskMaxHoriVelocity;
			 this.initSetupDone=false;			 
			 this.waitTimerMeleeEnd=0;			
			 // this.velocity.x=Lerp(this.velocity.x,0,2*xscale);	
			 this.velocity.x=0;
			 this.state='agro';

			 this.soundPlayed=false;
			 this.meleeOver=false;
			}
		IdleBehav()
			{
			  this.velocity.x=Lerp(this.velocity.x,0,2);	
			  this.switchAnimation('idle');

			  if(this.PlayerDetected(1))
			  	{
		  		this.state='agro';
		  		this.sx=1;
			  	}
			  else if(this.PlayerDetected(-1))
			  	{
		  		this.state='agro';
		  		this.sx=-1;
			  	}
			}
			
			
			
        FriendlyBehav()
            {
             this.velocity.x=Lerp(this.velocity.x,0,2);
             this.switchAnimation('idle');
             if(gameManager.runningClock - this.foundTime < 2000){
                this.messageBox.update();
                this.messageBox.display();
             }             
             if(this.PlayerDetected(1,this.raycastLength*0.5))
                {  
                this.foundTime=gameManager.runningClock;              
                this.sx=1;                
                if(!this.playerInView)
                	{
                	  // document.querySelector('#cornifer').play();
                	  playRandomCornifer();
                	  this.playerInView=true;                	  
                	}                
                }
              else if(this.PlayerDetected(-1,this.raycastLength*0.5))
                {  
                this.foundTime=gameManager.runningClock;              
                this.sx=-1;                
                if(!this.playerInView)
                	{
                	  // document.querySelector('#cornifer').play();
                	  playRandomCornifer();
                	  this.playerInView=true;                	  
                	} 
                }
              else if(this.messageBox.dialogueStarted &&  gameManager.runningClock - this.foundTime> 2000)
              	{
                this.messageBox.disable();
                this.playerInView=false;                
              	}
            }
		
		RetreatBehav()
			{
			if(!this.retreatDirSet)
				{
				 this.sx= Math.sign(this.permPosition.x - this.position.x);
				 this.retreatDirSet= true;
				}
			else
				{
				 if(Math.abs(this.permPosition.x - this.position.x)<5*xscale)
				 	{
				 	 this.retreatDirSet= false;
				 	 this.state='idle';
				 	}
				}
			this.switchAnimation('walking');
 			this.acceleration.add(this.horiForce.copy().mult(this.sx));	
			}

		AgroBehav()
			{
            if(!gameManager.player || !gameManager.player.isActive) return;
			if(!gameManager.player.inEnemyRadar)
				gameManager.player.inEnemyRadar=true;
			if(!this.startled)
				{					
				 this.startled=true;
				 this.animInQueue='idle';
				 this.switchAnimation('startle');
				}
		
			if(this.PlayerInHitRange())
				{				
				if(gameManager.runningClock - this.lastAttackTime > this.maxAttackGap)
					{
					 this.velocity.x=Lerp(this.velocity.x,0,2*xscale);	
					 this.state='attack';
					 //remember to reset lastAttackTime
					}
				if(this.longAttackCount!=0) this.longAttackCount=0;
				}
			else if(this.animation!='startle')
				{		
                 // this.lastAttackTime=gameManager.runningClock;		
				 this.switchAnimation('walking');
 				 this.acceleration.add(this.horiForce.copy().mult(this.sx));
 				 this.checkJumpPos();
 				 this.longAttackCount+=deltaTime;
 				 if(this.longAttackCount > this.maxLongAttackCount)
 				 	{
 				 	 this.state=this.longRangeAttacks[Math.floor(Math.random()*this.longRangeAttacks.length)]
 				 	 this.longAttackCount=0;
 				 	}
				}
			//earlier, Math.abs(this.position.x - this.tgt.position.x) > this.playerOutDistance
			if(!this.tgt || this.StrayedTooFar())
				{
				 this.startled=false;				 
				 this.state='retreat';
				 this.longAttackCount=0;
				}

			}
		StrayedTooFar()
			{
			  for(let mspot of gameManager.markedSpots)
			  {			  	
			  	if(mspot.sprite_type!='enemystopleft' &&
			  	   mspot.sprite_type!='enemystopright'
			  	   ) continue;			  	
			  	if(mspot.sprite_type=='enemystopright')
			  		{
			  		 if(this.position.x > mspot.position.x) return true;
			  		}
			  	else
			  		{			  		
					if(this.position.x < mspot.position.x) return true;
			  		}
			  }
			  return false;
			}
		Throw()
			{			 
			 this.velocity.x=Lerp(this.velocity.x,0,2*xscale);
			 this.Melee();
			}

		Melee()
			{
			 if(!this.soundPlayed)
			 	{
			 	 document.querySelector('#whoosh').play();
			 	 this.soundPlayed=true;
			 	 this.velocity.x=0;
			 	}
			 if(this.meleeOver)
			 	{
			 	 this.performPostMeleeRitual();
			 	 return true;
			 	}
			 if(this.animation!='attack0' && this.animation!='attack1' && this.animation!='attack2')
			 	{
			 	 this.animInQueue='attack1';
			 	 this.switchAnimation('attack0');
			 	 // document.querySelector('#RockSmash').play();
			 	}
			 else if(this.animation=="attack1" && this.animInQueue!="attack2")
			 	{
			 	this.animInQueue="attack2";	
			 			 		
			 	}
			 else if(this.animation=="attack2")
			 	{
			 	if(this.animationFrame>= this.animations["attack2"]["maxFrames"]-1)
			 		this.meleeOver=true;
			 		// this.WrapUpMelee();
			 	}
			}
		performPostMeleeRitual()
			{
			 this.switchAnimation('idle');
			 this.waitTimerMeleeEnd+=deltaTime;
			 if(this.waitTimerMeleeEnd > this.maxWaitTimeAfterMelee)
			 	{
			 	 this.WrapUpMelee();
			 	}
			}
		WrapUpMelee()
			{
			 this.lastAttackTime=gameManager.runningClock;
			 this.state='agro';
			 this.switchAnimation('idle');
			 this.meleeOver=false;
			 this.waitTimerMeleeEnd=0;
			 this.soundPlayed=false;
			}
		PlayerInHitRange()
			{
			  if(!this.tgt) return false;
			  let playerSep= this.tgt.position.x - this.position.x;
			  if(this.sx==1 && playerSep < 0) this.sx=-1;
			  else if(this.sx==-1 && playerSep > 0) this.sx=1;			  
			  if(Math.abs(playerSep) < this.attackProxim)
			  	{
			  	// console.log(`player seperation:${playerSep}, and attack proxim:${this.attackProxim} returning true`);
			  	return true;
			    }
			  // console.log(`player seperation:${playerSep}, and attack proxim:${this.attackProxim}  returning false`);
			  return false;
			}
		PlayerDetected(n,dist=this.raycastLength)
			{
			  if(!this.tgt) return false;
	          let offsets=[-40*yscale,0,40*yscale];
	          for(let offset of offsets)
	          	{
	      		let yoffset=new CreateVector(0,offset);
	      		if(Raycast(this.position.copy().add(yoffset),new CreateVector(n,0),dist,this.tgt))
	      			return true;
	          	}
	          return false;
			}
		 applyGravity()
		 	{
		 	 this.acceleration.y+=this.gravityScale;
		 	}
		 checkTarget()
		 	{
		 	 if(this.tgt && !this.tgt.isActive)
		 	 	this.tgt=null;
		 	}
		 move()
		 	{		
		 	 this.applyGravity(); 	 
		 	 this.velocity.add(this.acceleration);
		 	 this.acceleration.set(0,0);		 	
		 	 this.applyVelocity();
		 	 this.applyVelocityRestrictions();
		 	 this.update_and_display_hitbox();
		 	 this.spawnHitBoxOnSlashHusk();
		 	 this.checkTarget();
		 	 this.manageInvincibility();
		 	}
		 applyVelocity()
		 	{		 	 	 	 
		 	 this.hit_box.position.x+=this.velocity.x;		 	
		 	 for(let x of gameManager.collission_sprites)
		 	 	{
		 	 	 if(!x.onScreen) continue;
		 	 	 if(x==this.hit_box) continue;
		 	 	 
		 	 	 if(b_collision(this.hit_box,x)) 
		 	 	 	{
		 	 	 	
		 	 	 	 if(this.velocity.x > 0)
		 	 	 	 	this.hit_box.position.x=x.position.x-x.width/2-this.hit_box.width/2-2;
		 	 	 	 else 
		 	 	 	 	this.hit_box.position.x=x.position.x+x.width/2+this.hit_box.width/2+2;
		 	 	 	}	
		 	 	 /*delete this snippet 	 
		 	 	 else if(x.sprite_type == 'playerhitbox')
		 	 	 	{
		 	 	 		console.log('no collision');
		 	 	 		console.log(`${this.hit_box.position.x},${this.hit_box.position.y}__${this.hit_box.width},${this.hit_box.height}`);
		 	 	 		console.log(`${x.position.x},${x.position.y}__${x.width},${x.height}`);
		 	 	 	}*/
		 	 	}

		 	 this.hit_box.position.y+=this.velocity.y;
		 	 for(let x of gameManager.collission_sprites)
		 	 	{
		 	 	 if(!x.onScreen) continue;
		 	 	 if(x==this.hit_box) continue;
		 	 	 if(b_collision(this.hit_box,x)) 
		 	 	 	{
		 	 	 	
		 	 	 	if(this.velocity.y > 0)
		 	 	 		this.hit_box.position.y=x.position.y-x.height/2-this.hit_box.height/2-2;
		 	 	 	else
		 	 	 		this.hit_box.position.y=x.position.y+x.height/2+this.hit_box.height/2+2;	
		 	 	 	}
		 	 	}
		 	}
		 applyVelocityRestrictions()
		 	{
		 	 let xdir=this.velocity.x/Math.abs(this.velocity.x);
		 	 let ydir=this.velocity.y/Math.abs(this.velocity.y);
		 	 if(Math.abs(this.velocity.y) > this.maxVelocity.y)
		 	 	this.velocity.y=ydir*this.maxVelocity.y;
		 	 if(Math.abs(this.velocity.x) > this.maxVelocity.x)
		 	 	this.velocity.x=xdir*this.maxVelocity.x;
		 	}

		runAnimation()
			{
			  this.animationFrame+=this.animations[this.animation]['anim_speed'];
			  if(this.animationFrame >= this.animations[this.animation]['maxFrames'])
			  	{
		  		this.animationFrame=0;
		  		if(this.animInQueue) 
		  			{
		  			this.animation=this.animInQueue;
		  			//console.log('back to '+this.animation);
		  			this.animInQueue=null;
		  			}
			  	}
			  let rowIndex=parseInt(parseInt(this.animationFrame)/this.animations[this.animation]['cols']);
			  let colIndex=parseInt(this.animationFrame)%this.animations[this.animation]['cols'];
			  this.startx=colIndex * this.animations[this.animation]['width']/this.animations[this.animation]['cols'];
			  this.starty=rowIndex * this.animations[this.animation]['height']/this.animations[this.animation]['rows'];
			  this.imgWidth = this.animations[this.animation]['width']/this.animations[this.animation]['cols'];
			  this.imgHeight = this.animations[this.animation]['height']/this.animations[this.animation]['rows'];
			}
		 update()
		 	{

		 	  this.runAnimation();
		 	  this.stateMachine();
		 	  this.move();
		 	  this.updateHealthBarPos();
		 	  this.fallDamage();
		 	}
		 display()
		 	{		 	 
		 	 if(!this.onScreen) return false;
		 	 ctx.save();
		 	 ctx.translate(this.position.x-gameManager.camera.position.x, 
		 	 	 		   this.position.y-gameManager.camera.position.y);
		 	 ctx.rotate(d2r(this.angle));
		 	 ctx.scale(this.sx,this.sy);
		 	 if(this.flickerControl())
		 	 ctx.drawImage(this.animations[this.animation]['imgsheet'],
		 	 				this.startx,this.starty,this.imgWidth,this.imgHeight,
		 	 			   -this.width/2,
		 	 			   -this.height/2,
		 	 			   this.width*this.animations[this.animation]['width_extend'],
		 	 			   this.height*this.animations[this.animation]['height_extend']
		 	 			  );
		 	 // context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height);
		 	 ctx.restore();
		 	}
		}

    

	class UIBar
		{
		constructor(x,y,wid,hei,val,maxVal,backgroundColor,mainColor,spriteGroups,screenOverlay=true,sprite_type="un_uibar")
			{
			 this.position = new CreateVector(x,y);
			 this.width = wid * xscale;
			 this.height = hei * yscale;
			 this.fixedWidth= this.width;
			 this.onScreen = true;
			 // this.backgroundColor='#222222';
			 this.backgroundColor = backgroundColor;
			 this.mainColor = mainColor;
			 this.val = val;
			 this.maxVal = maxVal;
			 this.fixedMaxVal=maxVal;
			 this.spriteGroups=spriteGroups;
			 for(let grp of this.spriteGroups)
			 	grp.push(this);
			 this.screenOverlay=screenOverlay;
			 this.sprite_type=sprite_type;
			}
		setValues(val,maxVal)
			{
			 this.val = val;
			 this.maxVal = maxVal;
			 if(this.maxVal > this.fixedMaxVal)
			 	this.width=this.fixedWidth*this.maxVal/this.fixedMaxVal;
			}
		updateValue(val)
			{
			 this.val=val;
			}
		 display()
		 	{	
		 	 let camx=0,camy=0;
		 	 if(!this.screenOverlay)
		 	 	{
		 	 	 camx=gameManager.camera.position.x;
		 	 	 camy=gameManager.camera.position.y;
		 	 	}	 	 
		 	 if(!this.onScreen) return false;
		 	 ctx.save();
		 	 ctx.translate(this.position.x-camx,this.position.y-camy);
		 	 // ctx.rotate(d2r(this.angle));
		 	 // ctx.scale(this.sx,this.sy);
		 	 ctx.beginPath();
		 	 ctx.fillStyle=this.backgroundColor;
		 	 ctx.strokeStyle=this.backgroundColor;
		 	 ctx.lineWidth="6";
		 	 ctx.rect(0,0,this.width,this.height);
		 	 ctx.fill();
		 	 ctx.stroke();
		 	 ctx.beginPath();
		 	 ctx.fillStyle=this.mainColor;
		 	 ctx.strokeStyle=this.backgroundColor;
		 	 ctx.lineWidth="6";
		 	 ctx.rect(0,0,this.width*this.val/this.maxVal,this.height);
		 	 ctx.fill();
		 	 ctx.restore(); 
		 	}
		 update()
		 	{
		 	 return false;
		 	}
		}
    function DestroyAllBarriersInScene(){
        let arr=[];
        for(let x of gameManager.visible_sprites)        
            if(x.sprite_type=="barrierTree")
                arr.push(x);
        for(let elem of arr){
            elem.burn();
        }
        
    }
	class BarrierTree
		{
		 constructor(x,y,wid,hei,spriteGroups)
		 	{		 	 
		 	 this.position=new CreateVector(x,y);
		 	 this.width=wid;
		 	 this.height=hei;
		 	 this.spriteGroups=spriteGroups;
		 	 for(let grp of this.spriteGroups)
			 	grp.push(this); 
			 this.onScreen=true;
			 this.angle=0;
			 this.imgx=LoadImagex('sprites/misc/','Tree.png');
			 this.sprite_type='barrierTree';
			 this.hit_box=new HitBox(x,y,this.width*0.3,this.height*0.9,[gameManager.collission_sprites,
			 														     // gameManager.visible_sprites                                                
			 	                                                        ],this,'treehitbox');
		 	}
		 burn()
		 	{
		 		destroySelf(this.hit_box);
		 		destroySelf(this);

                for(let i=0;i<1;i++)
                    SpawnClouds(this.position);
		 	}
		 display()
		 	{
		 	 if(!this.onScreen) return false;		 	 
		 	 ctx.save();
		 	 ctx.translate(this.position.x-gameManager.camera.position.x, 
		 	 	 		   this.position.y-gameManager.camera.position.y);
		 	 // ctx.rotate(d2r(this.angle));
		 	 ctx.drawImage(this.imgx,-this.width/2,-this.height/2,this.width,this.height);
		 	 ctx.restore();	
		 	}
		  update()
		  	{
		  	 return false;
		  	}
		}

    class BossFightTriggGO
    	{
    	 constructor(x,y,mywidth,myheight,br1posx,br1posy,br2posx,br2posy,spriteGroups,spriteId)
    	 	{
    	 	  // console.log(`${x},${y}`);
    	 	  this.position=new CreateVector(x,y);
    	 	  this.width=mywidth;
    	 	  this.height=myheight;
    	 	  this.br1pos=new CreateVector(br1posx,br1posy);
    	 	  this.br2pos=new CreateVector(br2posx,br2posy);     	 	  	 	  
    	 	  this.spriteGroups=spriteGroups;
    	 	  for(let grp of this.spriteGroups)
			 	grp.push(this); 
			  this.onScreen=true;
			  this.triggered=false;
			  this.spriteId=spriteId;
			  this.sprite_type="BossFightTriggGO";
			  this.angle=0;
			  this.tree1=null;
			  this.tree2=null;
    	 	}
    	 bossHasDiedRemoveBars()
    	 	{
    	 		this.tree1.burn();
    	 		this.tree2.burn();
    	 		destroySelf(this);
    	 	}
         spawnTrees()
            {
              SpawnClouds(this.br1pos.x+this.position.x,this.br1pos.y+this.position.y);
              SpawnClouds(this.br2pos.x+this.position.x,this.br2pos.y+this.position.y);
              this.tree1= new BarrierTree(this.br1pos.x+this.position.x,
                               this.br1pos.y+this.position.y,
                               630*xscale,955*yscale,
                               [gameManager.visible_sprites]
                              );
                this.tree2= new BarrierTree(this.br2pos.x+this.position.x,
                               this.br2pos.y+this.position.y,
                               630*xscale,955*yscale,
                               [gameManager.visible_sprites]
                              );  
            }
         triggerOnRequest(go)
            {
             if(!this.triggered && go.spriteId && go.spriteId.split('_')[0]=='boss')
                {
                this.triggered=true;             
                this.spawnTrees();
                }
            }
    	 update()
    	 	{    	 	 
    	 	  if(!this.triggered && b_collision(this,gameManager.player))
    	 	  {
               if(this.activateBosses())
                    {
        	 	   this.triggered=true;    	 	   
        	 	   this.tree1= new BarrierTree(this.br1pos.x+this.position.x,
        	 	   				   this.br1pos.y+this.position.y,
        	 	   				   630*xscale,955*yscale,
        	 	   				   [gameManager.visible_sprites]
        	 	   				  );
        	 	   this.tree2= new BarrierTree(this.br2pos.x+this.position.x,
        	 	   				   this.br2pos.y+this.position.y,
        	 	   				   630*xscale,955*yscale,
        	 	   				   [gameManager.visible_sprites]
        	 	   				  ); 
                    }

    	 	  }
    	    }
         activateBosses()
            {
            for(let go of gameManager.visible_sprites)
               {
                if(go.spriteId && go.spriteId.split('_')[0]=='boss')
                    {
                    go.isActive=true;
                    go.onScreen=true;
                    return true;
                    }
               }
             return true;  
            }
    	 display()
    	 	{
    	 	 if(!this.onScreen)
    	 	 	return false;
    	 	 ctx.save();
    	 	 ctx.translate(
    	 	 	           this.position.x - gameManager.camera.position.x,
    	 	 	           this.position.y - gameManager.camera.position.y
    	 	 	          );
    	 	 ctx.fillStyle="#b3ffff";
    	 	 ctx.strokeStyle="#b3ffff";
    	 	 ctx.beginPath();
    	 	 ctx.rect(-this.width/2,-this.height/2,this.width,this.height);
    	 	 ctx.stroke();
    	 	 ctx.fill();
    	 	 ctx.restore();
    	 	}
    	}


	class Player
		{
		constructor(x,y,wid,hei,spriteGroups)
			{
			 this.position=new CreateVector(x,y);
			 this.width=wid*xscale;
			 this.height=hei*yscale;
			 this.numJumps=0;
             this.casting=false;
             this.lastSlash=1;
             /*
			 let idle_images=Array(10).fill(0).map((x,i)=>'E_E_Sword__Idle_00'+i+'.png');
			 let run_images= Array(10).fill(0).map((x,i)=>'E_E_Sword__Run_00'+i+'.png');
			 let slash_images=Array(10).fill(0).map((x,i)=>'E_E_Sword__Attack_00'+i+'.png');
			 let folderPath='sprites/protagonist/';
			 this.animations={'idle':LoadImages(folderPath+'Idle',idle_images),
			 				  'run' :LoadImages(folderPath+'Run',run_images),
			 				  'slash':LoadImages(folderPath+'Slash',slash_images)
							 };
             */
             let idle_images=Array(5).fill(0).map((x,i)=>'Idle'+(i+1)+'.png');
             let run_images= Array(6).fill(0).map((x,i)=>'Run'+(i+1)+'.png');
             let slash_images=Array(8).fill(0).map((x,i)=>'Attack'+(i+1)+'.png');
             let slash_images2=Array(11).fill(0).map((x,i)=>i+'.png');
             let death_images=Array(6).fill(0).map((x,i)=>i+'.png');
             let folderPath='sprites/sturdyFool/';
             this.animations={'idle':LoadImages(folderPath+'Idle',idle_images),
                              'run' :LoadImages(folderPath+'Run',run_images),
                              'slash':LoadImages(folderPath+'Attack',slash_images),
                              'slash2':LoadImages(folderPath+'Attack2',slash_images2),
                              'death':LoadImages(folderPath+'Death',death_images)
                             };
			 this.healFlash= LoadImages('sprites/protagonist',['drinkup.png'])[0];
			 this.animationFractions={'idle':0.4,'run':0.4,'slash':0.3,'slash2':0.2,'death':0.2};
			 this.animation='idle';
			 this.animationFrame=0;
			 this.animInQueue=null;
			 this.onScreen=true;
			 this.isActive=true;
			 this.sprite_type='player';
			 this.spriteGroups=spriteGroups;
			 for(let grp of spriteGroups)
			 	grp.push(this);
			 this.angle=0;
			 this.acceleration=new CreateVector(0,0);
			 this.velocity=new CreateVector(0,0);
			 this.maxHoriVel_player=6*xscale;
             this.maxVertVel_player=20*yscale;
             this.maxVertVel_player_sliding=6*yscale;
             this.IsInContactWithWallVar=0;
			 this.maxVelocity=new CreateVector(this.maxHoriVel_player,this.maxVertVel_player);
             this.gravityScale=1*yscale;
            //vars introduced on 07-05-2023 cntrl-F date to see details
             this.jumpingForce_onfirst_jump=3*this.gravityScale;
             this.jumpingForce_onsecond_jump=3*this.gravityScale;
             this.maxJumpTime_onfirst_jump=300;
             this.maxJumpTime_onsecond_jump=200;
             //vars introduced on 07-05-2023 cntrl-F date to see details ends
			 this.horiForce=new CreateVector(0.8*xscale,0);
             /*
             this.manual_velocity=new CreateVector(0,0);
             this.manual_horizontal_velocity=5*xscale;
             //defunct for the moment
             */
             this.wallForceWhileJumping=new CreateVector(2*xscale,0);
			 
             this.isOnContactWithGround=true;
			 this.sx=1;
			 this.sy=1;

			 this.jumpingForce=3.5*this.gravityScale;
			 this.spaceTrigger=true;
			 this.jumping=false;
			 this.jumpTimer=0;
			 this.maxJumpTime=250;


			 this.sideWaysShift=40*xscale;
		 	 this.downCheckRaycast=80*yscale;
		 	 this.slashTrigger=true;
             this.slashTrigger2=true;
		 	 // gameManager.camera.tgt=this;

		 	 this.health=100;
		 	 this.maxHealth=100;
		 	 this.hitBoxSpawned=false;
		 	 this.weaponDamage=10;
		 	 this.energy = 100;
		 	 this.maxEnergy=100;             
		 	 this.energyRefillRate=0.25
		 	 this.energyDepleteRate=10;
             this.hitCredit=100;
             this.maxHitCredit=100;
		 	 this.energyCosts={"slash":5,"jump":0};

		 	 gameManager.playerHealthBar.setValues(this.health,this.maxHealth);
		 	 gameManager.playerEnergyBar.setValues(this.hitCredit,this.maxHitCredit);

		 	 this.hit_box=new HitBox(x,y,this.width*0.5,
		 	 	                         this.height,
		 	 	                         [gameManager.collission_sprites		 	 	                          
		 	 	                         ],this,
		 	 	                         'playerhitbox');
		 	 this.invincibleState=false;
		 	 this.invin_count=0;
		 	 this.max_invin_time=2000;
		 	 this.flickerCount=0;
			 this.maxFlickerTime=100;
			 this.experience=100;
			 this.expNeeded=10;
		     this.healing=false;
		     this.lastHealTime=0;
		     this.healCoolDown=2000;
			 this.healTimeMax=3000;
			 this.healDelta=100;
			 this.flashOn=true;
			 this.healTimer=0;
			 this.healTimer2=0;
			 this.soundPlayed=false;
		 	 // this.damHitBox = new DamageHitBox(x-100,y,this.width*0.2,this.height*0.2,[gameManager.visible_sprites],'sample',this,70,0);
		 	 this.dashing=false;
		 	 this.dashStartTime=0;
		 	 this.maxDashTime=200;
		 	 this.dashSpeed=40*xscale;
		 	 this.dashStarted=false;	
		 	 this.reverseDashing=false;	 

		 	 this.inEnemyRadar=false;
             this.gravitySwitchedOff=false;
             this.gravityPauseTime=0;

             this.maxParamChangeTime=2000;
             this.parameterChangedClock=0;	
             // this.wallContacted=false;
             this.firstStruck=false;
             this.struckTime=0;
             this.slashQueue=[];
             this.slashQueueFull=false;
             this.onAir=false;
             // this.startExhausting=false;
			}
        //delete this block after implementing chaining    
		ResetFirstStruck(){
            if(this.lastSlash==1) return;
            if(gameManager.runningClock-this.struckTime > 1000) this.lastSlash=1;            
        }
        RecordFirstStrike(){
            this.struckTime=gameManager.runningClock;
            this.lastSlash=0;
        }
        //delete this block ends
        CheckIfIsInContactWithWall()
            {
                for(let x of gameManager.wall_grippers)
                    {
                     if(b_collision(this.hit_box,x))
                        {    
                         if(this.IsInContactWithWallVar==0)
                            {                               
                            this.IsInContactWithWallVar=Math.sign(x.position.x-this.position.x);
                            this.velocity.y=0;
                            this.maxVelocity.y=this.maxVertVel_player_sliding;	
                            
                            }                                              
                         return true;   
                        } 
                    }

                this.IsInContactWithWallVar=0;
                this.maxVelocity.y=this.maxVertVel_player;               
                return false;
            }

        fillHitCredits(){
            if(this.hitCredit >= this.maxHitCredit) 
                return;
            this.hitCredit+=30;
            if(this.hitCredit > this.maxHitCredit) this.hitCredit=this.maxHitCredit;
            gameManager.playerEnergyBar.updateValue(this.hitCredit);
        }
        hasEnoughCredits(){
            if(this.hitCredit < 20) return false;
            this.hitCredit-=15;
            if(this.hitCredit<0) this.hitCredit=0;
            return true;
        }
		handleHealing()
			{
			 if(gameManager.runningClock - this.lastHealTime < this.healCoolDown)
			 	return false;
			 if(GetKeyPressedx(gameManager.healKey))
			 	{
			 	 if(!this.healing)	 this.healing=true;			 	 
			 	 if(this.health < this.maxHealth && this.experience > 0)
			 	 	{
			 	 	this.health+=0.2;			 	 	
			 	 	this.experience-=1;
			 	 	gameManager.playerHealthBar.setValues(this.health,this.maxHealth);
			 	 	}
			 	}
			 else if(this.healing)
			 	{
			 	  this.healing = false;
			 	  this.lastHealTime= gameManager.runningClock;
			 	}
			}
		giveExp(expVal)
			{
			 this.experience+=expVal;
			}
		receiveParams(health,maxHealth,maxEnergy,weaponDamage,experience)
			{
			// console.log(`player received health:${health},maxHealth:${maxHealth} and maxEnergy:${maxEnergy}`);
			this.maxHealth = maxHealth;
			this.maxEnergy = maxEnergy;
			this.weaponDamage = weaponDamage;
			this.experience = experience;
			this.health = health; 
			gameManager.playerHealthBar.setValues(this.health,this.maxHealth);
		 	// gameManager.playerEnergyBar.setValues(this.energy,this.maxEnergy);	
            gameManager.playerEnergyBar.setValues(this.hitCredit,this.maxHitCredit);
			}

		 updateParams(maxHealth,maxEnergy,weaponDamage)
		 	{
		 	 this.maxHealth=maxHealth;
		 	 this.maxEnergy=maxEnergy;
		 	 this.weaponDamage=weaponDamage;
		 	 gameManager.playerHealthBar.setValues(this.health,this.maxHealth);
		 	 // gameManager.playerEnergyBar.setValues(this.energy,this.maxEnergy);
		 	}
		 update_and_display_hitbox()
		 	{
	 		// this.hit_box.updatePosition(this.position);
	 		this.position.setVec(this.hit_box.position);
		 	}
		manageInvincibility()
			{
			if(!this.invincibleState) return false;
			this.invin_count+= deltaTime;
			if(this.invin_count > this.max_invin_time)
				{
				 this.invin_count=0;
				 this.invincibleState=false;
				} 
			}

		flickerControl()
			{
			  if(!this.invincibleState) return true;
			  this.flickerCount+=deltaTime;
			  if(this.flickerCount > this.maxFlickerTime)
			  	{
			  	 this.flickerCount=0;
			  	 return true;
			  	}
			  return false;
			}

		fallDamage()
			{
			  // return false;
			  if(this.position.y- gameManager.bottomY > 2*canvas.height)
			  	{
			  	// this.takeDamage(this.health*1.01);
			  	gameManager.playerDied=true;
			  	this.takeDamage(2);			  		
			  			  
			  	}
			}
         
        fixChangedParameters(){
            if(this.parameterChangedClock==0) return;
            if(gameManager.runningClock - this.parameterChangedClock > this.maxParamChangeTime)
            {
                this.parameterChangedClock=0;
                this.maxVelocity.x=this.maxHoriVel_player;
                
            }
        }
		takeDamage(dmg,dir=0)
		 	{	
            // console.log(`player takes damage, acceleration added:${dir}`);
		 	 	
		 	// return false;
		 	if(this.invincibleState && !gameManager.playerDied) return false;
		 	gameManager.FreezeScreen();
		 	if(!gameManager.playerDied)
		 	document.querySelector('#LossBuzz').play();	
		 	this.invincibleState=true;
            if(Math.abs(dir)>0){	 	
            if(Math.abs(dir) > this.maxVelocity.x){
                this.maxVelocity.x=Math.abs(dir);
                
                this.parameterChangedClock=gameManager.runningClock;
            }
		 	this.acceleration.add(new CreateVector(dir,0));
            }
	 		this.health-=dmg;
	 		gameManager.playerHealthBar.updateValue(this.health);	 		
	 		if(this.health<=0)
	 			{
	 			if(gameManager.playerDied) document.querySelector('#LossBuzz').play();	
	 			this.health=0;
	 			console.log('destroyed');
	 			SpawnClouds(this.position);	 			
	 			destroySelf(this.hit_box);
	 			destroySelf(this);	 			
	 			this.isActive=false;
	 			gameManager.player=null;
	 			gameManager.playerDied=true;	 			
	 			gameManager.playerDiedClock= gameManager.runningClock;		 			 			
	 			}
		 	}
		refillEnergy()
			{
			 if(this.energy >= this.maxEnergy) return false;
			 this.energy+=this.energyRefillRate;
			 // gameManager.playerEnergyBar.updateValue(this.energy);
			}
		 	
		 runAnimation()
		 	{
	 		this.animationFrame+=this.animationFractions[this.animation];            	
	 		if(this.animationFrame >= this.animations[this.animation].length)
	 			{
	 			 this.animationFrame=0;
	 			 if(this.animInQueue) 
	 			 	{
	 			 	this.animation=this.animInQueue;
	 			 	this.animInQueue=null;
	 			 	}
	 			}
		 	}

		 spawnHitBoxOnSlash()
		 	{
		 	
	 		if((this.animation=="slash" || this.animation=="slash2") && parseInt(this.animationFrame)==6 && !this.hitBoxSpawned)
	 			{
	 			
	 			this.hitBoxSpawned=true;
                if(!this.casting)
	 			new DamageHitBox(this.position.x,
	 							 this.position.y,
	 							 this.width*0.4,
	 							 this.height*0.8,
	 							 [gameManager.visible_sprites,
	 							 	gameManager.hitbox_sprites,
	 							 	gameManager.active_sprites],
	 							 'player_hitbox',
	 							 this,
	 							 40,0,this.weaponDamage,this.sx*1.5,50);
                else{
                this.casting=false;
                if(this.hitCredit > 20)
                    {
                    this.hitCredit-=5;
                    gameManager.playerEnergyBar.updateValue(this.hitCredit);
                    new Bullet(this.position.x+this.sx*20*xscale,
                               this.position.y,
                               160*xscale,
                               160*yscale,
                               this,[gameManager.visible_sprites,gameManager.active_sprites]
                              );
                    this.switchOffGravity();

                    }
                    
                }
                /*
	 			new ThornyBall(this.position.x,
							   this.position.y,
							   30*xscale,
							   30*yscale,
							   this,70*xscale,0,
							   [gameManager.visible_sprites,gameManager.active_sprites]
					          );	*/

	 			}
	 		else if(this.animation!="slash" && this.hitBoxSpawned)
	 			this.hitBoxSpawned=false;
		 	}
		 checkIfOnGround()
		 	{
		 	for(let x of gameManager.collission_sprites)
		 		{
		 		 if(!x.onScreen || x==this.hit_box) continue;
		 		 
		 		 if(Raycast(this.position.copy(),new CreateVector(0,1),this.downCheckRaycast,x) )
		 		 	{
		 		 	return true;
		 		 	}
		 		}
		 	return false;
		 	}
		 
		 recordOnAir(){

		 	if(this.checkIfOnGround() && this.onAir) 
		 		{
		 		this.onAir=false;
		 		gameManager.screenShakeTimer=gameManager.runningClock;
		 		}
		 	else if(!this.checkIfOnGround() && !this.onAir) this.onAir=true;
		 }
		 jumpingContols()
		 	{
		 	 // this.recordOnAir(); #can be used for screenshaking

		 	/*
		 	 if(this.checkIfOnGround())
		 		DisplayInGaps("player is on ground");
		 	else
		 		DisplayInGaps("player is in air");
		 	*/
		 	 // if(spacePress)
		 	 if(GetKeyPressedx(gameManager.jumpKey))
		 	 	{
		 	 	 if(this.spaceTrigger  && !this.jumping && this.numJumps<2)
		 	 	 	{ 
                   
                    // this.velocity.y=-this.maxVelocity.y;
                    this.velocity.y=0;
  					if(Math.abs(this.IsInContactWithWallVar)==1)                      
                        this.reverseDashing=true; 
                    //snippet added on 07-05-2023 to implement different jumping parameters starts    
                    if(this.numJumps==0)
                    	{
                    	this.maxJumpTime=this.maxJumpTime_onfirst_jump;
                    	this.jumpingForce=this.jumpingForce_onfirst_jump;

                    	}
                    else
                    	{
						this.maxJumpTime=this.maxJumpTime_onsecond_jump;
                    	this.jumpingForce=this.jumpingForce_onsecond_jump;
                        
                    	}
                    //snippet added on 07-05-2023 to implement different jumping parameters ends
		 	 	 	this.spaceTrigger=false;
		 	 	 	if(this.energy < this.energyCosts["jump"] && this.numJumps<1) 
		 	 	 		return false;
		 	 	 	this.energy=Math.max(0,this.energy-this.energyCosts["jump"]);
		 	 	 	this.numJumps+=1;
		 	 	 	this.jumping=true;
		 	 	 	if(this.numJumps==1)
		 	 	 	document.querySelector('#HitPaddleBloop').play();
		 	 	 	else
		 	 	 		{
		 	 	 		document.querySelector('#HitPaddleBloop').play();
		 	 	 		SpawnClouds(this.position);
		 	 	 		}
		 	 	 	this.jumpTimer=0;
		 	 	 	}
		 	 	 else if(this.jumping)
		 	 	 	{                     
		 	 	 	 this.acceleration.y-=this.jumpingForce;                     
		 	 	 	 this.jumpTimer+=deltaTime;		 	 	 	 
		 	 	 	 if(this.jumpTimer > this.maxJumpTime)
		 	 	 	 	{		 	 	 	 	 
		 	 	 	 	 this.jumping=false;
		 	 	 	 	}
		 	 	 	}
		 	 	}
		 	 else if(!this.spaceTrigger && this.numJumps<2) //
		 	 	this.spaceTrigger=true;
		 	 if(!GetKeyPressedx(gameManager.jumpKey) && this.jumping) this.jumping=false;
             
             
		 	 if(!GetKeyPressedx(gameManager.jumpKey) && this.numJumps>0 && 
                (this.checkIfOnGround()|| Math.abs(this.IsInContactWithWallVar) ) ) 
		 	 	this.numJumps=0;
		 	}
		 applyGravity()
		 	{
             // if(this.isOnContactWithGround){
             //    this.velocity.y=Math.max(this.velocity.y,0);
             //    return;
             // }
             this.checkGravity();
		 	 if(this.dashing || this.gravitySwitchedOff)
		 	 	return false;
		 	 this.acceleration.y+=this.gravityScale;
		 	}
        
         switchOffGravity()
            {
             this.gravitySwitchedOff=true;
             this.velocity.y=0;
             this.gravityPauseTime=gameManager.runningClock;
            }
         checkGravity()
            {
                if(!this.gravitySwitchedOff) return;
                if(gameManager.runningClock - this.gravityPauseTime > 200)
                    this.gravitySwitchedOff=false;
            }
		 changeAnimation(anim)
		 	{
		 	if(this.animation=="slash" && anim!="slash2") return false;
	 		if(this.animation=="slash2" && anim!="slash") return false;
	 		if(this.animation == anim) return false;
	 		else
	 			{
	 			this.animation=anim;
	 			this.animationFrame=0;
	 			}
		 	}
		 move()
		 	{	
		 	 // DisplayInGaps(`${this.position.x},${this.position.y}`);	 	 
		 	 // this.checkDeath();
             this.CheckIfIsInContactWithWall();
		 	 this.handleHealing();
		 	 this.applyGravity();
		 	 this.manualControls();
		 	 this.jumpingContols();
		 	 this.velocity.add(this.acceleration);
		 	 this.acceleration.set(0,0);
		 	 this.applyVelocity();
		 	 this.applyVelocityRestrictions();	
		 	 this.update_and_display_hitbox();	 
		 	 this.spawnHitBoxOnSlash();	 
		 	 this.refillEnergy();
		 	 this.manageInvincibility();
		 	}

	
         reverseDashFns()
         	{
		 	 if(this.dashStartTime==0)
			 	 {			 	  
			 	  this.dashStartTime= gameManager.runningClock;
			 	  this.maxVelocity.x= this.dashSpeed*0.5;			 	  
			 	  document.querySelector('#HitPaddleBloop').play();
			 	 }
			 
		 	 this.acceleration.add(this.horiForce.copy().mult(-this.IsInContactWithWallVar*3));
		 	 if(gameManager.runningClock - this.dashStartTime > this.maxDashTime*0.6)
		 	 	 {
		 	 	  this.dashing=false;
		 	 	  this.dashStartTime=0;
		 	 	  this.maxVelocity.x= this.maxHoriVel_player;
		 	 	  this.reverseDashing=false;
		 	 	 }	
         	}	 
		 dashStateFns()
		 	{
		 	 if(this.dashStartTime==0)
			 	 {
			 	  this.dashStarted=true;                  
			 	  this.dashStartTime= gameManager.runningClock;
			 	  this.maxVelocity.x= this.dashSpeed;
			 	  this.velocity.y=0;
			 	  // SpawnClouds(this.position);
			 	  document.querySelector('#HitPaddleBloop').play();
			 	 }
             SpawnClouds(this.position,4);
		 	 this.acceleration.add(this.horiForce.copy().mult(this.sx*3));
		 	 if(gameManager.runningClock - this.dashStartTime > this.maxDashTime)
		 	 	 {                  
		 	 	  this.dashing=false;
		 	 	  this.dashStartTime=0;
		 	 	  this.maxVelocity.x= this.maxHoriVel_player;
		 	 	 }
		 	}
         //
         exhaustSlashQueue()
            {
                // if(!this.startExhausting) return false;
                if(this.slashQueue.length==0) 
                    {
                        if(this.slashQueueFull) this.slashQueueFull=false;
                        return false;
                    }
                // console.log(`present running animation:${this.animation} here`)
                // console.log(this.animationFrame)
                // console.log(this.animations[this.animation].length)
                if((this.animation=='slash' || this.animation=='slash2') &&
                    (this.animationFrame< this.animations[this.animation].length-1) )
                    {
                     // console.log(`present running animation:${this.animation}`)
                     if(this.slashQueue.length==1 && this.animInQueue!='idle') 
                        {
                        // console.log(`xanimation is ${this.animation}`)
                        // console.log(`xsize is ${this.animations[this.animation].length}`)
                        // console.log(`xpresent frame:${this.animationFrame}`)
                        this.animInQueue='idle';
                        }
                     else if(this.slashQueue.length>1 && this.animInQueue!=this.slashQueue[1])
                        {
                        // console.log(`animation is ${this.animation}`)
                        // console.log(`size is ${this.animations[this.animation].length}`)
                        // console.log(`present frame:${this.animationFrame}`)
                        // console.log("length of slash q:"+this.slashQueue.length);
                        this.animInQueue=this.slashQueue[1];   
                        // console.log(`next animation changed to ${this.animInQueue}`);
                        }                
                    }   
                else if(this.animation=='slash' || this.animation=='slash2')
                {
                    if(this.slashQueue.length!=0 && this.slashQueue[0]!=this.animInQueue)
                    {
                    // console.log(`${this.slashQueue[0]} shifted out`);
                    this.slashQueue.shift();
                    }
                }
                else 
                    this.changeAnimation(this.slashQueue[0]);

            }
		 manualControls()
		 	{
            // if(GetKeyPressedx("b")) this.startExhausting=true;
            if(this.reverseDashing)
            	{
            	 this.reverseDashFns();
            	 return;
            	}
		 	if(this.invincibleState && this.invin_count < 0.5*this.max_invin_time){
                
                this.velocity.x=Lerp(this.velocity.x,0,4); 
		 		return false; 
            }
		 	if(this.dashing)
		 		{
		 		 this.dashStateFns();
		 		 return;
		 		}
		 	if(GetKeyPressedx(gameManager.dashKey) )
	 			{
	 			 if(!this.dashStarted)
	 			  {
	 			  this.changeAnimation('idle');
	 			  this.dashing=true;
	 			  }	 			  
	 			}
	 		else if(this.dashStarted && this.checkIfOnGround())
	 			this.dashStarted=false;
		 	if(this.animation!='slash')
			 	{
		 		if(leftPress || leftArrow)
		 			{
		 			if(this.sx!=-1) this.sx=-1;
		 			this.changeAnimation('run');
		 			this.acceleration.sub(this.horiForce);
                    // this.manual_velocity.x=-this.manual_horizontal_velocity;
		 			}
		 		else if(rightPress || rightArrow)
		 			{
		 			if(this.sx!=1) this.sx=1;
		 			this.changeAnimation('run');
		 			this.acceleration.add(this.horiForce);
                    // this.manual_velocity.x=this.manual_horizontal_velocity;
		 			}		 		
		 		else
		 			{
		 			this.changeAnimation('idle');
		 			this.velocity.x=Lerp(this.velocity.x,0,4);	 
                    // this.manual_velocity.x=0;					 		
		 			}
		 		}
	 		else
		 		{
		 		this.velocity.x=Lerp(this.velocity.x,0,32);	
                // this.manual_velocity.x=0;   	
		 		}
            
	 		if(GetKeyPressedx(gameManager.strikeKey) && this.slashTrigger)
	 			{
	 			 if(this.energy < this.energyCosts["slash"] || this.slashQueueFull
                    )
	 			 	return false;
	 			 this.energy-=this.energyCosts["slash"]; 
	 			 this.slashTrigger=false;
	 			 // this.animInQueue="idle";
                 if(this.slashQueue.length==0)                    
                 this.slashQueue.push("slash");
                 else{
                    let last=this.slashQueue[this.slashQueue.length-1];
                    if(last=='slash') this.slashQueue.push('slash2');
                    else this.slashQueue.push('slash');
                    if(this.slashQueue.length==4) this.slashQueueFull=true;
                 }
                 // console.log(JSON.stringify(this.slashQueue));
                }
            /*
            //old strike code before slash chaining, delete after new
            if(GetKeyPressedx(gameManager.strikeKey) && this.slashTrigger)
                {
                 if(this.energy < this.energyCosts["slash"] || 
                    this.animation=="slash" || this.animation=="slash2"
                    )
                    return false;
                 this.energy-=this.energyCosts["slash"]; 
                 this.slashTrigger=false;
                 this.animInQueue="idle";
                 if(this.lastSlash==1)
                    {
                   this.changeAnimation("slash");   
                    this.RecordFirstStrike();
                    
                    }
                    else
                    {                         
                    this.changeAnimation("slash2");
                    this.lastSlash=1;                
                    }
                }
            */
	 		else if(!GetKeyPressedx(gameManager.strikeKey)&& !this.slashTrigger)
	 			{
                
	 			 this.slashTrigger=true;
	 			}

            if(GetKeyPressedx(gameManager.castKey) && this.slashTrigger2)
                {
                 // if(this.energy < this.energyCosts["slash"])
                 //    return false;
                 this.energy-=this.energyCosts["slash"]; 
                 this.slashTrigger2=false;
                 this.casting=true;
                 this.animInQueue="idle";
                 this.changeAnimation("slash"); 
                 
                }
            else if(!GetKeyPressedx(gameManager.castKey)&& !this.slashTrigger2)
                {
                 this.slashTrigger2=true;
                 
                }

	 			
		 	}

		 checkDeath()
		 	{
		 	 return false;
		 	 if((this.position.x - gameManager.camera.position.x > 1.5*canvas.width)||
		 	   (this.position.y - gameManager.camera.position.y > 1.5*canvas.height) )
		 	 	{
		 	 	 this.onScreen=false;
		 	 	 console.log(`${this.sprite_type} has died`);
		 	 	}
		 	}

		 collidedWith()
		 	{
		 	 for(let x of gameManager.collission_sprites)
		 	 	{
		 	 	 if(!x.onScreen) continue;
		 	 	 if(b_collision(this,x)) 
		 	 	 	{
		 	 	 	 return x;
		 	 	 	}
		 	 	}
		 	 return false;
		 	}
		 testCollisionWithKillPlants()
		 	{
	 		for(let x of gameManager.kill_plants)
	 			{
	 			if(b_collision(this.hit_box,x))
	 				{ 					 
	 				 this.takeDamage(this.health);	 				 
	 				}
	 			}
		 	}

		 testCollisionWithLoot()
		 	{
            return false;//revisit
		 	for(let x of gameManager.loot)
	 			{
	 			if(b_collision(this.hit_box,x))
	 				{ 					 
	 				 x.giveExp(this);	 				 
	 				}
	 			}	
		 	}

		 applyVelocity()
		 	{		 	 	 	 
		 	 this.hit_box.position.x+=this.velocity.x;
		 	 // this.hit_box.position.x+=this.manual_velocity.x;
		 	 for(let k in gameManager.collission_sprites)
		 	 	{ 
		 	 	 let x=gameManager.collission_sprites[k];
		 	 	 if(!x.onScreen) continue;
		 	 	 if(x==this || x==this.hit_box) continue;		 	 	 
		 	 	 if(b_collision(this.hit_box,x)) 
		 	 	 	{		 
		 	 	 	// console.log('collision with '+x.sprite_type); 	 	 
		 	 	 	 if(this.velocity.x > 0)
		 	 	 	 	{		 	 	 	 
		 	 	 	 	this.hit_box.position.x=x.position.x - x.width/2-this.hit_box.width/2-2;		 	 	 	 	
		 	 	 	  	}
		 	 	 	 else 
		 	 	 	 	{
		 	 	 	    this.hit_box.position.x=x.position.x + x.width/2 + this.hit_box.width/2+2;		 	 	 	    
		 	 	 		}
		 	 	 	}
		 	 	}

		 	 this.hit_box.position.y+=this.velocity.y;		 	 
		 	 for(let x of gameManager.collission_sprites)
		 	 	{
		 	 	 if(!x.onScreen) continue;
		 	 	 if(x==this || x==this.hit_box) continue;		 	 	 
		 	 	 if(b_collision(this.hit_box,x)) 
		 	 	 	{
		 	 	    // console.log('collision with '+x.sprite_type);
		 	 	 	if(this.velocity.y > 0)
		 	 	 		{
		 	 	 		this.hit_box.position.y=x.position.y-x.height/2-this.hit_box.height/2-2;		 	 	 		
		 	 	 		}
		 	 	 	else
		 	 	 		{
		 	 	 		this.hit_box.position.y=x.position.y+x.height/2+this.hit_box.height/2+2;		 	 	 		
		 	 	 		}
                     if(x.parent && x.parent.sprite_type=="MovingPlatform")                        
                        x.parent.inContact=true;                        
		 	 	 	}
		 	 	}
		 	}
		 applyVelocityRestrictions()
		 	{
		 	 let xdir=this.velocity.x/Math.abs(this.velocity.x);
		 	 let ydir=this.velocity.y/Math.abs(this.velocity.y);
		 	 if(Math.abs(this.velocity.y) > this.maxVelocity.y)
		 	 	this.velocity.y=ydir*this.maxVelocity.y;
		 	 if(Math.abs(this.velocity.x) > this.maxVelocity.x)
		 	 	this.velocity.x=xdir*this.maxVelocity.x;
		 	}

		 flashThis()
		 	{
		 	 if(!this.healing) return false;
		 	 this.healTimer+= deltaTime;
		 	 this.healTimer2+=deltaTime;
		 	 if(this.healTimer > this.healDelta)
		 	 	{
		 	 	 this.healTimer=0;
		 	 	 this.flashOn=!this.flashOn;
		 	 	}
		 	 if(this.healTimer2 > this.healTimeMax)
		 	 	{
		 	 	 this.flashOn=true;
		 	 	 this.healing=false;
		 	 	 this.healTimer=0;
		 		 this.healTimer2=0;
		 		 this.lastHealTime= gameManager.runningClock;
		 	 	}
		 	 return this.flashOn;
		 	}
		 update()
		 	{
		 	 if(!this.onScreen) return false;
             this.fixChangedParameters();
		 	 this.runAnimation();
		 	 this.move();
		 	 this.fallDamage();
             this.exhaustSlashQueue();
             //this.ResetFirstStruck();	//used prior to slash chaining delete	
		 	}
		 display()
		 	{		 	 
		 	 if(!this.onScreen || this.dashing || !this.flickerControl()) return false;

		 	 ctx.save();
		 	 ctx.translate(this.position.x-gameManager.camera.position.x, 
		 	 	 		   this.position.y-gameManager.camera.position.y);
		 	 ctx.rotate(d2r(this.angle));
		 	 ctx.scale(this.sx,this.sy);
		 	 ctx.drawImage(this.animations[this.animation][parseInt(this.animationFrame)],
		 	 			   -this.width/2,
		 	 			   -this.height/2,
		 	 			   this.width,
		 	 			   this.height
		 	 			  );
		 	 if(this.flashThis())
		 	 ctx.drawImage(this.healFlash,
						  -this.width/2,
		   				  -this.height/2,
		   				  this.width,
		   				  this.height
		 	 			  );
		 	 ctx.restore(); 
		 	}


		}

	class Camera
		{
		  constructor()
		  	{
		  	 this.position=new CreateVector(0,0);
		  	 this.mouseLockX=0;
		  	 this.mouseLockY=0;	
		  	 this.tgt=null;	  
		  	 this.lerpFactor=4;	 
		  	 this.shakeVals=[0,0];
		  	}
		  runWithMouse()
		  	{
		  	 if(mousePressed)
		  	 	{	
		  	 	if(this.mouseLockX==0)
		  	 		{
		  	 		this.mouseLockX=mouseX;		  	 		
		  	 		}
		  	 	if(this.mouseLockY==0)
		  	 		{
		  	 		this.mouseLockY=mouseY;
		  	 		}
		  	 	this.position.x-=(mouseX-this.mouseLockX)/10;
		  	 	this.position.y-=(mouseY-this.mouseLockY)/10;
		  	 	}
		  	 else
		  	 	{
		  	 	if(this.mouseLockX!=0) this.mouseLockX=0;
		  	 	if(this.mouseLockY!=0) this.mouseLockY=0;
		  	 	}
		  	}
		  smoothFocus(followH,followV)
		  	{
		  	 if(!this.tgt) return false;
		  	 // if(!this.tgt || !this.tgt.isActive) return false;
		  	 // DisplayInGaps(`camera is following ${this.tgt.sprite_type}`);
		  	 if(followH)
		  	 	this.position.x=Lerp(this.position.x,this.tgt.position.x-canvas.width/2,this.lerpFactor);
		  	 if(followV)
		  	 	this.position.y=Lerp(this.position.y,this.tgt.position.y-canvas.height/2,this.lerpFactor);
		  	 this.shakeCamera();
		  	}
		   shakeCamera()
		    {
		    	this.position.x+=this.shakeVals[0];
		    	this.position.y+=this.shakeVals[1];
		    }

		}
//generic button starts
	class GenericButton
    	{
        constructor(x,y,wid,hei,tex,btnType,btnGroups,btnName,parentPanel)      
          {
           this.position=new CreateVector(x,y);
           this.parentPanel=parentPanel;
           this.tex=tex;
           this.sprite_type="generic button";
           this.btnName=btnName;
           this.btnType=btnType;
           this.onScreen=true;
           this.width=wid;
           this.height=hei;
           this.arrowCornerPoints=[[-0.5,-0.5],[0.5,0],[-0.5,0.5]];
           this.mouseOverMe=false;
           this.x_text_offset=-40;
           this.y_text_offset=10;           
           if(this.btnType=='rightArrow')             
              this.tex='';
           else if (this.btnType=='leftArrow')
             {
              this.tex='';
              this.arrowCornerPoints=[[0.5,-0.5],[-0.5,0],[0.5,0.5]];
             } 
           this.arrowCornerPoints=this.arrowCornerPoints.map(x=>[x[0]*this.width,x[1]*this.height]);  
           this.fillColor='#a3a375';
           this.clickColor='#ccccb3';
           this.btnGroups=btnGroups;
           for(let grp of this.btnGroups)
              {
               grp.push(this);
              }
           this.mouseTrigger=false;
           }
        colorSwitch()
            {           
            let leftx=this.position.x - this.width/2;
            let rightx = this.position.x + this.width/2;
            let lefty=this.position.y - this.height/2;
            let righty = this.position.y + this.height/2;        
            if(mouseX > leftx && mouseX <rightx && mouseY > lefty && mouseY < righty )
                { 
                this.mouseOverMe=true;
                if(mousePressed)
                this.presentColor = this.fillColor;
                else
                this.presentColor=this.clickColor;  
                }
            else
                {    
                this.mouseOverMe=false;           
                this.presentColor=this.fillColor;
                }
            }
        update()
            {
             this.colorSwitch();  
             if(mousePressed && !this.mouseTrigger)
               {
                this.mouseTrigger=true;
                if(this.mouseOverMe)
                    {
                      this.specialButtonTask();
                    }
               }
             else if(!mousePressed && this.mouseTrigger)
                {
                 this.mouseTrigger=false;                
                }           
            }
        display()
            {              
             ctx.save();
             ctx.translate(this.position.x,this.position.y);
             ctx.fillStyle=this.presentColor;//#ccccb3
             ctx.strokeStyle='#000000';
             ctx.beginPath();
             // ctx.rect(-this.width/2,-this.height/2,this.width,this.height);
             if(this.btnType=='leftArrow' || this.btnType=='rightArrow')
                this.draw_arrow_button();
             else
                ctx.ellipse(0,0,this.width/2,this.height/2,0,0,2*Math.PI);
             ctx.stroke();
             ctx.fill();             
             ctx.restore();
             w2screen(this.tex,this.position.x+this.x_text_offset,
                               this.position.y+this.y_text_offset);
            }

        draw_arrow_button()
            {                
               ctx.moveTo(this.arrowCornerPoints[0][0],this.arrowCornerPoints[0][1]);
               ctx.lineTo(this.arrowCornerPoints[1][0],this.arrowCornerPoints[1][1]);
               ctx.lineTo(this.arrowCornerPoints[2][0],this.arrowCornerPoints[2][1]);
               ctx.closePath();
            }
        specialButtonTask()
            {
                // console.log(`${this.btnType}`);
                gameManager.performButtonPressFn(this.btnName);
            }

    	}
//generic button ends
	class Button
		{
		constructor(x,y,tex,btnGroups,enclosingPanel)
			{
			 this.position=new CreateVector(x,y);
			 this.tex=tex;
			 this.width=140;
			 this.height=50;
			 this.onScreen=true;
			 this.mouseTrigger=false;
			 this.fillColor='#a3a375';
			 this.clickColor='#ccccb3';
			 this.presentColor=this.fillColor;
			 this.btnGroups=btnGroups;
			 this.btnGroups.push(this);
			 this.eP=enclosingPanel;			 
			}
		colorSwitch()
			{			
			let leftx=this.position.x - this.width/2;
		 	let rightx = this.position.x + this.width/2;
		 	let lefty=this.position.y - this.height/2;
		 	let righty = this.position.y + this.height/2;		 
			if(mouseX > leftx && mouseX <rightx && mouseY > lefty && mouseY < righty )
				{				
				this.presentColor = this.clickColor;
				}
			else
				{				
				this.presentColor=this.fillColor;
				}
			}
		update()
			{
			 this.colorSwitch();
			 if(mousePressed && !this.mouseTrigger)
			 	{
			 	 this.mouseTrigger=true;
			 	 let leftx=this.position.x - this.width/2;
			 	 let rightx = this.position.x + this.width/2;
			 	 let lefty=this.position.y - this.height/2;
			 	 let righty = this.position.y + this.height/2;
			 	 if(mouseX > leftx && mouseX <rightx && mouseY > lefty && mouseY < righty )
			 	 	{
			 	 	// this.presentColor = this.clickColor;
			 	 	if(!this.eP.showSecondScreen)
				 	 	{
				 	 	 switch(this.tex)
				 	 	 	{
				 	 	 	case 'Save':				 	 		
					 	 		gameManager.saveStatusToLocalStoragex();
					 	 		gameManager.gamePaused = false;
					 	 		break;
					 	 	case 'Restart':
					 	 	    if(confirm("Press Ok to delete progress and restart game from start"))
					 	 	    {
					 	 		localStorage.removeItem("GameSaveData");
					 	 		window.location.href='Platformer.html';
					 	 		}
					 	 		break;
					 	 	case 'Controls':
					 	 		this.eP.switchScreen();
					 	 		break;
				 	 		}
				 	 	}
			 	 	}
			 	}
			 else if(!mousePressed && this.mouseTrigger)
			 	{
			 	 this.mouseTrigger=false;			 	 
			 	}
			 // else if(!mousePressed)
			 // 	{
				// this.presentColor=this.fillColor;
			 // 	}
			}
		display()
			{
			 if(this.eP.showSecondScreen) return false;			 	 
			 ctx.save();
			 ctx.translate(this.position.x,this.position.y);
			 ctx.fillStyle=this.presentColor;//#ccccb3
			 ctx.strokeStyle='#000000';
			 ctx.beginPath();
			 ctx.rect(-this.width/2,-this.height/2,this.width,this.height);
			 ctx.stroke();
			 ctx.fill();			 
			 ctx.restore();
			 w2screen(this.tex,this.position.x-40,this.position.y+10);
			}
		}

	class LevelUpBox
		{
		 constructor(go)
		 	{		 	  
		 	  this.position=new CreateVector(canvas.width/2,canvas.height/2);
		 	  this.width=800;
		 	  this.height=600;
		 	  this.maxHealth=100;
		 	  this.maxEnergy=100;
		 	  this.weaponDamage=10;
		 	  this.experience=100;
		 	  this.expNeeded=10;	
		 	  this.focussed=1;
		 	  this.keyFocussed=-1;
		 	  this.enterTrigger=true;
		 	  this.coolDownTimer=0;
		 	  this.coolDownMaxTime=200;
		 	  this.btnGroups=[];
		 	  this.go=go;
		 	  new Button(this.position.x,this.position.y+200,"Save",this.btnGroups,this);
		 	  new Button(this.position.x+300,this.position.y-175,"Restart",this.btnGroups,this);
		 	  new Button(this.position.x+300,this.position.y,"Controls",this.btnGroups,this);
		 	  this.maxEntries=3;
		 	  this.showSecondScreen=false;
		 	  this.lboxFlickerBool=false;
		 	  this.lboxFlickerClock=0;
		 	  this.lboxFlickerMaxTime=200;
		 	  this.pressedKeyCode=-2;
		 	  this.mouseTrigger=true;
              this.disappearingMessageStartTime=0;
              this.disappearingMessage="";              
              this.maxDisap=2000;
              this.disFlickerGap=this.maxDisap/20;
              this.disFlickTimer=0;
              this.disFlickBool=true;
		 	}
         disFlickerControl(){
            this.disFlickTimer+=deltaTime;
            if(this.disFlickTimer > this.disFlickerGap){
                this.disFlickTimer=0;
                this.disFlickBool=!this.disFlickBool;
            }
            return this.disFlickBool;
         }
         displayTempMessage(){
            if(this.disappearingMessageStartTime==0) return;
            if(gameManager.runningClock - this.disappearingMessageStartTime>this.maxDisap){
                this.disappearingMessageStartTime=0;
            }    
            if(this.disFlickerControl())        
            w2screen(this.disappearingMessage,canvas.width/2,canvas.height/2,'#00FFFF');
         }
         showDisappearingMessage(msg){
            this.disappearingMessageStartTime=gameManager.runningClock;
            this.disappearingMessage=msg;
         }

		 clickedOutside()
		 	{
		 	 if(mouseX > this.position.x-this.width/2 && mouseX < this.position.x+this.width/2)
		 	 if(mouseY > this.position.y-this.height/2 && mouseY < this.position.y+this.height/2)
		 	 	return false;
		 	 return true;
		 	}
		 mouseClickDetectedOutside()
		 	{
	 		if(this.clickedOutside() && mousePressed && this.mouseTrigger)
	 			{
	 			 this.mouseTrigger=false;
	 			 gameManager.gamePaused=false;
	 			}
		 	}
		 turnBackMouseTriggerOn()
		 	{
		 	 if(!mousePressed && !this.mouseTrigger)
		 	 this.mouseTrigger=true;
		 	}
		 lboxFlickerControl()
		 	{
		 	if(gameManager.runningClock - this.lboxFlickerClock > this.lboxFlickerMaxTime)
		 		{
		 		 this.lboxFlickerClock= gameManager.runningClock;
		 		 this.lboxFlickerBool=!this.lboxFlickerBool;
		 		}
		 	return this.lboxFlickerBool;
		 	}
		 switchScreen()
		 	{
		 	 if(this.showSecondScreen)
			 	 {
			 	  this.showSecondScreen= false;
			 	  this.maxEntries=3;
			 	 }
			 else
			 	 {
			 	  this.showSecondScreen= true;
			 	  this.maxEntries=5;
			 	 }
		 	}
		 update()
		 	{
		 	 
		 	 if(!gameManager.gamePaused || !gameManager.player) 
		 	 	{
                this.focussed=1;
		 	 	if(this.showSecondScreen) this.switchScreen();
		 	 	return false;	
		 	 	}	 	
		 	 this.turnBackMouseTriggerOn();
		 	 this.mouseClickDetectedOutside(); 
		 	 this.runCoolDown();
		 	 this.checkForKeyPress();		 	 
		 	}
		 receiveGameObject(obj)
		 	{
		 	 this.go=obj;
		 	}
		 displayAndUpdateButtons()
		 	{
		 	 for(let btn of this.btnGroups)
		 	 	{
		 	 	btn.update();
		 	 	btn.display();	
		 		}		 	 
		 	}
		 runCoolDown()
		 	{
		 	 if(this.coolDownTimer==0) return false;
		 	 this.coolDownTimer += deltaTime;
		 	 if(this.coolDownTimer > this.coolDownMaxTime)
		 	 	{
		 	 	 this.coolDownTimer=0;
		 	 	}
		 	}
		 changeParam()
		 	{
		 	 if(this.go.experience < this.go.expNeeded)
		 	 	return false;
		 	 switch(this.focussed)
		 	 	{
		 	 		case 1:
		 	 			this.go.maxHealth+=1;		 	 			
		 	 			break;
		 	 		case 2:
		 	 			this.go.maxEnergy+=1;
		 	 			break;
		 	 		case 3:
		 	 			this.go.weaponDamage+=1;
		 	 			break;
		 	 		default:
		 	 		break;
		 	 	}
		 	 this.go.experience-=this.go.expNeeded;		 	 
		 	 // gameManager.player.updateParams(this.maxHealth,this.maxEnergy,this.weaponDamage);
		 	 this.go.expNeeded=parseInt(1.1*this.go.expNeeded);
		 	}
		 checkForKeyPress()
		 	{
             let freeToMove=true;
             // freeToMove= !this.showSecondScreen || (this.showSecondScreen && this.keyFocussed==-1 );
             freeToMove=this.keyFocussed==-1;
		 	 if(downArrow && this.coolDownTimer==0 && freeToMove)
		 	 	{
		 	 	 this.focussed+=1;
		 	 	 if(this.focussed > this.maxEntries) this.focussed=1;
		 	 	 this.coolDownTimer=1;
		 	 	}
		 	 else if(upArrow && this.coolDownTimer==0 && freeToMove)
		 	 	{
		 	 	 this.focussed-=1;
		 	 	 if(this.focussed < 1) this.focussed=this.maxEntries;
		 	 	 this.coolDownTimer=1;
		 	 	}
		 	 else if(rightArrow && this.coolDownTimer==0)
		 	 	{
		 	 	  this.coolDownTimer=1;
                  if(!this.showSecondScreen)
		 	 	  this.changeParam();
		 	 	}
		 	 else if(leftArrow && this.coolDownTimer==0)
		 	 	{
		 	 	  this.coolDownTimer=1;
                  if(!this.showSecondScreen)
		 	 	  this.changeParam(-1);
		 	 	}

		 	}
		 display()
		 	{
		 	 if(!gameManager.gamePaused) return false;
             
		 	 ctx.save();
		 	 ctx.translate(this.position.x,this.position.y);
		 	 ctx.fillStyle="#604020";
		 	 ctx.strokeStyle="#604020";
		 	 ctx.beginPath();
		 	 ctx.rect(-this.width/2,-this.height/2,this.width,this.height);		 	 
		 	 ctx.stroke();
		 	 ctx.fill();		 	 
		 	 ctx.restore();
		 	 if(this.showSecondScreen) this.showKeyReAssignDetails();
		 	 else this.showStats();
		 	 this.displayAndUpdateButtons();
             this.displayTempMessage();
		 	}

		 showKeyReAssignDetails()
		 	{
		 	 this.assignNewKeys();
		 	 if(this.keyFocussed!=-1) this.keyFocussed=this.focussed;
		 	 if(enterPress)
		 	 	{
		 	 	 if(this.enterTrigger)
		 	 	 	{
		 	 	 	 this.enterTrigger= false;
		 	 	 	 this.keyFocussed=this.keyFocussed==-1?this.focussed:-1;
		 	 	 	}
		 	 	}
		 	 else if(!this.enterTrigger) 
		 	 	this.enterTrigger=true;
		 	 let startx=this.position.x -this.width*0.4;
		 	 let starty=this.position.y - this.height*0.4;
		 	 let shifts=[[100,0],[-100,80],[0,80],[0,80],[0,80],[0,80]];
		 	 let dialogues=["Use Arrow keys to navigate",
		 	 			    "Jump :  "+gameManager.jumpKey,
		 	 			    "Dash :  "+gameManager.dashKey,
		 	 			    "Strike:  "+gameManager.strikeKey,
		 	 			    "Heal:  "+gameManager.healKey,
                            "Cast:  "+gameManager.castKey		 	 			    
		 	 			   ];
		 	 for(let i in dialogues)
		 	 	{	
		 	 	 startx+=shifts[i][0];
		 	 	 starty+=shifts[i][1];
		 	 	 if(i==this.focussed )
		 	 	 	{
		 	 	 	if(this.keyFocussed==-1 || 
		 	 	 		(this.keyFocussed==this.focussed && this.lboxFlickerControl()))
		 	 	 	w2screen(dialogues[i],startx,starty,'#FF0000');
		 	 		}
		 	 	 else
		 	 	 w2screen(dialogues[i],startx,starty); 
		 	 	}
		 	}
		 assignNewKeys()
		 	{
		 	if(pressedKeyCode==-1) this.pressedKeyCode=-2;
            if(pressedKeyCode==-1) return false;
	 		if(this.keyFocussed==-1) return false;
             
	 		if(pressedKeyCode!=this.pressedKeyCode)
	 			{	 	
                  		
	 			  this.pressedKeyCode=pressedKeyCode;	 			  
	 			  if((pressedKeyCode>64 && pressedKeyCode <91)||
	 			  	(pressedKeyCode>96 && pressedKeyCode < 123)||
	 			    (pressedKeyCode==32)||specKeys.has(pressedKeyCode))
	 			  	{
	 			  	 let chosenKey="";
	 			  	 if(pressedKeyCode>64 && pressedKeyCode <91) 
	 			  	  chosenKey=String.fromCharCode(pressedKeyCode+32);
	 			  	 else if(!specKeys.has(pressedKeyCode))
	 			  	  chosenKey=String.fromCharCode(pressedKeyCode); 
                     else
                      chosenKey=GetSpecialKeyNames(pressedKeyCode);
	 			  	 switch (this.keyFocussed)
	 			  	 	{
	 			  	 	 case 1:	 			  	 	   
	 			  	 	   if(gameManager.isNewKey(chosenKey))
	 			  	 	   	 {
	 			  	 	   	 	gameManager.allKeys[0]=chosenKey;
	 			  	 	   	 	gameManager.jumpKey=chosenKey;
	 			  	 	   	 	console.log(`new jump key:${chosenKey}`);
	 			  	 	   	 	gameManager.storeKeyDataToLocalStorage();
	 			  	 	   	 }
	 			  	 	   	else 
	 			  	 	   		this.showDisappearingMessage("duplicate key");
	 			  	 	   break;
	 			  	 	 case 2:
	 			  	 	   if(gameManager.isNewKey(chosenKey))
	 			  	 	   	 {
	 			  	 	   	 	gameManager.allKeys[1]=chosenKey;
	 			  	 	   	 	gameManager.dashKey=chosenKey;
	 			  	 	   	 	console.log(`new dash key:${chosenKey}`);
	 			  	 	   	 	gameManager.storeKeyDataToLocalStorage();
	 			  	 	   	 }
	 			  	 	   	else 
	 			  	 	   		this.showDisappearingMessage("duplicate key");
	 			  	 	   break;
	 			  	 	 case 3:
	 			  	 	   if(gameManager.isNewKey(chosenKey))
	 			  	 	   	 {
	 			  	 	   	 	gameManager.allKeys[2]=chosenKey;
	 			  	 	   	 	gameManager.strikeKey=chosenKey;
	 			  	 	   	 	console.log(`new strike key:${chosenKey}`);
	 			  	 	   	 	gameManager.storeKeyDataToLocalStorage();
	 			  	 	   	 }
	 			  	 	   	else 
	 			  	 	   		this.showDisappearingMessage("duplicate key");
	 			  	 	   break;
	 			  	 	 case 4:
	 			  	 	   if(gameManager.isNewKey(chosenKey))
	 			  	 	   	 {
	 			  	 	   	 	gameManager.allKeys[3]=chosenKey;
	 			  	 	   	 	gameManager.healKey=chosenKey;
	 			  	 	   	 	console.log(`new heal key:${chosenKey}`);
	 			  	 	   	 	gameManager.storeKeyDataToLocalStorage();
	 			  	 	   	 }
	 			  	 	   	else 
	 			  	 	   		this.showDisappearingMessage("duplicate key");
	 			  	 	   break;
                        case 5:
                           if(gameManager.isNewKey(chosenKey))
                             {
                                gameManager.allKeys[4]=chosenKey;
                                gameManager.castKey=chosenKey;
                                console.log(`new cast key:${chosenKey}`);
                                gameManager.storeKeyDataToLocalStorage();
                             }
                            else 
                                this.showDisappearingMessage("duplicate key");
                           break;
	 			  	 	}
	 			  	}
	 			  
	 			}
		 	}

		 showStats()
		 	{
		 	 if(this.keyFocussed!=-1) 
		 	 	this.keyFocussed=-1;
		 	 let startx=this.position.x -this.width*0.4;
		 	 let starty=this.position.y - this.height*0.4;
		 	 let shifts=[[100,0],[-100,80],[0,80],[0,80],[0,220],[500,0]];
		 	 let dialogues=["Use Arrow keys to navigate",
		 	 			    "Health :"+this.go.maxHealth,
		 	 			    "Energy :"+this.go.maxEnergy,
		 	 			    "Weapon Damage:"+this.go.weaponDamage,
		 	 			    "Exp Needed:"+this.go.expNeeded,
		 	 			    "Exp:"+this.go.experience
		 	 			   ];
		 	 for(let i in dialogues)
		 	 	{	
		 	 	 startx+=shifts[i][0];
		 	 	 starty+=shifts[i][1];
		 	 	 if(i==this.focussed ||(this.go.experience < this.expNeeded && i==5))
		 	 	 w2screen(dialogues[i],startx,starty,'#FF0000');
		 	 	 else
		 	 	 w2screen(dialogues[i],startx,starty); 
		 	 	}
		 	}
		}
	 //Parallax class starts
//constructor of GeneralSprite(x,y,wid,hei,hitboxoffsetx,hitboxoffsety,spriteGroups)
	class Parallax extends GeneralSprite
		{
		 constructor(imagex,spriteGroups,widthToBeDisplayed,heightToBeDisplayed,fullWidth,fullHeight,xSpeed,ySpeed)
		 	{
		 	 super(0,0,975,640,0,0,spriteGroups);
		 	 
		 	 this.imagex=imagex;
		 	 this.startPoint=new CreateVector(0,0);
		 	 this.wTD=widthToBeDisplayed;
		 	 this.hTD=heightToBeDisplayed;
		 	 this.fullWidth=fullWidth;
		 	 this.fullHeight=fullHeight;
		 	 this.speed=new CreateVector(xSpeed,ySpeed);		 	 
		 	}
		 update()
		 	{

		 	 this.startPoint.add(this.speed);
		 	 if(this.startPoint.x+this.wTD >= this.fullWidth)
		 	 	this.startPoint.x=0;
		 	 if(this.startPoint.y+this.hTD>=this.fullHeight) 
		 	 	this.startPoint.y=0;
		 	}
		 display()
		 	{		 	
		 	  ctx.drawImage(this.imagex,
		 	  			    this.startPoint.x,this.startPoint.y,
		 	  			    this.wTD,this.hTD,
		 	  			    this.position.x,this.position.y,
		 	  			    canvas.width,canvas.height
		 	  			   );
		 	}

		}
	//Parallax class ends


	class GameManager
		{
		 constructor()
		 	{
		 	 this.visible_sprites=[];
             this.wall_grippers=[];		 	 
		 	 this.active_sprites=[];
		 	 this.kill_plants=[];
		 	 this.killables=[];
		 	 // this.elevatorboxes=[]; delete me
		 	 this.loot=[];		 	 		 	 
		 	 this.collission_sprites=[];
		 	 this.markedSpots=[];
		 	 this.hitbox_sprites=[];
		 	 this.enemy_sprites=[];
		 	 this.camera_stop_sprites=[];
		 	 this.entryexit_sprites=[];
		 	 this.camera=new Camera(0,0);
		 	 this.scenesReady=[];
		 	 this.scenesLoaded=[];
		 	 this.listOfDestroyedSprites=[];
		 	 		 	 
		 	 this.testing=false;
		 	 this.playerDiedClock = 0;		 	 
		 	 this.runningClock=0;		 	 
		 	 this.player=null;
		 	 this.tempCounter=0;
		 	 this.gamePaused=false;
		 	 this.inTransition=false;
		 	 this.sceneForward=true;
		 	 this.followMouse=false;
		 	 this.sceneStartTime= 0;
		 	 this.positionAdjuster=new PositionAdjuster(null,[this.visible_sprites,this.active_sprites]);

		 	 this.playerHealthBar= new UIBar(50,20,300,30,100,100,'#222222','#FF0000',[this.visible_sprites,this.active_sprites],true,'playerhealth');
			 this.playerEnergyBar= new UIBar(50,100,300,30,100,100,'#222222','#0000FF',[this.visible_sprites,this.active_sprites],true,'playerenergy');
			 this.levelUpBox=new LevelUpBox(this.player);			 
			 this.localStorageChecked=false;
			 this.bottomY=2000;
			 this.playerDied=false;

			 this.onStartUpScreen=true;
			 this.loader_ui_visiblesprites=[];
			 this.loadedStartScreen=false;

			 this.dashKey="c";
			 this.jumpKey=" ";
			 this.strikeKey="z";
			 this.healKey="q";
             this.castKey="x";
			 this.allKeys=[this.jumpKey,this.dashKey,this.strikeKey,this.healKey,this.castKey];
		 	
		 	 this.screenShakeTimer=0;
		 	 this.maxScreenShakeTime=500;
		 	 
		 	 this.maxFreezeTime=4000;
		 	 this.lastScreenFreeze=0;
		 
		 	}
		 MindScreenFreeze(){
		 	if(this.lastScreenFreeze==0) return false;
		 	if(this.runningClock-this.lastScreenFreeze>this.maxFreezeTime)
		 		this.lastScreenFreeze=0;

		 }
		 FreezeScreen(){
		 	return false;//not working
		 	this.lastScreenFreeze=this.runningClock;
		 }
		 MindScreenShake(){
		 	
		 	if(this.screenShakeTimer==0) return;
		 	if(gameManager.runningClock - this.screenShakeTimer > this.maxScreenShakeTime)
		 		{		 		
		 		this.screenShakeTimer=0;
		 	    this.camera.shakeVals[0]=0;
		 	    this.camera.shakeVals[1]=0;
		 	    return;
		 	    }
		 	this.camera.shakeVals[0]=Math.random()*20;
		 	this.camera.shakeVals[1]=Math.random()*20;
		 }
		 isNewKey(keyx){
            // console.log('checking:'+keyx);
		 	for(let i in this.allKeys)	{	
                 // console.log('found '+this.allKeys[i]); 		
		 		 if(this.allKeys[i]==keyx) return false;
                }
		 	return true;		 		
		 }
		 togglePauseScreen(){
		 	if(!this.player || this.playerDied) return false;
		 	if(this.player.inEnemyRadar && !this.gamePaused)
		 		{
		 		 console.log('Cant do pause screen right now');		 		 
		 		}
		 	else 
		 		{
		 		 this.gamePaused=!this.gamePaused;
		 		}

		 }
		 getKeyDataFromLocalStorage(){
		 	let keyData=localStorage.getItem("gameKeyData");
		 	if(!keyData) return false;
		 	keyData=JSON.parse(keyData);
		 	this.jumpKey=keyData.jumpKey;
		 	this.dashKey=keyData.dashKey;
		 	this.strikeKey=keyData.strikeKey;
		 	this.healKey=keyData.healKey;
            if (keyData.castKey)
            this.castKey=keyData.castKey;
		 	this.allKeys=[this.jumpKey,this.dashKey,this.strikeKey,this.healKey,this.castKey];
		 }
		 storeKeyDataToLocalStorage(){
		 	let keyData={"jumpKey":this.jumpKey,"dashKey":this.dashKey,
		 	             "strikeKey":this.strikeKey,"healKey":this.healKey,"castKey":this.castKey
		                };
		    localStorage.setItem("gameKeyData",JSON.stringify(keyData));
		 }

		 getLocalStoragex(){
		 	/*
		 	let localStorage_local={"sceneNo":2,
		 						    "player":{"health":80,"maxHealth":200,"weaponDamage":20,"exp":100,"maxEnergy":100}
		 	                       };
		 	*/
		 	let localStorage_local = localStorage.getItem("GameSaveData");
		 	if(!localStorage_local) return false;
		 	localStorage_local= JSON.parse(localStorage_local);
		 	return localStorage_local; 
		 }

		 saveStatusToLocalStoragex(){
		 	let sceneNo= this.scenesLoaded.filter(x=>x).length;
		 	let datum={"sceneNo":sceneNo,
					   "player":{"health":this.player.health,
					             "maxHealth":this.player.maxHealth,
					             "weaponDamage":this.player.weaponDamage,
					             "exp":this.player.experience,
					             "maxEnergy":this.player.maxEnergy
					            },
					   "listOfDestroyedSprites":this.listOfDestroyedSprites
                      };
            localStorage.setItem("GameSaveData",JSON.stringify(datum));
		 }
		 checkPlayerExistence()
		 	{		 	 
		 	 if(this.playerDiedClock ==0) return false;
		 	 w2screen("You Got Destroyed Bruh",300*xscale,400*yscale,'#FF0000',80);
		 	 if(this.runningClock - this.playerDiedClock > 1500)
		 	 	{
		 	 	console.log('time up reloading now');
		 	 	// window.location.href="./Platformer.html";
                this.playerDiedClock=0;
                this.playerDied=false;
		 	 	this.changeScene('none');
		 	    }
		 	}
		 checkHitWithKillPlants()
		 	{
		 	 for(let x of this.kill_plants)
		 	 {
		 	 	for(let y of this.killables)
		 	 		{
		 	 			if(b_collision(x,y.hit_box))
		 	 			{
		 	 				y.takeDamage(y.health);
		 	 				console.log(y.sprite_type+' got thorned');
		 	 			}
		 	 		}
		 	 }
		 	}

		 unload_components()
		 	{		 	
		 	this.collission_sprites=[];
		 	this.camera_stop_sprites=[];
		 	this.entryexit_sprites=[];
		 	this.markedSpots=[];
		 	this.kill_plants=[];
		 	this.killables=[];
		 	this.enemy_sprites=[];

		 	if(!this.player)
		 		{
		 		this.visible_sprites=[this.playerHealthBar,this.playerEnergyBar,this.positionAdjuster];
		 		this.active_sprites=[this.playerHealthBar,this.playerEnergyBar,this.positionAdjuster];	
		 		}
		 	else{
		 		this.visible_sprites=[this.player,this.positionAdjuster,this.playerHealthBar,this.playerEnergyBar];
		 		this.active_sprites=[this.player,this.positionAdjuster,this.playerHealthBar,this.playerEnergyBar];
		 		this.killables=[this.player];
		 		this.collission_sprites=[this.player.hit_box];
		 		this.player.spriteGroups=[this.visible_sprites,this.active_sprites,this.killables];		
		 		this.player.inEnemyRadar=false; 		
		 		}
		 			 	
		 	}

		 runClock()
		 	{
	 		this.runningClock+=deltaTime;
	 		if(this.runningClock > 300000) this.runningClock=0;
		 	}

		 showExperience()
		 	{
		 	 if(!this.player) return false;
		 	 w2screen("Exp:"+this.player.experience,canvas.width-100,canvas.height-50);
		 	 w2screen("Weapon:"+this.player.weaponDamage,20,canvas.height-50);
		 	}

		 update()
		 	{
		 	 //DisplayInGaps(this.collission_sprites.map(x=>x.sprite_type).reduce((s,x)=>s+x+',',''));	
		 	 this.runClock();

		 	 if(this.onStartUpScreen)
		 	 	{
		 	 	  this.showStartScreen();                  
		 	 	  return;
		 	 	} 	 
		 	 
		 	 this.runGame();		 	 		 	 
		 	 this.checkScenes();	
		 	 this.showExperience();	
		 	 this.showLevelUpBox(); 
		 	}
		 performButtonPressFn(btnName)
		 	{
		 		if(btnName=="Continue")
		 		this.onStartUpScreen=false;
		 		else if(btnName=="Start")
		 		{
		 			localStorage.removeItem("GameSaveData");
					 // window.location.href='Platformer.html';
					 this.onStartUpScreen=false;
		 		}

		 	}
		 showStartScreen()
		 	{	
		 	 if(!this.loadedStartScreen)
		 	 	{
		 	 		this.loadedStartScreen=true;
		 	 		this.onStartUpScreen=true;
		 	 		//constructor(x,y,wid,hei,tex,btnType,btnGroups,btnName,parentPanel) 
		 	 		//constructor(imagex,spriteGroups,widthToBeDisplayed,heightToBeDisplayed,fullWidth,fullHeight,xSpeed,ySpeed)
		 	 		new Parallax(FORESTBACKGROUND,[this.loader_ui_visiblesprites],
		 	 					 1000,3500,
		 	 					 5250,3500,2,0
		 	 			        ); 
		 	 		new GenericButton(0.4*canvas.width,0.4*canvas.height,
		 	 			       200,80,
		 	 			       "Start","Start",
		 	 			       [this.loader_ui_visiblesprites],"Start",
		 	 			       null
		 	 			      );
		 	 		if(localStorage.getItem("GameSaveData"))
		 	 			new GenericButton(0.4*canvas.width,0.6*canvas.height,
		 	 			       200,80,
		 	 			       "Continue","Continue",
		 	 			       [this.loader_ui_visiblesprites],"Continue",
		 	 			       null
		 	 			      );

		 	 	}	 			
		 	 for (let sp of this.loader_ui_visiblesprites)
		 		{
		 		  sp.update();
		 		  sp.display();
		 		}
		 	}
		 showLevelUpBox()
		 	{
		 	 this.levelUpBox.update();
		 	 this.levelUpBox.display();
		 	}
		 changeScene(sc_id)
		 	{		
		 	 this.inTransition=true; 	 		 	 
		 	 

		 	 if(sc_id=="scright")
		 	 	{
		 	 	 this.sceneForward=true;
		 	 	 this.scenesReady.push(true);
		 	 	 this.scenesLoaded.push(false);
		 	 	}
		 	 else if(sc_id=="scleft")
		 	 	{
		 	 	console.log('going back to previous scene');
		 	 	this.sceneForward=false;
	 	 		this.scenesReady.pop();
	 	 		this.scenesLoaded.pop();
	 	 		this.scenesLoaded[this.scenesLoaded.length-1]=false;
		 	 	}
		 	 else
		 	 	{
		 	 	this.sceneForward=true;
		 	 	this.scenesLoaded[this.scenesLoaded.length-1]=false;
		 	 	this.localStorageChecked=false;
		 	 	}
		 	}

		 placePlayerOnEntryExit(ent_ex)
		 	{
	 		for(let elem of this.entryexit_sprites)
	 			{
 				if(elem.sprite_type==ent_ex)
 					{
 					 // console.log(`player placed at ${elem.position.x},${elem.position.y} of ${elem.sprite_type}`);
 					 gameManager.player.hit_box.position.setVec(elem.position);
 					}
	 			}
		 	}

		 camChecker()
		 	{
		 	 if(gameManager.playerDied) return [false,false];
		 	 if(!(this.camera.tgt && this.camera.tgt==this.player))
		 	 	{		 	 	
		 	 	return [true,true];
		 	 	}
		 	 let resultMat=[true,true];		 	 
		 	 for(let camstopper of this.camera_stop_sprites)
		 	 	{
		 	 	 resultMat=camstopper.cameraCanFollow(this.player).map((x,i)=>x?resultMat[i]:false);		 	 	 
		 	 	}
		 	 return resultMat;
		 	}
		 
		 runGame()
		 	{
		 	 this.MindScreenShake();
		 	 this.MindScreenFreeze();
		 	 this.checkHitWithKillPlants();
		 	 if(!this.gamePaused)	this.checkPlayerExistence();		 	
		 	 const [hori,vert]=this.camChecker();
		 	 if(!this.followMouse)
			 	 {			 	 
			 	 this.camera.smoothFocus(hori,vert);
			 	 }
			 else
			 	 {
			 	 	if(this.runningClock - this.sceneStartTime < 2000)			 	 	
			 	 	 this.camera.smoothFocus(hori,vert);
			 	 	else
			 	 	 this.camera.runWithMouse();
			 	 }

		 	 for(let sprite of this.visible_sprites)
		 	 	{		 	 			 	 	
		 	 	sprite.display();
		 	 	}
		 	 for(let sprite of this.active_sprites)
		 	 	{
		 	 	if(!gameManager.gamePaused && this.lastScreenFreeze==0)	 
		 	 		{	 	
		 	 		sprite.update();	
		 	 		}
		 	 	
		 	 	}
		 	 /*	
		 	 for(let hb of this.elevatorboxes)
		 	 	{
		 	 	if(b_collision(hb,this.player.hit_box))
		 	 		{
		 	 			
		 	 			if(this.player.hit_box.position.y<=hb.position.y){
		 	 				this.player.hit_box.position.y=hb.position.y-hb.width/2-5*yscale;
		 	 				this.player.velocity.y=0;
		 	 			}
		 	 			else
		 	 				this.player.hit_box.position.y=hb.position.y+hb.width/2+5*yscale;
		 	 		}
		 	 	}
		 	 */

		 	 for(let hb of this.hitbox_sprites)
		 	 	{
		 	 	 if(gameManager.gamePaused)
		 	 	 	continue;
		 	 	 if(hb.sprite_type=="player_hitbox")
		 	 	 	{
		 	 	 	 for(let sprite of this.enemy_sprites)
		 	 	 	 	{
		 	 	 	 		/*
		 	 	 	 		//deleteable for confirming that a shorter wider collison box fails to detect its collision with
		 	 	 	 		  a longer thinner box. None of the points of one are within the other.
		 	 	 	 	if(sprite.sprite_type=="TraitorLord") 
		 	 	 	 		{
		 	 	 	 			console.log('coordinates follow')
		 	 	 	 			let px=sprite.hit_box.position.x;
		 	 	 	 			let py=sprite.hit_box.position.y;
		 	 	 	 			let w=sprite.hit_box.width;
		 	 	 	 			let h=sprite.hit_box.height;
		 	 	 	 			console.log(`${(px-w/2).toFixed(0)},${(py-h/2).toFixed(0)} ${(px+w/2).toFixed(0)},${(py-h/2).toFixed(0)} ${(px-w/2).toFixed(0)},${(py+h/2).toFixed(0)} ${(px+w/2).toFixed(0)},${(py+h/2).toFixed(0)}`);
		 	 	 	 			 px=hb.position.x;
		 	 	 	 			 py=hb.position.y;
		 	 	 	 			 w=hb.width;
		 	 	 	 			 h=hb.height;
		 	 	 	 			console.log(`${(px-w/2).toFixed(0)},${(py-h/2).toFixed(0)} ${(px+w/2).toFixed(0)},${(py-h/2).toFixed(0)} ${(px-w/2).toFixed(0)},${(py+h/2).toFixed(0)} ${(px+w/2).toFixed(0)},${(py+h/2).toFixed(0)}`);
		 	 	 	 		}
		 	 	 	 		*/	 	 	 	 	 
		 	 	 	 	 if(b_collision(sprite.hit_box,hb))
		 	 	 	 	 	{	
                             gameManager.player.fillHitCredits();	 	 	 	 	 		
		 	 	 	 	 	 hb.causeDamage(sprite);		 	 	 	 	 	 	
		 	 	 	 	 	}
		 	 	 	 	}
                     for(let x of gameManager.loot)
                        {
                        if(b_collision(hb,x))
                            {                    
                             x.giveExp(gameManager.player);                    
                            }
                        }
		 	 	 	}
		 	 	 else if(hb.sprite_type=="enemy_hitbox")
		 	 	 	{
		 	 	 	  if(!gameManager.player) continue;		 	 	 	  
		 	 	 	  if(b_collision(gameManager.player.hit_box,hb))
		 	 	 	  	{
		 	 	 	  	hb.causeDamage(gameManager.player);
		 	 	 	    }
		 	 	 	}
		 	 	}
		 	}
		 alterSceneData()
		 	{
		 	 if(this.localStorageChecked)
		 	 	{		 	 	
		 	 	return false;
		 	    }
		 	 this.localStorageChecked=true;		 	 
		 	 let localStoragex=this.getLocalStoragex();
		 	 this.getKeyDataFromLocalStorage();
		 	 if(!localStoragex) 
		 	 	{
		 	 	console.log('nothing in localstorage..returning');
                this.sceneForward=[true];
                this.scenesLoaded=[false];
		 	 	return true;
		 	 	}
		 	let scene=localStoragex.sceneNo;

 	 	 	this.player=new Player(100*xscale,
		   	   					   200*yscale,
							   	   150*xscale,
							   	   200*yscale,
							   	   [this.visible_sprites,this.active_sprites,this.killables]
		   	   					  );
 	 	 	console.log('player loaded from memory');
 	 	 	this.levelUpBox.receiveGameObject(this.player);
 	 	 	if(localStoragex.listOfDestroyedSprites)
 	 	 		this.listOfDestroyedSprites=localStoragex.listOfDestroyedSprites;
 	 	 	this.player.receiveParams(localStoragex.player.health,
 	 	 		                      localStoragex.player.maxHealth,
 	 	 		                      localStoragex.player.maxEnergy,
 	 	 		                      localStoragex.player.weaponDamage,
 	 	 		                      localStoragex.player.exp 	 	 		                      
 	 	 		                     );

		 	 for(let i=0;i < scene;i++)
		 	 	{
		 	 	 this.scenesReady[i]=true;
		 	 	 this.scenesLoaded[i]=true;
		 	 	}
		 	 this.scenesLoaded[this.scenesLoaded.length-1]=false;

		 	 // console.log(JSON.stringify(this.scenesReady));
		 	 // console.log(JSON.stringify(this.scenesLoaded));
		 	}
		 checkScenes()
		 	{
		 	 this.alterSceneData();
		 	 let n=this.scenesReady.length;		 	 
		 	 if(n==0)
		 	 	{
		 	 	 this.scenesReady[0]=true;
		 	 	 this.scenesLoaded[0]=false;
		 	 	 n+=1;
		 	 	}
		 	 for(let i=0;i<n;i++)
			 	 {
			 	 if(this.scenesReady[i]==true && this.scenesLoaded[i]==false)
			 	 	{
			 	 	// if(!(n==1 && this.sceneForward) && !this.testing)
			 	 	this.unload_components();
			 	 	this.loadScene(i);
			 	 	break;
			 	 	}
			 	 }
		 	}
		 loadScene(n)
		 	{
		 	this.tempCounter+=1;
		 	console.log('gameManager called '+this.tempCounter+ ' times for scene:'+n);
		 	if(this.tempCounter > 50) 
		 		{
		 		console.log('something is wrong');
		 		return false;
		 		}
		 	 // this.unload_components();		 	 
		 	 for(let elem of scenes[n])
		 	 	{
		 	 	/*
		 	 	 if (this.player || (!this.testing && elem['sprite']=='player' && (n!=0 || !this.sceneForward) ) )
		 	 	 	continue;
		 	 	 */
		 	 	 if(elem['sprite']=='player' && (this.player) )
		 	 	 	continue;
		 	 	 if(elem['sprite']=='platform')
		 	 	 	new Platform(elem['x']*xscale,
		 	 	 				 elem['y']*yscale,
		 	 	 				 elem['width']*xscale,
		 	 	 				 elem['height']*yscale,
		 	 	 				 [this.visible_sprites,this.collission_sprites]
		 	 	 				);
                 else if(elem['sprite']=='WallGripper')
                    new WallGripper(elem['x']*xscale,
                                 elem['y']*yscale,
                                 elem['width']*xscale,
                                 elem['height']*yscale,
                                 [this.visible_sprites,this.wall_grippers]
                                );
		 	 	 else if(elem['sprite']=='player')	
		 	 	 	{		 	 	 		 	 	 	
		 	 	 	this.player=new Player(elem['x']*xscale,
		 	 	 		   	   elem['y']*yscale,
		 	 	 		   	   elem['width']*xscale,
		 	 	 		   	   elem['height']*yscale,
		 	 	 		   	   [this.visible_sprites,this.active_sprites,this.killables]
		 	 	 		   	   );	
		 	 	 	console.log('player loaded from scene data');
		 	 	   this.levelUpBox.receiveGameObject(this.player);
		 	 	   }		 	 	 
		 	 	 else if(elem['sprite'].split('_')[0]=='camstopper')
		 	 	 	new CameraStopper(elem['x']*xscale,
		 	 	 		   	   elem['y']*yscale,
		 	 	 		   	   elem['sprite'],
		 	 	 		   	   [this.visible_sprites,
                                this.camera_stop_sprites,this.active_sprites]
		 	 	 		   	   );
		 	 	 else if(elem['sprite'].split('_')[0]=='entryexit')
		 	 	 	new EntryExitPoint(elem['x']*xscale,
		 	 	 		   	   elem['y']*yscale,
		 	 	 		   	   elem['sprite'].split('_')[1],
		 	 	 		   	   [this.visible_sprites,this.entryexit_sprites,this.active_sprites]
		 	 	 		   	   );
		 	 	 else if(elem['sprite'].split('_')[0]=='scenechanger')
		 	 	 	new SceneChanger(elem['x']*xscale,
		 	 	 		   	   elem['y']*yscale,
		 	 	 		   	   elem['sprite'].split('_')[1],
		 	 	 		   	   [this.visible_sprites,this.active_sprites]
		 	 	 		   	   );		 	 	 
		 	 	 else if(elem['sprite']=='husk' && this.listOfDestroyedSprites.indexOf(elem['spriteId'])==-1)	 	 	 	
		 	 	 	  new Husk(elem['x']*xscale,
		 	 	 		   	   elem['y']*yscale,
		 	 	 		   	   elem['width']*xscale,
		 	 	 		   	   elem['height']*yscale,
		 	 	 		   	   [this.visible_sprites,this.enemy_sprites,this.active_sprites,this.killables],
                               elem['dialogue']?elem['dialogue']:[],
		 	 	 		   	   elem['spriteId']
		 	 	 		   	   );
		 	 	 else if(elem['sprite']=='traitorLord' && 
		 	 	 	     this.listOfDestroyedSprites.indexOf(elem['spriteId'])==-1)	 	 	 	
		 	 	 	  new TraitorLord(elem['x']*xscale,
		 	 	 		   	   elem['y']*yscale,
		 	 	 		   	   elem['width']*xscale,
		 	 	 		   	   elem['height']*yscale,
		 	 	 		   	   [this.visible_sprites,
		 	 	 		   	    this.enemy_sprites,
		 	 	 		   	    this.active_sprites,
		 	 	 		   	    this.killables],                               
		 	 	 		   	   elem['spriteId']
		 	 	 		   	   ); 
		 	 	 else if(elem['sprite']=='lance')		 
                    {	 	 
                      if(this.listOfDestroyedSprites.indexOf(elem['spriteId'])==-1)	
		 	 	 	  new Lance(elem['x']*xscale,
		 	 	 		   	   elem['y']*yscale,
		 	 	 		   	   elem['width']*xscale,
		 	 	 		   	   elem['height']*yscale,
		 	 	 		   	   [this.visible_sprites,this.enemy_sprites,this.active_sprites],
		 	 	 		   	   elem['spriteId']
		 	 	 		   	   );
                      else
                        DestroyAllBarriersInScene();
                    }
		 	 	 else if(elem['sprite']=='falseknight' &&  this.listOfDestroyedSprites.indexOf(elem['spriteId'])==-1)		 	 	 	
		 	 	 	  new FalseKnight(elem['x']*xscale,
		 	 	 		   	   elem['y']*yscale,
		 	 	 		   	   elem['width']*xscale,
		 	 	 		   	   elem['height']*yscale,
		 	 	 		   	   [this.visible_sprites,this.enemy_sprites,this.active_sprites],
		 	 	 		   	   elem['spriteId'],elem['spawnedBoss']
		 	 	 		   	   );
		 	 	 else if(elem['sprite'].split('_')[0]=='MarkedSpot')
		 	 	 	new MarkedSpot(elem['x']*xscale,
		 	 	 		   	   elem['y']*yscale,
		 	 	 		   	   elem['sprite'].split('_')[1],
		 	 	 		   	   [this.visible_sprites,this.markedSpots]
		 	 	 		   	   );
		 	 	 else if(elem['sprite']=='BossFightTriggGO' &&  
		 	 	 		 this.listOfDestroyedSprites.indexOf(elem['spriteId'])==-1)
		 	 	 	new BossFightTriggGO(elem['x']*xscale,
		 	 	 		   	   elem['y']*yscale,
                               elem['mywidth']*xscale,
                               elem['myheight']*yscale,
		 	 	 		   	   elem['br1posx']*xscale,
		 	 	 		   	   elem['br1posy']*yscale,
		 	 	 		   	   elem['br2posx']*xscale,
		 	 	 		   	   elem['br2posy']*yscale,		 	 	 		   	   
		 	 	 		   	   [this.active_sprites],
		 	 	 		   	   elem['spriteId']
		 	 	 		   	   );
		 	 	 else if(elem['sprite']=='huskMiner' &&  
		 	 	 	     this.listOfDestroyedSprites.indexOf(elem['spriteId'])==-1)		 	 	 	
		 	 	 	  new HuskMiner(elem['x']*xscale,
		 	 	 		   	   elem['y']*yscale,
		 	 	 		   	   elem['width']*xscale,
		 	 	 		   	   elem['height']*yscale,		 	 	 		   	   
		 	 	 		   	   [this.visible_sprites,this.enemy_sprites,this.active_sprites],
		 	 	 		   	   elem['spriteId'],
		 	 	 		   	   elem['cutscene']
		 	 	 		   	   );
		 	 	 else if(elem['sprite']=='tree')		 	 	 	  
		 	 	 	new BarrierTree(elem['x']*xscale,
    	 	   				        elem['y']*yscale,
    	 	   				        elem['width']*xscale,
    	 	   				        elem['height']*yscale,
    	 	   				   		[gameManager.visible_sprites]
    	 	   				  	 	);
    	 	   	 else if(elem['sprite']=='thorn')
    	 	   	 	new Thorn(elem['x']*xscale,
 	   				          elem['y']*yscale,
 	   				          elem['width']*xscale,
 	   				          elem['height']*yscale,
 	   				          elem['xoffset']*xscale,
 	   				          elem['yoffset']*yscale,
 	   				   		  [gameManager.visible_sprites]
    	 	   				  	 	);	
    	 	   	 else if(elem['sprite']=='flower'&&  
		 	 	 	     this.listOfDestroyedSprites.indexOf(elem['spriteId'])==-1)
    	 	   	 	new Flower(elem['x']*xscale,
 	   				          elem['y']*yscale,
 	   				          elem['width']*xscale,
 	   				          elem['height']*yscale,
 	   				          elem['xoffset']*xscale,
 	   				          elem['yoffset']*yscale,
 	   				          elem['exp'],elem['spriteId'],
 	   				   		  [gameManager.visible_sprites,gameManager.loot]
    	 	   				  	 	);
    	 	   	 else if(elem['sprite']=='saw')
    	 	   	 	new SawWheel(elem['x']*xscale,
 	   				          elem['y']*yscale,
 	   				          elem['width']*xscale,
 	   				          elem['height']*yscale,
 	   				          elem['xoffset']*xscale,
 	   				          elem['yoffset']*yscale,
 	   				   		  [gameManager.visible_sprites,gameManager.active_sprites],
 	   				   		  elem['moveTime'],elem['moveTimeInit'],elem['speed'],elem['isHoriWheel']
    	 	   				  	 	);
    	 	   	 else if(elem['sprite']=='shrub')
    	 	   	 	new GrassShrub(elem['x']*xscale,
 	   				          elem['y']*yscale,
 	   				          elem['width']*xscale,
 	   				          elem['height']*yscale,
 	   				          elem['xoffset']*xscale,
 	   				          elem['yoffset']*yscale,
 	   				   		  [gameManager.visible_sprites]
    	 	   				  	 	);
    	 	   	 else if(elem['sprite']=='wall')
                 {
                    let dTime=0;
                    if("dTime" in elem)
                        dTime=elem['dTime'];
    	 	   	 	new Wall(elem['x']*xscale,
 	   				          elem['y']*yscale,
 	   				          elem['width']*xscale,
 	   				          elem['height']*yscale,
 	   				          elem['isHorizontal'], 
 	   				          elem['copies'],	   				          
 	   				   		  [gameManager.visible_sprites,gameManager.active_sprites],
                              dTime
    	 	   				  	 	);	 	
                  } 	
                 else if(elem['sprite']=='Elevator')
                  {
                  	new Elevator(elem['x']*xscale,
                  		 		 elem['y']*yscale,
                  		 		 elem['width']*xscale,
                  		 		 elem['height']*yscale,elem['turnTime'],
                  		 		 [gameManager.visible_sprites,gameManager.active_sprites]
                  		        );
                  } 
                 else if(elem['sprite']=='MovingPlatform')
                  {
                    new MovingPlatform(elem['x']*xscale,
                                 elem['y']*yscale,
                                 elem['width']*xscale,
                                 elem['height']*yscale,elem['turnTime'],
                                 [gameManager.visible_sprites,
                                 gameManager.active_sprites
                                 ]
                                );
                  } 	
		 	 	}
		 	 this.placePlayerOnEntryExit(this.sceneForward?'entry':'exit');		 	 
		 	 this.camera.tgt=this.camera_stop_sprites[this.sceneForward?0:1];
		 	 this.scenesLoaded[n]=true;
		 	 this.inTransition=false;
		 	 this.sceneStartTime= this.runningClock;		 	 
		 	 console.log('scene No'+n+' loaded');
		 	 presentMusicIndex=n;
		 	 // musicStarted=false;
		 	 pauseMusic();
		 	 startMusic();
		 	}
		}
    const drawCircleAtCenter=()=>{
        var r = 100; 
        var x = canvas.width / 2;
        var y = canvas.height / 2;       
        ctx.globalCompositeOperation = 'destination-out';
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();       
        ctx.globalCompositeOperation = 'source-over';
    }
    const unmaskcenter=()=>{
     let r=300;
     // ctx.fillStyle=backGroundColor;
     // ctx.globalAlpha = 0.5;
     // ctx.fillRect(0,0,canvas.width, canvas.height);
     // ctx.globalAlpha = 1;

     let lineWidth=400;
     ctx.beginPath();
     for(let i=0;i<1;i++)
        {
         ctx.arc(canvas.width / 2,  canvas.height / 2, r, 0, 2 * Math.PI);
         ctx.strokeStyle = 'black';
         ctx.lineWidth = lineWidth;
         ctx.stroke();
        }
     ctx.lineWidth = 1;
   
    }
	let gameManager=new GameManager();
	//Game Classes End

	window.addEventListener('load', 
							function () 
									{
								 	resize();									
							 		var loop = function () 
													{                 					
													ctx.clearRect(0,0,canvas.width,canvas.height);	
													ctx.fillStyle = backGroundColor;
													ctx.fillRect(0,0,canvas.width, canvas.height);                                                    
													gameManager.update();	
                                                    
                                                    // unmaskcenter();
													// showMouse();		
				                                 	};
					  	     		setInterval(loop, deltaTime);					  		
									}
							);
	
</script>  
</canvas>
</body>
</html>