<head>
	<script>
	let mouseX,mouseY;
	let camX=0,camY=0;
	let deltaTime=1000 / 60;
	let pauseGame=false;
	let upPress,leftPress,downPress,rightPress,fPress,gPress,enterPress,mousePressed,mouseDoubleTap,spacePress;
	let backGroundColor="#16a1b3";
	
	function trackMouse(e)
		{
		mouseX=e.clientX;
		mouseY=e.clientY;
		};
    function w2screen(strr = "", px = 20, py = 30) 
    	{
	      ctx.font = "40px Haettenschweiler";
	      ctx.fillStyle = "#FFFFFF";
	      ctx.fillText(strr, px, py);
    	}
//hfns starts

	function NumToHex(num)
		{
			let refDict=["A","B","C","D","E","F"];
			let hexval="";
			let limiter=0;
			while(num > 0)
			{
				let lastDigit=num % 16;
				if(lastDigit > 9)
					hexval=refDict[lastDigit-10]+hexval;
				else
					hexval=""+lastDigit+hexval;
				num=parseInt(num/16);
				limiter+=1;
				if(limiter > 10)
					{
					console.log('error');
					break;
					}
			}
			return "#"+hexval;

		}
	function RandomColor()
		{
			return NumToHex(Math.floor(random(0,255))*16**4+Math.floor(random(0,255))*16**2+Math.floor(random(0,255)));
		}

	function GetRAVec(a,angle)
		{
			let t=d2r(angle);
			let xval= a.x * Math.cos(t)+a.y * Math.sin(t);
			let yval=-a.x * Math.sin(t)+a.y * Math.cos(t);
			return new createVector(xval,yval);
		}
	function GetrRAVec(a,angle)
		{
			let t=d2r(angle);
			let xval= a.x * Math.cos(t)-a.y * Math.sin(t);
			let yval= a.x * Math.sin(t)+a.y * Math.cos(t);
			return new createVector(xval,yval);
		}
	function CheckCollisionAdvanced(obj1,obj2)
		{
			return tiltedCollsion(obj1,obj2)||tiltedCollsion(obj2,obj1);
		}
	function tiltedCollision(obj1,obj2)
		{
			return false;//continue from here
			obj2_clone={"width":obj2.width,
			            "height":obj2.height,
			            "position":0};
			obj2_clone.position=GetrRAVec(obj2.position,obj2.rotangle);
		}

	function createdVec(x,y)
		{
			return new createVector(x,y);
		}

    function random(x,y)
    	{
    		if(y)
    		{
    			return Math.random()*(y-x)+x;
    		}
    		return Math.random()*x;
    	}
    function r2d(angle) 
        {
            return angle/Math.PI * 180;
        }
    function d2r(angle)
        {
            return angle/180*Math.PI;
        }

    function VecMult(vec,x)
    	{
    		let newVec=vec.copy();
    		newVec.mult(x);
    		return newVec;
    	}
    function VecDiv(vec,x)
    	{
    		let newVec=vec.copy();
    		newVec.div(x);
    		return newVec;
    	}
    function VecAdd(vec1,vec2)
    	{
    		let newVec=vec1.copy();
    		newVec.set(vec1.x+vec2.x,vec1.y+vec2.y);
    		return newVec;
    	}
    function VecSub(vec1,vec2)
    	{
    		let newVec=vec1.copy();
    		newVec.set(vec1.x-vec2.x,vec1.y-vec2.y);
    		return newVec;
    	}
    function VecDot(vec1,vec2)
    	{
    		return vec1.x*vec2.x+vec1.y*vec2.y;
    	}
    function VecDist(vec1,vec2)
    	{
    		let res=VecSub(vec1,vec2);
    		return res.mag();
    	}
    function createVector(x,y)
        {
            this.x=x;
            this.y=y;
            
            this.copy=()=>
                {
                    let newVec=new createVector(this.x,this.y);
                    return newVec;
                }
            this.set=(x,y)=>
                {
                    this.x=x;
                    this.y=y;
                }
            this.add=(x)=>
                {
                    this.x+=x.x;
                    this.y+=x.y;
                }
            this.sub=(x)=>
                {
                    this.x-=x.x;
                    this.y-=x.y;
                }
            this.mult=(x)=>
                {
                    this.x*=x;
                    this.y*=x;
                }
            this.div=(x)=>
                {
                    this.x/=x;
                    this.y/=x;
                }
            this.normalize=()=>
                {
                    let mag=Math.sqrt(this.x**2+this.y**2);
                    if(mag!=0)
                    {
                    this.x=this.x/mag;
                    this.y=this.y/mag;
                    }
                    
                }
            this.mag=()=>
                {
                    return Math.sqrt(this.x**2+this.y**2);
                }
            this.heading=()=>
                {
                    let ang=Math.atan2(this.y,this.x)/Math.PI*180;
                    if(ang < 0) ang+=360;
                    return ang;
                }
        }
    function flushArray(arr) 
        {
        var lis = [];
        for (var i in arr) 
            {
            if (!arr[i].onScreen) lis.push(i);
            }
      for (var i in lis) 
            {
            arr.splice(lis[i], 1);
            for (var j in lis) lis[j] -= 1;
            }
        }
    let DistBween=(x1,y1,x2,y2)=>
                                {
                                    return Math.sqrt((x1-x2)**2+(y1-y2)**2);
                                };
    let Lerp=(startValue,endValue,lerpFac=2)=>
    								{
    									return startValue+(endValue-startValue)/lerpFac;
    								};
	function collisioncheckz(elem1,elem2)
				{
			return (inter_ects(elem1.posx-elem1.width/2,elem1.posy-elem1.height/2,
							   elem1.width,elem1.height,
					   		   elem2.posx-elem2.width/2,elem2.posy-elem2.height/2,
					   		   elem2.width,elem2.height
					  		  )
				   );
				}
	function collisioncheckzVec(elem1,elem2)
				{
			return (inter_ects(elem1.position.x-elem1.width/2,elem1.position.y-elem1.height/2,
							   elem1.width,elem1.height,
					   		   elem2.position.x-elem2.width/2,elem2.position.y-elem2.height/2,
					   		   elem2.width,elem2.height
					  		  )
				   );
				}
	function circularCollision(elem1,elem2)
		{
			let centerSeperation=elem1.position.copy();
			centerSeperation.sub(elem2.position);
			centerSeperation=centerSeperation.mag();
			return centerSeperation < elem1.width/2+elem2.width/2;//kmhere
		}
	function inter_ects(q1,q2,ql1,ql2,w1,w2,wl1,wl2)
				{
				if(w1>=q1)
					{
					if((w1-q1)<ql1)
						{
						if(w2>=q2)
							{
							if((w2-q2)<ql2) return true;
							return false;
							}
						else
							{
							if((q2-w2)<wl2) return true;
							return false;
							}
						}
					}
				else
					{
					if((q1-w1)<wl1)
						{
						if(w2>=q2)
							{
							if((w2-q2)<ql2) return true;
							return false;
							}
						else
							{
							if((q2-w2)<wl2) return true;
							return false;
							}
						}
					}
				}


//hfns ends


    
	</script>
</head>


<body>
	<canvas style='border:3px solid black;' onmousemove="trackMouse(event)">  
	</canvas>
	<script>	 	
	var canvas = document.querySelector('canvas');
   	ctx = canvas.getContext('2d');
   	canvas.width = window.innerWidth-35;
  	canvas.height = window.innerHeight-100;
    let xscale=canvas.width/1501;
    let yscale=canvas.height/654;
	var resize = function () 
		{
  		canvas.width = window.innerWidth-35;
  		canvas.height = window.innerHeight-100;
		};			
	window.addEventListener('resize', resize);

	document.onkeypress=function (e)
					{
					// console.log(e.keyCode);			
					if(e.keyCode==32) spacePress=true;
					if(e.keyCode==119) upPress=true;
					if(e.keyCode==100) rightPress=true;
					if(e.keyCode==115) downPress=true;
					if(e.keyCode==97) leftPress=true;
					if(e.keyCode==103) gPress=true;
					if(e.keyCode==102) fPress=true;
					if(e.keyCode==13)  enterPress=true;				
					};
	document.onkeyup=function (e)
					{	
					// console.log(e.keyCode);
					if(e.keyCode==32) spacePress=false;					
					if(e.keyCode==87) upPress=false;
					if(e.keyCode==68) rightPress=false;
					if(e.keyCode==83) downPress=false;
					if(e.keyCode==65) leftPress=false;
					if(e.keyCode==71) gPress=false;
					if(e.keyCode==70) fPress=false;
					if(e.keyCode==13)  enterPress=false;
					};

	document.onmousedown=function(e)
					{
					mousePressed=true;													
					};	
	document.onmouseup=function(e)
					{
					mousePressed=false;												
					};
	let insects=[];
	insects.push(new Insect(300*xscale,300*yscale));
	RunGame=()=>
		{
			if(spacePress)
				{
					spacePress=false;
					pauseGame=!pauseGame;
				}
			for(let x of insects)
				{
					if(!x.onScreen) continue;
					x.update();
					if(!pauseGame)
						x.display();
				}
		};

	window.addEventListener('load', 
							function () 
									{
								 	resize();									
							 		var loop = function () 
													{										                    					
													ctx.clearRect(0,0,canvas.width,canvas.height);	
													ctx.fillStyle = backGroundColor;
													ctx.fillRect(0,0,canvas.width, canvas.height);
													RunGame();				
				                                 	};
					  	     		setInterval(loop, deltaTime);					  		
									}
							);

	//Insect starts
	function Insect(posx,posy)
		{
			this.position=new createVector(posx,posy);
			this.roamingPos=[VecAdd(this.position,createdVec(300,0)),
							 VecAdd(this.position,createdVec(0,300)),
							 this.position.copy()
							];
			this.roamingIndex=0;
			this.velocity=new createVector(0,0);
			this.speed=5;
			this.onScreen=true;
			this.rotangle=0;
			this.prevRotangle=0;
			this.presentAnimationState=2;
			this.animationCounter=0;
			this.animInQueue="none";
			this.width=100*xscale;
			this.height=100*yscale;
			this.targetx=false;
			this.state="roaming";
			this.proximDist=10*xscale;
			
			this.idle_images=[];
			for(let i=0;i<1;i++)
				{
				let imgx=new Image();
				imgx.src=`./Sprites/idle${i}.png`;
				this.idle_images.push(imgx);
				}
			this.run_images=[];
			for(let i=0;i<2;i++)
				{
				let imgx=new Image();
				imgx.src=`./Sprites/run${i}.png`;
				this.run_images.push(imgx);
				}
			this.attack_images=[];
			for(let i=0;i<2;i++)
				{
				let imgx=new Image();
				imgx.src=`./Sprites/attack${i}.png`;
				this.attack_images.push(imgx);
				}
			this.animationStates=[this.idle_images,this.run_images,this.attack_images];
			this.animationT=[0,0,0];
			this.animationTMax=[5,10,5];

			this.controlAnimationSpeed=()=>
				{
					this.animationT[this.presentAnimationState]+=1;
					if(this.animationT[this.presentAnimationState] > this.animationTMax[this.presentAnimationState])
						{	
							this.animationT[this.presentAnimationState]=0;
							return true;
						}
					return false;
				}
			this.updateAnimationFrame=()=>
				{
					if(!this.controlAnimationSpeed()) return;
					this.animationCounter+=1;
                    if(this.animationCounter >= this.animationStates[this.presentAnimationState].length)
                        {
                        if(this.animInQueue=="none")
                           this.animationCounter=0;
                        else
                            {
                              this.changeAnimation(this.animInQueue);
                              this.animInQueue="none";
                            }
                        }
				}
			this.turnTowardsTarget=(targetPos)=>
				{
					
				    let targetDir=VecSub(targetPos,this.position);
				    console.log(targetDir);
                    let rawAngle=targetDir.heading();                  
                    
                    if(Math.abs(rawAngle-this.rotangle)>Math.abs(360+rawAngle-this.rotangle))
                        {
                            rawAngle+=360;
                        }
                    else if(Math.abs(rawAngle-this.rotangle)>Math.abs(360+this.rotangle-rawAngle))
                        {
                            this.rotangle+=360;
                        }
                    this.rotangle=Lerp(this.rotangle,rawAngle,9); 
                    console.log(this.rotangle);
                    if(this.rotangle > 360) this.rotangle-=360;

                    if(this.rotangle !=this.prevRotangle)
                    	{
                    	this.prevRotangle=this.rotangle;
                    	this.calculateVelocity();
                    	}
				}
			this.calculateVelocity=()=>
				{
					this.velocity.x=this.speed*Math.cos(d2r(this.rotangle));
					this.velocity.y=this.speed*Math.sin(d2r(this.rotangle));
				}
			this.moveForward=()=>
				{
					this.position.add(this.velocity);

				}
			this.reachedTarget=(dest)=>
				{
					return VecDist(this.position,dest) < this.proximDist;

				}
            this.changeAnimation=(anim)=>
                  {                    
                    if ((anim=="idle") && this.presentAnimationState!=0)
                        {
                        this.animationCounter=0;
                        this.presentAnimationState=0;
                        }
                    else if ((anim=="move") && this.presentAnimationState!=1)
                        {
                        this.animationCounter=0;
                        this.presentAnimationState=1;
                        }
                    else if ((anim=="attack") && this.presentAnimationState!=2)
                        {
                        this.animationCounter=0;
                        this.presentAnimationState=2;
                        }
                  }
			this.display=()=>
				{		            
                if(!this.onScreen) return false;
                ctx.save();
                ctx.translate(this.position.x-camX, this.position.y-camY);
                ctx.rotate(this.rotangle*Math.PI/180);		                            
                ctx.drawImage(
                              this.animationStates[this.presentAnimationState][this.animationCounter],
                              -this.width / 2,
                              -this.height / 2,
                              this.width,
                              this.height
                             ); 
                                                                    
                ctx.restore(); 
                this.updateAnimationFrame();
                //this.controlHealthBarVisibility();	                            
                //this.boxCollider.dr_w();                  
				}
			this.update=()=>
				{
				  if(!this.onScreen) return;
				  if(this.state=="roaming")
				  		{
				  		this.changeAnimation("move");
				  		this.turnTowardsTarget(this.roamingPos[this.roamingIndex]);
				  		this.moveForward();
				  		if(this.reachedTarget(this.roamingPos[this.roamingIndex]))
				  			{
				  			this.roamingIndex+=1;
				  			if(this.roamingIndex >= this.roamingPos.length)
				  				this.roamingIndex=0;
				  			}
				  		}
				}

		}
	//Insect ends

	</script>

	
</body>